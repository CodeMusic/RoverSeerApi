{% extends "simple/base.html" %}
{% from 'simple/icons.html' import icon, icon_big, icon_small %}
{% macro engine_data_form(engine_data) -%}
    {% for engine_name, kv_data in engine_data.items() %}
        {% for k, v in kv_data.items() %}
            <input type="hidden" name="engine_data-{{ engine_name }}-{{ k|e }}" value="{{ v|e }}">
        {% endfor %}
    {% endfor %}
{%- endmacro %}
{% block title %}{% if query_in_title %}{{- q|e }} - {% endif %}{% endblock %}
{% block meta %}<link rel="alternate" type="application/rss+xml" title="MusaiSearch: {{ q|e }}" href="{{ url_for('search', _external=True) }}?q={{ q|urlencode }}&amp;categories={{ selected_categories|join(",") | replace(' ','+') }}&amp;pageno={{ pageno }}&amp;time_range={{ time_range }}&amp;language={{ current_language }}&amp;safesearch={{ safesearch }}&amp;format=rss">{% endblock %}
{% block content %}
{% include 'simple/search.html' %}

<section id="ai_chat" aria-label="AI assistant" data-q="{{ q|e }}" data-categories="{{ selected_categories|join(',')|e }}" data-pageno="{{ pageno }}" data-time-range="{{ time_range|e }}" data-language="{{ current_language|e }}" data-safesearch="{{ safesearch|e }}">
  <button id="ai_chat_toggle" class="ai-toggle" type="button" aria-label="Collapse AI assistant" title="Collapse">▾</button>
  <span class="ai-brand" aria-hidden="true">Musai</span>
  <form id="ai_chat_form" aria-label="Ask Musai..." action="javascript:void(0)">
    <select id="ai_mode" aria-label="Mode">
      <option value="chat" selected>Chat</option>
      <option value="search">Search</option>
    </select>
    <input id="ai_perspective" type="checkbox" checked aria-label="Perspective Thinking">
    <label for="ai_perspective" title="Perspective Thinking (POV)">POV</label>
    <textarea id="ai_chat_input" rows="1" autocomplete="off" placeholder="Ask Musai..." inputmode="text" enterkeyhint="send" autocapitalize="sentences" aria-label="Ask Musai"></textarea>
    <button id="ai_chat_send" type="submit" title="Send" aria-label="Send">↵</button>
    <small id="ai_chat_status" aria-live="polite"></small>
  </form>
  <button id="ai_backToTop" type="button" title="Back to top" aria-label="Back to top" hidden>
    {{ icon_big('navigate-up') }}
  </button>
  <div id="ai_chat_output" hidden></div>
  <script>
    // very small helper to call your webhook with current search metadata
    const aiForm = document.getElementById('ai_chat_form');
    const aiInput = document.getElementById('ai_chat_input');
    const aiOut = document.getElementById('ai_chat_output');
    const aiStatus = document.getElementById('ai_chat_status');
    const aiSection = document.getElementById('ai_chat');
    const aiSend = document.getElementById('ai_chat_send');
    const aiToggle = document.getElementById('ai_chat_toggle');
    const aiMode = document.getElementById('ai_mode');
    const aiPerspective = document.getElementById('ai_perspective');
    const rootHtml = document.documentElement;
    const collapseStorageKey = 'musai_ai_chat_collapsed';
    let chatBusy = false;
    let internalNavInProgress = false;
    const aiBackTop = document.getElementById('ai_backToTop');
    // Auto-resize the textarea to maintain flow and reduce cognitive friction
    (function autoSizeAITextarea()
    {
      try
      {
        if (!aiInput) { return; }
        var maxHeight = 140;
        var adjust = function()
        {
          try
          {
            aiInput.style.height = 'auto';
            var h = Math.min(aiInput.scrollHeight || 0, maxHeight);
            aiInput.style.height = (h > 0 ? h : 40) + 'px';
          }
          catch (_) { /* no-op */ }
        };
        aiInput.addEventListener('input', adjust);
        // Initialize once on load
        adjust();
      }
      catch (e) { /* no-op */ }
    })();
    // Always start expanded on results pages (ignore any previous collapsed state)
    try
    {
      aiSection.classList.remove('collapsed');
      rootHtml.classList.remove('ai-chat-collapsed');
      if (aiToggle)
      {
        aiToggle.setAttribute('aria-label', 'Collapse AI assistant');
        aiToggle.title = 'Collapse';
        aiToggle.textContent = '▾';
      }
      try { localStorage.setItem(collapseStorageKey, '0'); } catch (_) { /* no-op */ }
    }
    catch (e) { /* no-op */ }

    // Toggle collapse/expand for attentional control
    aiToggle?.addEventListener('click', function(ev)
    {
      ev.preventDefault();
      ev.stopPropagation();
      const willCollapse = !aiSection.classList.contains('collapsed');
      aiSection.classList.toggle('collapsed', willCollapse);
      rootHtml.classList.toggle('ai-chat-collapsed', willCollapse);
      try { localStorage.setItem(collapseStorageKey, willCollapse ? '1' : '0'); } catch (e) { /* no-op */ }
      if (aiToggle) {
        aiToggle.setAttribute('aria-label', willCollapse ? 'Expand AI assistant' : 'Collapse AI assistant');
        aiToggle.title = willCollapse ? 'Expand' : 'Collapse';
        aiToggle.textContent = willCollapse ? '▸' : '▾';
      }
    });

    // Collapse the AI response when clicking on the results area (outside the dock)
    (function attachOutsideCollapse()
    {
      try
      {
        document.addEventListener('click', function(e)
        {
          // Ignore clicks inside the AI area
          if (aiSection && (e.target === aiSection || (e.target.closest && e.target.closest('#ai_chat'))))
          {
            return;
          }
          // Only act if the output is currently visible
          var outputVisible = aiOut && !aiOut.hidden && aiOut.innerHTML.trim() !== '';
          if (!outputVisible)
          {
            return;
          }
          // Collapse to bubbles-only mode
          aiSection.classList.add('collapsed');
          rootHtml.classList.add('ai-chat-collapsed');
          try { localStorage.setItem(collapseStorageKey, '1'); } catch (_) { /* no-op */ }
          if (aiToggle) { aiToggle.setAttribute('aria-label', 'Expand AI assistant'); aiToggle.title = 'Expand'; aiToggle.textContent = '▸'; }
        }, true);
      }
      catch (e) { /* no-op */ }
    })();

    // Expose AI busy state and internal navigation marker for other UI (overlay/header)
    try {
      window.musaiAI = window.musaiAI || {};
      window.musaiAI.isBusy = function() { return !!chatBusy; };
      window.musaiAI.markInternalNav = function() {
        internalNavInProgress = true;
        setTimeout(function() { internalNavInProgress = false; }, 3000);
      };
    } catch (_) { /* no-op */ }
    // Affordance: show integrated back-to-top when user scrolls down
    (function attachBackToTop()
    {
      try
      {
        if (!aiBackTop) { return; }
        aiBackTop.addEventListener('click', function(e)
        {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        let lastY = window.scrollY || window.pageYOffset || 0;
        let ticking = false;
        const threshold = 120;

        const show = function() { aiBackTop.hidden = false; };
        const hide = function() { aiBackTop.hidden = true; };
        hide();

        window.addEventListener('scroll', function()
        {
          const currentY = window.scrollY || window.pageYOffset || 0;
          if (ticking) { return; }
          ticking = true;
          window.requestAnimationFrame(function()
          {
            const isScrollingDown = currentY > lastY;
            if (currentY < threshold) { hide(); }
            else if (isScrollingDown) { show(); }
            else { hide(); }
            lastY = currentY;
            ticking = false;
          });
        }, { passive: true });
      }
      catch (e) { /* no-op */ }
    })();
    let typingEl = null;

    // Render a readable, dismissible error toast in the AI area
    function showAiErrorToast(message)
    {
      try
      {
        if (!aiSection) { return; }
        // Remove any existing toast to avoid stacking
        var existing = aiSection.querySelector('.ai-error-toast');
        if (existing && existing.parentNode) { existing.parentNode.removeChild(existing); }

        var toast = document.createElement('div');
        toast.className = 'ai-error-toast mystical-glow';
        toast.setAttribute('role', 'alert');
        toast.setAttribute('aria-live', 'assertive');
        toast.style.cssText = 'position:absolute;right:12px;bottom:12px;max-width:74%;background:rgba(64,38,94,.95);color:#ffffff;padding:10px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.35);display:flex;align-items:center;gap:10px;z-index:1000;';

        var label = document.createElement('span');
        label.textContent = message || 'An error occurred.';
        label.style.cssText = 'color:#ffffff;';

        var close = document.createElement('button');
        close.type = 'button';
        close.className = 'ai-toast-close';
        close.setAttribute('aria-label', 'Dismiss');
        close.textContent = '×';
        close.style.cssText = 'background:transparent;color:#ffffff;border:none;font-size:18px;cursor:pointer;line-height:1;padding:0;margin-left:auto;';
        close.addEventListener('click', function(ev)
        {
          ev.preventDefault();
          if (toast && toast.parentNode) { toast.parentNode.removeChild(toast); }
        });

        // Ensure the section can anchor absolute children
        if (!aiSection.style.position) { aiSection.style.position = 'relative'; }

        toast.appendChild(label);
        toast.appendChild(close);
        aiSection.appendChild(toast);
      }
      catch (_) { /* no-op */ }
    }

    // Mode-aware placeholder and enter key hints (mobile bottom bar)
    (function wireModeUX()
    {
      try
      {
        if (!aiMode || !aiInput) { return; }
        var apply = function()
        {
          var mode = (aiMode.value || 'chat');
          if (mode === 'search')
          {
            aiInput.placeholder = 'Search for...';
            aiInput.enterKeyHint = 'search';
            aiInput.setAttribute('inputmode', 'search');
            aiSend.setAttribute('aria-label', 'Search');
            aiSend.title = 'Search';
          }
          else
          {
            aiInput.placeholder = 'Ask Musai...';
            aiInput.enterKeyHint = 'send';
            aiInput.setAttribute('inputmode', 'text');
            aiSend.setAttribute('aria-label', 'Send');
            aiSend.title = 'Send';
          }
        };
        aiMode.addEventListener('change', apply);
        apply();
      }
      catch (_) { /* no-op */ }
    })();

    // Submit on Enter, newline on Shift+Enter
    aiInput?.addEventListener('keydown', function (ev)
    {
      // Avoid interfering with IME composition
      if (ev.isComposing || ev.keyCode === 229) { return; }
      const isEnter = ev.key === 'Enter' || ev.keyCode === 13;
      if (isEnter && !ev.shiftKey)
      {
        ev.preventDefault();
        ev.stopPropagation();
        if (typeof aiForm.requestSubmit === 'function')
        {
          aiForm.requestSubmit();
        }
        else
        {
          aiForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
        }
      }
    });

    // Click on send button triggers the same submit flow without navigating
    aiSend?.addEventListener('click', function (ev)
    {
      ev.preventDefault();
      ev.stopPropagation();
      if (typeof aiForm.requestSubmit === 'function')
      {
        aiForm.requestSubmit();
      }
      else
      {
        aiForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
      }
    });

    // Extract a concise, psychologically salient context from the visible results
    function collectTopResultsContext(limit)
    {
      const maxItems = typeof limit === 'number' ? limit : 5;
      const resultArticles = Array.from(document.querySelectorAll('#urls article.result'));
      const top = resultArticles.slice(0, maxItems);
      const items = top.map(function (article)
      {
        const anchor = article.querySelector('h3 a');
        const title = (anchor && anchor.textContent ? anchor.textContent : '').trim();
        const url = (anchor && anchor.href ? anchor.href : '').trim();
        const snippetEl = article.querySelector('p.content');
        const snippetRaw = snippetEl ? (snippetEl.innerText || snippetEl.textContent || '') : '';
        const snippet = snippetRaw.replace(/\s+/g, ' ').trim();

        // Soft limits to reduce cognitive overload
        const maxTitleLen = 140;
        const maxSnippetLen = 220;
        const titleShort = title.length > maxTitleLen ? (title.slice(0, maxTitleLen - 1) + '…') : title;
        const snippetShort = snippet.length > maxSnippetLen ? (snippet.slice(0, maxSnippetLen - 1) + '…') : snippet;

        return { title: titleShort, url: url, snippet: snippetShort };
      }).filter(function (x)
      {
        return x.title || x.url || x.snippet;
      });

      return items;
    }

    // Normalize and strip non-informational symbols for concise context blocks
    function sanitizeForContext(value)
    {
      try
      {
        var s = String(value || '');
        s = s.replace(/\s+/g, ' ').trim();
        var unicodeStrip = null;
        try { unicodeStrip = new RegExp("[^\\p{L}\\p{N}\\s\\.,;:\\-\\(\\)\\!\\?\\'\\\"]", "gu"); } catch (_) { unicodeStrip = null; }
        if (unicodeStrip)
        {
          s = s.replace(unicodeStrip, ' ');
        }
        else
        {
          s = s.replace(/[^A-Za-z0-9\s\.,;:\-\(\)\!\?'\"]/g, ' ');
        }
        s = s.replace(/\s{2,}/g, ' ').trim();
        return s;
      }
      catch (_) { return (value || '').toString(); }
    }

    aiForm?.addEventListener('submit', async function (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const mode = (aiMode && aiMode.value) || 'chat';
      // If currently collapsed, expand to accept input
      if (aiSection.classList.contains('collapsed'))
      {
        aiSection.classList.remove('collapsed');
        rootHtml.classList.remove('ai-chat-collapsed');
        try { localStorage.setItem(collapseStorageKey, '0'); } catch (e) { /* no-op */ }
        if (aiToggle) { aiToggle.setAttribute('aria-label', 'Collapse AI assistant'); aiToggle.title = 'Collapse'; aiToggle.textContent = '▾'; }
      }
      const userPrompt = aiInput.value.trim();
      if (!userPrompt) {
        return;
      }

      // If Search mode, perform a search instead of calling AI
      if (mode === 'search')
      {
        try
        {
          const hasScheme = function(value) { return /^(?:[a-z][a-z0-9+.-]*):\/\//i.test(value); };
          const looksLikeUrl = function(value)
          {
            if (!value || /\s/.test(value)) { return false; }
            if (hasScheme(value)) { return true; }
            if (/^www\./i.test(value)) { return true; }
            if (/^(?:localhost)(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return true; }
            if (/^(?:\d{1,3})(?:\.\d{1,3}){3}(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return true; }
            return /^[^\s]+\.[a-z]{2,}(?:[\/?#].*)?$/i.test(value);
          };
          const normalizeUrl = function(value)
          {
            if (!value) { return value; }
            if (hasScheme(value)) { return value; }
            if (/^www\./i.test(value)) { return 'https://' + value; }
            if (/^(?:localhost|\d{1,3}(?:\.\d{1,3}){3})(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return 'http://' + value; }
            return 'https://' + value;
          };

          if (looksLikeUrl(userPrompt))
          {
            const finalUrl = normalizeUrl(userPrompt);
            try { window.musaiAI && typeof window.musaiAI.markInternalNav === 'function' && window.musaiAI.markInternalNav(); } catch (_) {}
            if (window.musaiOverlayAPI && typeof window.musaiOverlayAPI.open === 'function')
            {
              window.musaiOverlayAPI.open(finalUrl, 'ai-mode-search-url');
            }
            else
            {
              try { window.open(finalUrl, '_blank', 'noopener'); } catch (_) {}
            }
            return;
          }

          // Navigate to results with q and existing categories if present
          const ds = aiSection?.dataset || {};
          const categories = (ds.categories || '').split(',').filter(Boolean).join(',');
          const base = "{{ url_for('search') }}";
          const url = base + '?q=' + encodeURIComponent(userPrompt) + (categories ? ('&categories=' + encodeURIComponent(categories)) : '');
          try { window.location.href = url; } catch (_) {}
          return;
        }
        catch (_) { return; }
      }

      // Disable input & send to prevent duplicate submissions
      aiInput.disabled = true;
      aiSend.disabled = true;
      aiStatus.textContent = '';
      aiOut.hidden = true;
      chatBusy = true;

      // Render Musai-style typing indicator
      try {
        if (!typingEl) {
          typingEl = document.createElement('div');
          typingEl.className = 'ai-typing-bubble mystical-glow';
          typingEl.setAttribute('role', 'status');
          typingEl.setAttribute('aria-live', 'polite');
          typingEl.innerHTML = `
            <span class="ai-typing-icon" aria-hidden="true"><img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt=""></span>
            <span class="ai-typing-label">Musai is thinking</span>
            <span style="display:inline-flex;align-items:center;gap:4px;margin-left:6px;">
              <span class="ai-typing-dot mystical-dots" style="animation-delay:0ms"></span>
              <span class="ai-typing-dot mystical-dots" style="animation-delay:200ms"></span>
              <span class="ai-typing-dot mystical-dots" style="animation-delay:400ms"></span>
            </span>
          `;
        }
        // Place indicator to the left of the AI text entry
        if (typingEl.parentNode !== aiForm) {
          try { aiForm.insertBefore(typingEl, aiInput); } catch (_) { /* no-op */ }
        }
        // Keep output bubble hidden until we have a response
        aiOut.hidden = true;
        aiOut.innerHTML = '';
      } catch (e) {
        /* no-op */
      }

      // stable client session id using localStorage
      const storageKey = 'musai_session_id';
      let sessionId = localStorage.getItem(storageKey);
      if (!sessionId) {
        sessionId = 'web-' + Date.now() + '-' + Math.random().toString(36).slice(2);
        localStorage.setItem(storageKey, sessionId);
      }

      const ds = aiSection?.dataset || {};
      // Build search-contextual payload
      const contextResults = collectTopResultsContext(5);

      // If the overlay iframe is same-origin, extract a readable text context
      let overlayContextBlock = '';
      try
      {
        if (window.musaiOverlayAPI && typeof window.musaiOverlayAPI.isOpen === 'function' && window.musaiOverlayAPI.isOpen())
        {
          if (typeof window.musaiOverlayAPI.contextBlock === 'function')
          {
            overlayContextBlock = window.musaiOverlayAPI.contextBlock({ maxChars: 2000 }) || '';
          }
          // Fallback: when the iframe is cross-origin or otherwise unreadable, provide a clear placeholder
          try
          {
            if (!overlayContextBlock)
            {
              var lk = (window.musaiOverlayAPI && typeof window.musaiOverlayAPI.lastKnownUrl === 'function') ? (window.musaiOverlayAPI.lastKnownUrl() || '') : '';
              if (!lk) {
                lk = '';
              }

              overlayContextBlock = '[Current Context:\nUnable to view this page content.\nURL: ' + lk + '\n]';
              
            }
          }
          catch (_) { /* no-op */ }
        }
      }
      catch (_) { /* no-op */ }

      // Build a labeled context block for search results; label as previous when overlay is active
      let resultsBlock = '';
      try
      {
        if (contextResults && contextResults.length)
        {
          const lines = contextResults.map(function (r, idx)
          {
            const title = sanitizeForContext(r.title || r.url || 'Untitled');
            const snippet = sanitizeForContext(r.snippet || '');
            const url = (r.url || '').trim();
            return (idx + 1) + ') ' + title + (url ? (' — ' + url) : '') + (snippet ? ('\n   ' + snippet) : '');
          }).join('\n');
          if (overlayContextBlock)
          {
            resultsBlock = '[Previous User Search Results Context:\n' + lines + '\n]';
          }
          else
          {
            resultsBlock = '[User Search Results Context:\n' + lines + '\n]';
          }
        }
      }
      catch (_) { /* no-op */ }

      let combinedQuery = userPrompt;
      if (resultsBlock && overlayContextBlock)
      {
        combinedQuery = resultsBlock + '\n\n' + overlayContextBlock + '\n\n' + userPrompt;
      }
      else if (overlayContextBlock)
      {
        combinedQuery = overlayContextBlock + '\n\n' + userPrompt;
      }
      else if (resultsBlock)
      {
        combinedQuery = resultsBlock + '\n\n' + userPrompt;
      }

      // Detect if userPrompt looks like a direct URL; used when overlay is closed
      function inferUrlFromPrompt(prompt)
      {
        try
        {
          var raw = (prompt || '').trim();
          if (!raw) { return ''; }
          try
          {
            var u1 = new URL(raw);
            return u1.href;
          }
          catch (_)
          {
            // Heuristic: add scheme if missing (example.com/foo)
            if (/^www\.[^\s]+/i.test(raw) || /[^\s]+\.[a-z]{2,}(?:[\/?#]|$)/i.test(raw))
            {
              try { var u2 = new URL('https://' + raw); return u2.href; } catch (__) { /* no-op */ }
            }
          }
        }
        catch (_) { /* no-op */ }
        return '';
      }

      // If overlay is open, capture last known URL and navigation state; otherwise, use prompt-derived URL if any
      var overlayUrl = '';
      var overlayState = { isOpen: false, initialUrl: '', lastKnownUrl: '', loadCount: 0, navigatedAway: false };
      try
      {
        var open = (window.musaiOverlayAPI && typeof window.musaiOverlayAPI.isOpen === 'function' && window.musaiOverlayAPI.isOpen());
        if (open)
        {
          try { overlayUrl = (window.musaiOverlayAPI.lastKnownUrl && window.musaiOverlayAPI.lastKnownUrl()) || (window.musaiOverlayAPI.currentUrl && window.musaiOverlayAPI.currentUrl()) || ''; } catch (__) { /* no-op */ }
          try { overlayState = (window.musaiOverlayAPI.state && window.musaiOverlayAPI.state()) || overlayState; } catch (__) { /* no-op */ }
        }
        else
        {
          overlayUrl = inferUrlFromPrompt(userPrompt) || '';
        }
      }
      catch (_) { /* no-op */ }

      // If navigated away inside the iframe, append a human-readable bracketed note to the AI message
      let effectiveQuery = combinedQuery;
      try
      {
        if (overlayState && overlayState.isOpen && overlayState.navigatedAway)
        {
          effectiveQuery = combinedQuery + '\n\n[ The user has navigated away from the search so we do not know their current page ]';
        }
      }
      catch (_) { /* no-op */ }

      const payload = {
        sessionId: sessionId,
        query: effectiveQuery,
        action: 'webhookChat',
        url: overlayUrl,
        meta: JSON.stringify({ search: {
          q: ds.q || '',
          selected_categories: (ds.categories || '').split(',').filter(Boolean),
          pageno: parseInt(ds.pageno || '1', 10),
          time_range: ds.timeRange || '',
          language: ds.language || '',
          safesearch: ds.safesearch || ''
        }, contextResults: contextResults, overlay: overlayState })
      };

      // Read POV toggle and attach as perspective=true/false
      const povEnabled = !!(aiPerspective && aiPerspective.checked);
      const povParam = povEnabled ? 'true' : 'false';
      try { payload.perspective = povParam; } catch (_) { /* no-op */ }

      try {
        // Add last_known_url as an explicit parameter on the webhook URL
        let lastKnownForParam = '';
        try
        {
          lastKnownForParam = (overlayState && overlayState.lastKnownUrl) || overlayUrl || '';
        }
        catch (_) { /* no-op */ }
        const webhookBase = 'https://n8n.codemusic.ca/webhook/chat/message';
        const qsParts = [];
        if (lastKnownForParam) { qsParts.push('url=' + encodeURIComponent(lastKnownForParam)); }
        qsParts.push('perspective=' + povParam);
        const webhookUrl = webhookBase + (qsParts.length ? ('?' + qsParts.join('&')) : '');
        const res = await fetch(webhookUrl, {
          method: 'POST',
          headers: Object.assign(
            { 'Content-Type': 'application/json' },
            (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function')
              ? window.musaiN8N.getAuthHeader()
              : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }
          ),
          body: JSON.stringify(payload),
          credentials: 'omit',
          cache: 'no-store'
        });
        if (!res.ok) {
          throw new Error('HTTP ' + res.status);
        }
        const data = await res.json();
        // Normalize to first record shape { response, pov }
        const record = Array.isArray(data) ? (data[0] || {}) : (data || {});
        const responseText = record.response || '';
        const pov = Array.isArray(record.pov) ? record.pov : [];

        // Clear output and remove typing indicator
        aiOut.innerHTML = '';
        try { if (typingEl && typingEl.parentNode) { typingEl.parentNode.removeChild(typingEl); } } catch (_) { /* no-op */ }
        typingEl = null;

        // Main response (purplish bubble)
        const main = document.createElement('div');
        main.className = 'ai-main-bubble';
        main.textContent = responseText || (Object.keys(record).length ? JSON.stringify(record, null, 2) : '');

        // Extract logical/creative thoughts if present
        let logicalThought = '';
        let creativeThought = '';
        let perspectiveThought = '';
        for (const p of pov) {
          const t = (p && (p.type || p.name) || '').toString().toLowerCase();
          if (!logicalThought && (t === 'logical' || /logic/.test(t)) && typeof p.thought === 'string') {
            logicalThought = p.thought;
          }
          if (!creativeThought && (t === 'creative' || /creativ/.test(t)) && typeof p.thought === 'string') {
            creativeThought = p.thought;
          }
          if (!perspectiveThought && (t === 'perspective' || /perspective|perspec/.test(t)) && typeof p.thought === 'string') {
            perspectiveThought = p.thought;
          }
        }

        if (logicalThought || creativeThought || perspectiveThought) {
          const toggles = document.createElement('div');
          toggles.className = 'ai-pov-toggle-group';

          const redBtn = document.createElement('button');
          redBtn.type = 'button';
          redBtn.className = 'ai-pov-toggle red';
          redBtn.textContent = 'Logical';
          if (!logicalThought) redBtn.disabled = true;

          const blueBtn = document.createElement('button');
          blueBtn.type = 'button';
          blueBtn.className = 'ai-pov-toggle blue';
          blueBtn.textContent = 'Creative';
          if (!creativeThought) blueBtn.disabled = true;

          const violetBtn = document.createElement('button');
          violetBtn.type = 'button';
          violetBtn.className = 'ai-pov-toggle violet';
          violetBtn.textContent = 'Perspective';
          if (!perspectiveThought) violetBtn.disabled = true;

          const redPanel = document.createElement('div');
          redPanel.className = 'ai-pov-panel red';
          redPanel.textContent = logicalThought || '';
          redPanel.hidden = true;

          const bluePanel = document.createElement('div');
          bluePanel.className = 'ai-pov-panel blue';
          bluePanel.textContent = creativeThought || '';
          bluePanel.hidden = true;

          const violetPanel = document.createElement('div');
          violetPanel.className = 'ai-pov-panel violet';
          violetPanel.textContent = perspectiveThought || '';
          violetPanel.hidden = true;

          function setActive(which) {
            const isRed = which === 'red';
            const isBlue = which === 'blue';
            const isViolet = which === 'violet';
            // Only one visible at a time: when a POV is active, hide the main response
            main.hidden = !!which;
            redPanel.hidden = !isRed;
            bluePanel.hidden = !isBlue;
            violetPanel.hidden = !isViolet;
            redBtn.classList.toggle('active', isRed);
            blueBtn.classList.toggle('active', isBlue);
            violetBtn.classList.toggle('active', isViolet);
          }

          redBtn.addEventListener('click', function () {
            if (redBtn.disabled) return;
            setActive(!redBtn.classList.contains('active') ? 'red' : null);
          });
          blueBtn.addEventListener('click', function () {
            if (blueBtn.disabled) return;
            setActive(!blueBtn.classList.contains('active') ? 'blue' : null);
          });
          violetBtn.addEventListener('click', function () {
            if (violetBtn.disabled) return;
            setActive(!violetBtn.classList.contains('active') ? 'violet' : null);
          });

          // Render header first, then the single visible content beneath it
          aiOut.appendChild(toggles);
          toggles.appendChild(redBtn);
          toggles.appendChild(blueBtn);
          toggles.appendChild(violetBtn);
          aiOut.appendChild(main);
          aiOut.appendChild(redPanel);
          aiOut.appendChild(bluePanel);
          aiOut.appendChild(violetPanel);
          // default: show only main response
          setActive(null);
        } else {
          // No POVs: just show main response
          aiOut.appendChild(main);
        }

        aiOut.hidden = false;
      } catch (err) {
        try { if (typingEl && typingEl.parentNode) { typingEl.parentNode.removeChild(typingEl); } } catch (_) { /* no-op */ }
        typingEl = null;
        // Show a high-contrast, dismissible error toast instead of plain text
        showAiErrorToast('Error contacting AI service.');
        aiOut.hidden = true;
      } finally {
        aiStatus.textContent = '';
        // Re-enable controls
        aiInput.disabled = false;
        aiSend.disabled = false;
        chatBusy = false;
      }
    });

    // Prevent accidental navigation while Musai is thinking
    window.addEventListener('beforeunload', function (e) {
      if (chatBusy && !internalNavInProgress) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // Intercept clicks on links while chat is busy: offer Open in Musai / Leave / Cancel
    document.addEventListener('click', function (e) {
      if (!chatBusy) { return; }
      var anchor = e.target && (e.target.closest ? e.target.closest('a[href]') : null);
      if (!anchor) { return; }
      try {
        // Respect user intent for new-tab/middle-click
        if (e.metaKey || e.ctrlKey || e.shiftKey || e.button === 1) { return; }

        // Ignore in-page UI controls (collapse/media loaders/maps/etc.)
        var ignoreUi = (
          anchor.classList.contains('media-loader') ||
          anchor.classList.contains('btn-collapse') ||
          anchor.hasAttribute('data-target') ||
          anchor.hasAttribute('data-toggle')
        );
        if (ignoreUi) { return; }

        var href = anchor.getAttribute('href') || '';
        if (!href || href === '#') { return; }

        var isHashLink = href.charAt(0) === '#';
        if (isHashLink) { return; }

        // Allow same-origin navigations (staying within Musai) without interruption
        var dest;
        try { dest = new URL(href, window.location.href); } catch (_) { dest = null; }
        if (dest && dest.origin === window.location.origin) {
          internalNavInProgress = true;
          return;
        }

        // Detect direct media/doc links (images, audio/video, pdf) and offer to open in new tab or Musai
        var isMedia = /\.(png|jpe?g|gif|webp|svg|bmp|ico|pdf|mp3|wav|ogg|flac|mp4|m4v|webm|mov)([#?].*)?$/i.test(href);
        e.preventDefault();
        e.stopPropagation();
        var promptMsg = 'Musai is thinking. What would you like to do with this link?';
        var openMusai = window.confirm(promptMsg + '\n\nOK = Open in Musai overlay\nCancel = More options');
        if (openMusai) {
          try { window.musaiOverlayAPI && window.musaiOverlayAPI.open(href, (anchor.id || '')); } catch (_) {}
          return;
        }
        if (isMedia) {
          var openNewTab = window.confirm('Open in a new tab instead?\n\nOK = New tab\nCancel = Cancel');
          if (openNewTab) { try { window.open(href, '_blank', 'noopener'); } catch (_) {} }
          return;
        }
        var leave = window.confirm('Leave this page and open the link here?\n\nOK = Leave site\nCancel = Cancel');
        if (leave) { try { window.location.href = href; } catch (_) {} }
        return;
      } catch (_) { /* no-op */ }
    }, true);

    // Intercept any form submissions (e.g., categories, pagination) while busy
    document.addEventListener('submit', function (e) {
      if (!chatBusy) { return; }
      try {
        var form = e.target;
        if (form && form.action) {
          var dest = new URL(form.action, window.location.href);
          if (dest.origin === window.location.origin) {
            internalNavInProgress = true;
            return;
          }
        }
      } catch (_) { /* no-op */ }
      var ok = window.confirm('Musai is thinking. Submitting will cancel the response. Continue?');
      if (!ok) { e.preventDefault(); e.stopPropagation(); }
    }, true);
  </script>
</section>

{% if results and results|map(attribute='template')|unique|list|count == 1 %}
  {% set only_template = 'only_template_' + results[0]['template']|default('default')|replace('.html', '') %}
{% else %}
  {% set only_template = '' %}
{% endif %}

<div id="results" class="{{ only_template }}">

  {%- if answers -%}
    {%- include 'simple/elements/answers.html' -%}
  {%- endif %}

    <div id="sidebar">

        {%- if number_of_results != '0' -%}
        <p id="result_count"><small>{{ _('Number of results') }}: {{ number_of_results }}</small></p>
        {%- endif -%}

        {%- if infoboxes -%}
          <div id="infoboxes">
            <details open class="sidebar-collapsible">
              <summary class="title">{{ _('Info') }}</summary>
              {%- for infobox in infoboxes -%}
                {%- include 'simple/elements/infobox.html' -%}
              {%- endfor -%}
            </details>
          </div>
        {%- endif -%}

        {%- if suggestions -%}
          {%- include 'simple/elements/suggestions.html' -%}
        {%- endif -%}

        {%- include 'simple/elements/engines_msg.html' -%}

        {%- if method == 'POST' -%}
          {%- include 'simple/elements/search_url.html' -%}
        {%- endif -%}

        {%- if search_formats -%}
          {%- include 'simple/elements/apis.html' -%}
        {%- endif -%}

        <div id="sidebar-end-collapsible"></div>
    </div>

    {%- if corrections -%}
      {%- include 'simple/elements/corrections.html' -%}
    {%- endif -%}

    <div id="urls" role="main">
    {% for result in results %}
        {% if result.open_group and not only_template %}<div class="template_group_{{ result['template']|replace('.html', '') }}">{% endif %}
        {% set index = loop.index %}
        {% include get_result_template('simple', result['template']) %}
        {% if result.close_group and not only_template %}</div>{% endif %}
    {% endfor %}
    {% if not results and not answers %}
        {% include 'simple/messages/no_results.html' %}
    {% endif %}
    </div>
    <div id="backToTop">
      <a href="#" aria-label="{{ _('Back to top') }}">{{ icon_small('navigate-up') }}</a>
    </div>
    {% if paging %}
    <nav id="pagination" role="navigation">
        {% if pageno > 1 %}
            <form method="{{ method or 'POST' }}" action="{{ url_for('search') }}" class="previous_page">
                <div class="{% if rtl %}right{% else %}left{% endif %}">
                  <input type="hidden" name="q" value="{{ q|e }}" >
                  {% for category in selected_categories %}
                  <input type="hidden" name="category_{{ category }}" value="1" >
                  {% endfor %}
                  <input type="hidden" name="pageno" value="{{ pageno-1 }}" >
                  <input type="hidden" name="language" value="{{ current_language }}" >
                  <input type="hidden" name="time_range" value="{{ time_range }}" >
                  <input type="hidden" name="safesearch" value="{{ safesearch }}" >
                  <input type="hidden" name="theme" value="{{ theme }}" >
                  {% if timeout_limit %}<input type="hidden" name="timeout_limit" value="{{ timeout_limit|e }}" >{% endif %}
                  {{- engine_data_form(engine_data) -}}
                  <button role="link" type="submit">{{ icon_small('navigate-left') }} {{ _('Previous page') }}</button>
                </div>
            </form>
        {% endif %}
        {%- if results | count > 0 -%}
          <form method="{{ method or 'POST' }}" action="{{ url_for('search') }}" class="next_page">
              <div class="{% if rtl %}left{% else %}right{% endif %}">
                <input type="hidden" name="q" value="{{ q|e }}" >
                {% for category in selected_categories %}
                <input type="hidden" name="category_{{ category }}" value="1" >
                {% endfor %}
                <input type="hidden" name="pageno" value="{{ pageno+1 }}" >
                <input type="hidden" name="language" value="{{ current_language }}" >
                <input type="hidden" name="time_range" value="{{ time_range }}" >
                <input type="hidden" name="safesearch" value="{{ safesearch }}" >
                <input type="hidden" name="theme" value="{{ theme }}" >
                {% if timeout_limit %}<input type="hidden" name="timeout_limit" value="{{ timeout_limit|e }}" >{% endif %}
                {{- engine_data_form(engine_data) -}}
                <button role="link"  type="submit">{{ _('Next page') }} {{ icon_small('navigate-right') }}</button>
              </div>
          </form>
        {%- endif -%}
        {% set pstart = 1 %}
        {% set pend = 11 %}
        {% if pageno > 5 %}
            {% set pstart = pageno - 4 %}
            {% set pend = pageno + 6 %}
        {% endif %}

        <div class="numbered_pagination">
        {% for x in range(pstart, pend) %}
            <form method="{{ method or 'POST' }}" action="{{ url_for('search') }}" class="page_number">
                <input type="hidden" name="q" value="{{ q|e }}" >
                {% for category in selected_categories %}
                <input type="hidden" name="category_{{ category }}" value="1" >
                {% endfor %}
                <input type="hidden" name="pageno" value="{{ x }}" >
                <input type="hidden" name="language" value="{{ current_language }}" >
                <input type="hidden" name="time_range" value="{{ time_range }}" >
                <input type="hidden" name="safesearch" value="{{ safesearch }}" >
                <input type="hidden" name="theme" value="{{ theme }}" >
                {% if timeout_limit %}<input type="hidden" name="timeout_limit" value="{{ timeout_limit|e }}" >{% endif %}
                {{- engine_data_form(engine_data) -}}
                {% if pageno == x %}
                <input role="link" class="page_number_current" type="button" value="{{ x }}">
                {% else %}
                <input role="link" class="page_number" type="submit" value="{{ x }}">
                {% endif %}
            </form>
        {% endfor %}
        </div>
    </nav>
    {% endif %}
</div>
{% endblock %}
