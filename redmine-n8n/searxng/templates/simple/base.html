<!DOCTYPE html>
<html class="no-js theme-{{ preferences.get_value('simple_style') or get_setting('ui.theme_args.simple_style') or 'auto' }} center-alignment-{{ preferences.get_value('center_alignment') and 'yes' or 'no' }}" lang="{{ locale_rfc5646 }}" {% if rtl %} dir="rtl"{% endif %}>
<head>
  <meta charset="UTF-8">
  <meta name="endpoint" content="{{ endpoint }}">
  <meta name="description" content="MusaiSearch — a privacy-respecting, purple-steel metasearch experience">
  <meta name="keywords" content="MusaiSearch, search, search engine, metasearch, music, code, purple steel">
  <meta name="generator" content="searxng/{{ searx_version }}">
  <meta name="referrer" content="no-referrer">
  <meta name="robots" content="noarchive">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <meta name="theme-color" content="#1e2030">
  <style>
    /* Paint-safe fallback to avoid white flash before CSS loads */
    html,
    body {
      background: #1e2030;
      color: #ececf4;
    }
    html.theme-light,
    html.theme-light body {
      background: #eafaf7;
      color: #222222;
    }
    html.theme-black,
    html.theme-black body {
      background: #000000;
      color: #e5e7eb;
    }
  </style>
  <style>
    /* Small inline Musai icon next to titles */
    .musai-open-iframe {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 6px;
      padding: 0;
      background: transparent;
      border: 2px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      vertical-align: middle;
      /* Ensure this sits above any row-wide overlay link */
      position: relative;
      z-index: 5;
      pointer-events: auto;
    }
    /* Remove morty border indicators from Musai button */
    .musai-inline-icon {
      width: 16px;
      height: 16px;
      opacity: .88;
      transition: transform .15s ease, opacity .15s ease, filter .15s ease;
    }
    .musai-open-iframe:hover .musai-inline-icon {
      opacity: 1;
      transform: scale(1.15);
      filter: brightness(1.15);
    }

    /* Create a stacking context so the inline button can layer above stretched links */
    .result h3 { position: relative; }
    /* Lower the z-index of the row overlay compared to the Musai button (if any is set) */
    .result .url_header { z-index: 1; }

    /* Fullscreen overlay to host iframe + top bar */
    #musaiOverlay {
      position: fixed;
      inset: 0;
      background: var(--musai-bg);
      z-index: 980; /* below AI chat (999) but above rest */
      display: none;
      flex-direction: column;
      /* Reserve space for the docked AI chat + iPhone home indicator */
      padding-bottom: calc(120px + env(safe-area-inset-bottom));
    }
    #musaiOverlay[aria-hidden="false"] { display: flex; }
    #musaiOverlayTopbar {
      display: flex;
      align-items: center;
      gap: 10px;
      /* Keep clear of the notch on iPhone */
      padding: calc(8px + env(safe-area-inset-top)) 12px 8px 12px;
      background: var(--musai-bg-2);
      border-bottom: 1px solid var(--musai-primary);
      position: relative;
      z-index: 2; /* keep above loading veil */
    }
    #musaiOverlayTopbar .musai-logo {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--musai-text);
      text-decoration: none;
      font-weight: 600;
    }
    #musaiOverlayTopbar .musai-logo img { width: 18px; height: 18px; }
    /* Gradient wordmark for MusaiSearch in overlay */
    #musaiOverlayTopbar .musai-logo .wordmark
    {
      display: inline-flex;
      align-items: baseline;
      gap: 2px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    #musaiOverlayTopbar .musai-logo .wordmark .musai
    {
      background: linear-gradient(90deg, #0ea5a3 0%, #22c55e 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }
    #musaiOverlayTopbar .musai-logo .wordmark .search
    {
      background: linear-gradient(90deg, #f59e0b 0%, #84cc16 60%, #22c55e 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }
    #musaiOverlayTopbar form.musai-search {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
      flex: 1;
    }
    #musaiOverlayTopbar form.musai-search input[type="text"] {
      width: 100%;
      min-width: 120px;
      height: 36px;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid var(--musai-primary);
      background: rgba(0,0,0,0.15);
      color: var(--musai-text);
    }
    #musaiOverlayTopbar form.musai-search button[type="submit"] {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 10px;
      border: 0;
      height: 36px;
      padding: 0 10px;
      cursor: pointer;
      flex: 0 0 auto;
    }
    #musaiOverlayTopbar .toolbar-spacer { flex: 0 0 auto; width: 0; }
    #musaiOverlayTopbar button {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 8px;
      border: 0;
      padding: 6px 10px;
      cursor: pointer;
    }
    #musaiOverlayTopbar button:hover { filter: brightness(1.1); }
    #musaiOverlayFrame {
      flex: 1;
      border: 0;
      width: 100%;
    }
    /* Mystical loading veil shown while iframe is fetching */
    #musaiOverlayLoading {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 50% 40%, rgba(107,91,149,.18), rgba(30,32,48,.88));
      pointer-events: none; /* keep toolbar interactive */
      z-index: 1; /* above iframe */
    }
    #musaiOverlay[data-loading="true"] #musaiOverlayLoading { display: flex; }
    /* Harmonize bubble colors over the veil */
    #musaiOverlayLoading .ai-typing-bubble {
      background: rgba(107,91,149,.18);
      border-color: rgba(107,91,149,.45);
    }
  </style>
  <script>
    (function setThemeColorImmediate()
    {
      try
      {
        var cls = document.documentElement.className || '';
        var isAuto = /(^|\s)theme-auto(\s|$)/.test(cls);
        var getESTHour = function()
        {
          try
          {
            return parseInt(new Intl.DateTimeFormat('en-US', { hour: 'numeric', hour12: false, timeZone: 'America/New_York' }).format(new Date()), 10);
          }
          catch (e)
          {
            return (new Date()).getUTCHours();
          }
        };
        var prefersLight = isAuto
          ? (function(){ var h = getESTHour(); return h >= 7 && h < 19; })()
          : (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches);
        var light = '#eafaf7';
        var dark = '#1e2030';
        var black = '#000000';
        var color = dark;
        if ((/(^|\s)theme-light(\s|$)/.test(cls)) || (isAuto && prefersLight))
        {
          color = light;
        }
        if (/(^|\s)theme-black(\s|$)/.test(cls))
        {
          color = black;
        }
        var meta = document.querySelector('meta[name="theme-color"]');
        if (meta) { meta.setAttribute('content', color); }
        document.documentElement.style.backgroundColor = color;
        if (document.body) { document.body.style.backgroundColor = color; }
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  <script>
    (function defineN8NAuth()
    {
      try
      {
        var rawCredentials = 'siteuser:codemusai';
        var token = (window.btoa ? ('Basic ' + btoa(rawCredentials)) : 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp');
        window.musaiN8N = window.musaiN8N || {};
        window.musaiN8N.authToken = token;
        window.musaiN8N.getAuthHeader = function()
        {
          return { 'Authorization': window.musaiN8N.authToken };
        };
      }
      catch (_)
      {
        window.musaiN8N = window.musaiN8N || {};
        window.musaiN8N.authToken = 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp';
        window.musaiN8N.getAuthHeader = function()
        {
          return { 'Authorization': window.musaiN8N.authToken };
        };
      }
    })();
  </script>
  <title>{% block title %}{% endblock %}{{ instance_name }}</title>
  {% block meta %}{% endblock %}
  {% if rtl %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/searxng-rtl.min.css') }}" type="text/css" media="screen">
  {% else %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/searxng-ltr.min.css') }}" type="text/css" media="screen">
  {% endif %}
  {% if get_setting('server.limiter') or get_setting('server.public_instance') %}
  <link rel="stylesheet" href="{{ url_for('client_token', token=link_token) }}" type="text/css">
  {% endif %}
  <script>
    // update the css
    document.documentElement.classList.remove('no-js');
    document.documentElement.classList.add('js');
  </script>
  <script>
    (function detectInIframe()
    {
      try
      {
        if (window.top !== window.self)
        {
          document.documentElement.classList.add('in-iframe');
        }
      }
      catch (e)
      {
        document.documentElement.classList.add('in-iframe');
      }
    })();
  </script>
  <script>
    (function applyEstAutoTheme()
    {
      try
      {
        var root = document.documentElement;
        if (!/(^|\s)theme-auto(\s|$)/.test(root.className)) { return; }
        var getESTHour = function()
        {
          try
          {
            return parseInt(new Intl.DateTimeFormat('en-US', { hour: 'numeric', hour12: false, timeZone: 'America/New_York' }).format(new Date()), 10);
          }
          catch (e)
          {
            return (new Date()).getUTCHours();
          }
        };
        var apply = function()
        {
          var hour = getESTHour();
          var estLight = hour >= 7 && hour < 19;
          root.classList.remove('est-light', 'est-dark');
          root.classList.add(estLight ? 'est-light' : 'est-dark');
          var color = estLight ? '#eafaf7' : '#1e2030';
          var meta = document.querySelector('meta[name="theme-color"]');
          if (meta) { meta.setAttribute('content', color); }
        };
        apply();
        setInterval(apply, 300000); // refresh every 5 minutes
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  {% block head %}
  <link title="{{ instance_name }}" type="application/opensearchdescription+xml" rel="search" href="{{ opensearch_url }}">
  {% endblock %}
  <link rel="icon" href="{{ url_for('static', filename='img/favicon.png') }}" sizes="any">
  <link rel="apple-touch-icon" href="{{ url_for('static', filename='img/favicon.png') }}">
  <style>
    :root {
      --musai-primary: #6e62a6; /* deeper purple-steel */
      --musai-accent: #9aa3c7;  /* cooler steel accent */
      --musai-bg: #1e2030;      /* slightly cooler base */
      --musai-bg-2: #2a2e42;    /* purple-steel surface */
      --musai-text: #ececf4;
      --musai-muted: #aab0c8;
    }
    /* Light mode palette and surfaces */
    html.theme-light {
      --musai-primary: #0f766e; /* teal-700 */
      --musai-accent: #14b8a6;  /* teal-500 */
      --musai-bg: #eafaf7;      /* very light teal */
      --musai-bg-2: #dff5f0;    /* very light teal (accent) */
      --musai-text: #222222;    /* dark text for contrast */
      --musai-muted: #506a6a;   /* muted teal-gray */
    }
    @media (prefers-color-scheme: light) {
      html.theme-auto {
        --musai-primary: #0f766e;
        --musai-accent: #14b8a6;
        --musai-bg: #eafaf7;
        --musai-bg-2: #dff5f0;
        --musai-text: #222222;
        --musai-muted: #506a6a;
      }
    }
    body {
      background: var(--musai-bg);
      color: var(--musai-text);
    }
    /* Keep content clear of the docked AI bar */
    main {
      padding-bottom: calc(120px + env(safe-area-inset-bottom));
    }
    /* When AI chat is collapsed, reduce the cognitive footprint at the bottom */
    html.ai-chat-collapsed main {
      padding-bottom: calc(56px + env(safe-area-inset-bottom));
    }
    a { color: var(--musai-muted); }
    a:hover { color: var(--musai-accent); }
    /* Ensure general text elements always inherit theme-aware font color */
    h1, h2, h3, h4, h5, h6,
    p, li, dt, dd,
    th, td,
    label, summary, figcaption
    {
      color: var(--color-base-font);
    }
    /* Ensure Musai badge text contrasts per theme (white on dark) */
    #links_on_top .link_on_top_musai span { color: var(--musai-text); }
    /* Home page title behaves like a text logo; make it about 2x larger */
    #main_index .title h1
    {
      font-size: 3rem;
      line-height: 1.1;
      margin: 0 0 8px 0;
    }
    /* Home page title-image: scale any image inside .title by ~30% */
    #main_index .title img
    {
      transform: scale(1.3);
      transform-origin: center;
      display: inline-block;
    }
    /* Do not recolor custom logo assets */
    #search_logo svg circle,
    #search_logo svg path,
    #search_logo svg rect { stroke: inherit; fill: inherit; }
    #search_logo img, #search_logo picture { display: block; height: 106px; width: auto; }
    /* Home page only: scale logo to be about four times baseline (double previous) */
    #main_index #search_logo img,
    #main_index #search_logo picture
    {
      height: 424px;
    }
    /* Create healthy spacing between the logo and the search input */
    #search_header
    {
      display: flex;
      align-items: center;
      column-gap: 16px;
    }
    /* Home page: stack logo above the search bar and center them */
    #main_index #search_header
    {
      flex-direction: column;
      align-items: center;
      row-gap: 12px;
    }
    /* Home page: center the search input and set a sensible width */
    #main_index #search_view .search_box
    {
      width: min(900px, calc(100vw - 56px));
      margin: 0 auto;
    }
    /* Search page only: gently nudge the logo for better visual alignment */
    #main_search #search_logo
    {
      position: relative;
      left: -10px; /* shift left by 10px */
      top: -2px;  /* shift up by ~2px */
    }
    /* Results page only: add extra breathing room below the logo/header */
    #main_results #search_header
    {
      padding-bottom: 16px;
    }
    /* Results page (desktop): allow the search input to span available width */
    @media (min-width: 641px) {
      #main_results #search_view { flex: 1 1 auto; min-width: 240px; }
      #main_results #search_view .search_box { width: 100%; }
      #main_results #search_view #q { width: 100%; }
    }
    /* Results page only: reduce logo size by ~30% from baseline (106px → 74px) */
    #main_results #search_logo img,
    #main_results #search_logo picture
    {
      height: 74px;
    }
    /* Pages with simple header: make the top-left logo about twice as large */
    .page_with_header img.logo
    {
      height: 212px;
      width: auto;
      display: block;
    }
    .search_box {
      background: rgba(46,50,66,.6);
      border: 1px solid var(--musai-primary);
      box-shadow: 0 4px 24px rgba(0,0,0,.35);
      border-radius: 14px;
      /* Layout for input, clear affordance, and submit button */
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      column-gap: 8px;
      padding: 6px 8px;
    }
    @media (prefers-color-scheme: light) { html.theme-auto .search_box { background: rgba(255,255,255,.9); } }
    html.theme-light .search_box { background: rgba(255,255,255,.9); }
    /* Use theme-aware input text color to ensure readability on light/dark */
    #q { color: var(--color-search-font); }
    #q::placeholder { color: #aab0c8; opacity: .9; }
    /* Room for the clear affordance when inline */
    #q
    {
      width: 100%;
      min-width: 0;
    }
    /* Clear button positioning and affordance */
    #clear_search
    {
      background: transparent;
      color: var(--musai-muted);
      border: 0;
      padding: 2px 6px;
      font-size: 18px;
      line-height: 1;
      border-radius: 8px;
      cursor: pointer;
      opacity: .9;
      align-self: center;
    }
    #clear_search:hover { color: var(--musai-text); background: rgba(255,255,255,0.06); opacity: 1; }
    #clear_search.empty
    {
      width: 0;
      padding: 0;
      margin: 0;
      opacity: 0;
      pointer-events: none;
    }
    /* Prevent iOS Safari auto-zoom on focus */
    @media (max-width: 640px) {
      #q { font-size: 16px; }
    }
    #send_search {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 12px;
      border: 0;
    }
    #send_search:hover { filter: brightness(1.1); }
    footer { color: var(--musai-muted); }
    /* Add breathing room and slightly lower the categories (General, Images, Videos, etc.) */
    #categories {
      margin-top: 6px; /* nudge down to avoid feeling too high */
      padding-bottom: 12px;
    }
    /* Allow search types to wrap to a second line if needed to avoid crowding */
    #categories_container { flex-wrap: wrap; }
    /* Dark-mode tuning: harmonize default SearXNG variables to Musai palette */
    html.theme-dark,
    html.theme-black,
    html.theme-auto.est-dark
    {
      /* Baseline text contrast */
      --color-base-font: #e6e8ef; /* higher-contrast body text */
      --color-base-font-rgb: 230,232,239;

      /* Accents and interactive elements */
      --color-url-font: #aab0c8; /* general links */
      --color-result-link-font: #a78bfa; /* result titles */
      --color-result-link-font-highlight: #c4b5fd;
      --color-result-link-visited-font: #c4b5fd;
      --color-categories-item-selected-font: #a78bfa;
      --color-categories-item-border-selected: #a78bfa;
      --color-btn-background: #6e62a6; /* Musai primary for buttons */
      --color-btn-font: #ffffff;
      --color-search-background: #2a2e42; /* search field surface */
      --color-search-font: #ececf4; /* search field text */

      /* Surfaces */
      --color-header-background: #1e2030;
      --color-sidebar-background: #2a2e42;
      --color-result-background: #2a2e42;
      --color-result-border: #3b3f57;
      --color-result-url-font: #cbd5e1;

      /* Secondary/meta text */
      --color-sidebar-font: #f8fafc; /* sidebar and infobox text */
      --color-result-engines-font: #c0c6dc; /* engine list badges */
      --color-result-publishdate-font: #aab3cf; /* timestamps */
      --color-answer-font: #e6e8ef; /* answers block */
    }
    /* Mobile: swap categories row for a compact dropdown */
    #categories_mobile { display: none; }
    @media (max-width: 640px) {
      #categories { display: none; }
      #categories_mobile { display: block; padding: 6px 0 12px; }
      #categories_mobile select {
        width: 100%;
        padding: 10px 12px;
        background: rgba(46,50,66,.6);
        border: 1px solid var(--musai-primary);
        color: var(--musai-text);
        border-radius: 10px;
      }
    }
    /* On mobile results pages, hide the top search field to avoid duplication with bottom bar */
    @media (max-width: 640px) {
      #main_results #search_view { display: none; }
    }
    /* Keep categories/search types away from the top-right utility links
       (apply on search and results pages only; not on the home page) */
    @media (min-width: 1025px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 160px; /* space for About / Preferences */
      }
    }
    @media (min-width: 768px) and (max-width: 1024px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 110px;
      }
    }
    /* Small landscape tablets / narrow laptops: reserve room for top-right links */
    @media (min-width: 641px) and (max-width: 767px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 88px;
      }
    }
    /* AI chat area — docked at the bottom as a floating bar */
    #ai_chat {
      background: rgba(46,50,74,.9);
      border: 1px solid var(--musai-primary);
      box-shadow: 0 4px 24px rgba(0,0,0,.35);
      border-radius: 12px;
      padding: 8px;
      /* Docked, centered */
      position: fixed;
      top: auto;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(30px + env(safe-area-inset-bottom));
      width: min(900px, calc(100vw - 28px));
      z-index: 999;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    /* Collapse affordance (left-most) */
    #ai_chat .ai-toggle {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 10px;
      border: 0;
      height: 32px;
      width: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }
    #ai_chat .ai-toggle:hover {
      filter: brightness(1.1);
    }
    /* Brand cue appears only when collapsed */
    #ai_chat .ai-brand {
      display: none;
      font-weight: 600;
      color: var(--musai-text);
      opacity: .9;
      margin-left: 4px;
    }
    /* Collapsed visual state: hide input/output, show compact identity */
    #ai_chat.collapsed {
      padding: 6px 10px;
      gap: 8px;
      white-space: nowrap;
    }
    /* When embedded inside an iframe, collapse to minimal intrinsic width */
    html.in-iframe #ai_chat.collapsed {
      width: auto;
    }
    #ai_chat.collapsed form,
    #ai_chat.collapsed #ai_chat_output {
      display: none;
    }
    #ai_chat.collapsed .ai-brand {
      display: inline;
    }
    @media (min-width: 1025px) {
      #ai_chat input[type="text"] {
        height: 44px;
      }
      /* scope sizing to the send button only, not POV toggles */
      #ai_chat #ai_chat_send {
        height: 44px;
        width: 48px;
      }
    }
    @media (max-width: 1024px) {
      #ai_chat { bottom: calc(8px + env(safe-area-inset-bottom)); width: calc(100% - 16px); }
    }
    @media (prefers-color-scheme: light) { html.theme-auto #ai_chat { background: rgba(255,255,255,.9); } }
    html.theme-light #ai_chat { background: rgba(255,255,255,.9); }
    #ai_chat form { flex: 1; display: flex; align-items: center; gap: 8px; margin: 0; }
    /* Mode selector (mobile) to switch between Chat and Search */
    #ai_chat #ai_mode {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 10px;
      border: 0;
      height: 40px;
      padding: 0 10px;
      flex: 0 0 auto;
    }
    /* Hide the mode selector on larger screens (desktop keeps top search bar) */
    @media (min-width: 641px) {
      #ai_chat #ai_mode { display: none; }
    }
    #ai_chat input[type="text"],
    #ai_chat textarea {
      flex: 1;
      min-width: 0;
      height: 40px;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid var(--musai-primary);
      background: rgba(0,0,0,0.15);
      color: var(--musai-text);
      resize: none;
      line-height: 1.4;
    }
    /* Style the send button only so POV toggles can have their own colors */
    #ai_chat #ai_chat_send {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 10px;
      border: 0;
      height: 40px;
      width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
    }
    #ai_chat #ai_chat_send:hover {
      filter: brightness(1.1);
    }
    /* Back to top integrated into AI bar */
    #ai_chat #ai_backToTop {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 10px;
      border: 0;
      height: 40px;
      width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }
    /* Ensure the up-arrow icon is visible and sized correctly */
    #ai_chat #ai_backToTop svg { width: 18px; height: 18px; display: block; }
    #ai_chat #ai_backToTop:hover { filter: brightness(1.1); }
    /* Keep AI dock visible even when overlay is open; overlay leaves bottom padding */
    #ai_chat input[type="text"][disabled],
    #ai_chat textarea[disabled],
    #ai_chat button[disabled] {
      opacity: .6;
      cursor: not-allowed;
      filter: none;
    }
    /* Output bubble appears above the docked bar */
    #ai_chat_output {
      position: absolute;
      right: 10px;
      bottom: calc(100% + 10px);
      margin-top: 0;
      padding: 10px;
      border-radius: 10px;
      background: rgba(40,34,68,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 6px 28px rgba(0,0,0,.35);
      max-width: min(420px, 60vw);
      max-height: 70vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      white-space: pre-wrap;
    }
    /* Typing indicator bubble (Musai-style) */
    .ai-typing-bubble {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(107,91,149,.10);
      border: 1px solid rgba(107,91,149,.45);
      box-shadow: 0 2px 16px rgba(0,0,0,.25);
      position: relative;
      overflow: hidden;
    }
    .ai-typing-bubble .ai-typing-icon {
      font-size: 16px;
      line-height: 1;
    }
    .ai-typing-bubble .ai-typing-icon img { width: 16px; height: 16px; display: block; }
    .ai-typing-bubble .ai-typing-label {
      font-size: 0.95rem;
      color: var(--musai-text);
      opacity: .9;
    }
    .ai-typing-bubble .ai-typing-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #a78bfa; /* purple-400 */
    }
    html.theme-light .ai-typing-bubble {
      background: rgba(20,184,166,.10);
      border-color: rgba(20,184,166,.45);
    }
    /* Glow and dots animation */
    @keyframes mysticalGlow {
      0%, 100% { box-shadow: 0 0 14px rgba(167,139,250,.25); }
      50% { box-shadow: 0 0 22px rgba(167,139,250,.45); }
    }
    @keyframes mysticalDots {
      0%, 80%, 100% { transform: scale(0.8); opacity: 0.6; }
      40% { transform: scale(1.15); opacity: 1; }
    }
    .mystical-glow {
      animation: mysticalGlow 2s ease-in-out infinite;
    }
    .mystical-dots {
      animation: mysticalDots 1.4s ease-in-out infinite;
      display: inline-block;
    }
    /* Main response bubble (purplish) */
    .ai-main-bubble {
      background: #6e62a6; /* steel purple (opaque) */
      border: 1px solid #4f3f85; /* deeper steel border for contrast */
      color: #ffffff; /* ensure high-contrast text */
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 8px;
      white-space: pre-wrap;
    }
    /* POV toggles and panels (red = logical, blue = creative) */
    .ai-pov-toggle-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0 6px 0;
      flex-wrap: wrap;
    }
    .ai-pov-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid transparent;
      cursor: pointer;
      user-select: none;
      background: rgba(255,255,255,0.06);
      color: var(--musai-text);
    }
    .ai-pov-toggle[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }
    .ai-pov-toggle.red {
      border-color: #b91c1c;
      background: #dc2626;
      color: #ffffff;
    }
    .ai-pov-toggle.red.active {
      background: #b91c1c;
      box-shadow: inset 0 0 0 1px #7f1d1d;
    }
    .ai-pov-toggle.blue {
      border-color: #1d4ed8;
      background: #2563eb;
      color: #ffffff;
    }
    .ai-pov-toggle.blue.active {
      background: #1d4ed8;
      box-shadow: inset 0 0 0 1px #1e3a8a;
    }
    /* New: Perspective (violet) bubble toggle */
    .ai-pov-toggle.violet {
      border-color: #6d28d9;
      background: #7c3aed;
      color: #ffffff;
    }
    .ai-pov-toggle.violet.active {
      background: #6d28d9;
      box-shadow: inset 0 0 0 1px #4c1d95;
    }
    .ai-pov-panel {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px;
      margin-top: 6px;
      white-space: pre-wrap;
      font-size: 0.95rem;
    }
    .ai-pov-panel.red {
      background: #dc2626;
      border-color: #b91c1c;
      color: #ffffff;
    }
    .ai-pov-panel.blue {
      background: #2563eb;
      border-color: #1d4ed8;
      color: #ffffff;
    }
    .ai-pov-panel.violet {
      background: #7c3aed;
      border-color: #6d28d9;
      color: #ffffff;
    }

    /* Collapsible AI response bubble behavior when clicking outside */
    html.ai-chat-collapsed #ai_chat_output {
      display: none !important;
    }
    /* Mobile refinements for iPhone widths */
    @media (max-width: 640px) {
      /* So header elements don’t overflow */
      #search_header { flex-wrap: wrap; row-gap: 8px; }
      #search_logo img, #search_logo picture { height: 74px; }
      /* Home page only: keep the larger proportion on small screens */
      #main_index #search_logo img, #main_index #search_logo picture { height: 148px; }

      /* Keep header logo proportionate on small screens */
      .page_with_header img.logo { height: 148px; }

      /* Larger touch targets and readable text to avoid auto-zoom */
      #ai_chat input[type="text"], #ai_chat textarea { height: 44px; font-size: 16px; }
      #ai_chat #ai_chat_send { height: 44px; width: 48px; font-size: 18px; }
      #ai_chat .ai-toggle { height: 44px; width: 48px; font-size: 18px; }
      /* When collapsed on small screens, tighten spacing to fit the label neatly */
      #ai_chat.collapsed { padding: 4px 8px; gap: 6px; }
      /* Inside an iframe, keep collapsed bar to intrinsic width */
      html.in-iframe #ai_chat.collapsed { width: auto; }

      /* Ensure output bubble fits and breathes on small screens */
      #ai_chat_output { max-width: min(92vw, 560px); right: 8px; }

      /* Keep the back-to-top button clear of the AI bar */
      #backToTop { bottom: calc(88px + env(safe-area-inset-bottom)); }
      /* If collapsed on small screens, further reduce the offset */
      html.ai-chat-collapsed #backToTop { bottom: calc(56px + env(safe-area-inset-bottom)); }
    }
  </style>
  <style>
    /* EST-based overrides for auto theme */
    html.theme-auto.est-light {
      --musai-primary: #0f766e;
      --musai-accent: #14b8a6;
      --musai-bg: #eafaf7;
      --musai-bg-2: #dff5f0;
      --musai-text: #222222;
      --musai-muted: #506a6a;
    }
    html.theme-auto.est-dark {
      --musai-primary: #6e62a6;
      --musai-accent: #9aa3c7;
      --musai-bg: #1e2030;
      --musai-bg-2: #2a2e42;
      --musai-text: #ececf4;
      --musai-muted: #aab0c8;
    }
    html.theme-auto.est-light .search_box { background: rgba(255,255,255,.9); }
    html.theme-auto.est-dark .search_box { background: rgba(46,50,66,.6); }
    html.theme-auto.est-light #ai_chat { background: rgba(255,255,255,.9); }
    html.theme-auto.est-dark #ai_chat { background: rgba(46,50,74,.9); }
  </style>
  <style>
    /* Hide banner element */
    #banner
    {
      display: none !important;
    }
  </style>
</head>
<body class="{{ endpoint }}_endpoint" >
  <main id="main_{{  self._TemplateReference__context.name|replace("simple/", "")|replace(".html", "") }}" class="{{body_class}}">
    {% if errors %}
        <div class="dialog-error" role="alert">
            <a href="#" class="close" aria-label="close" title="close">×</a>
            <ul>
            {% for message in errors %}
                <li>{{ message }}</li>
            {% endfor %}
            </ul>
        </div>
    {% endif %}

    <nav id="links_on_top">
      {%- from 'simple/icons.html' import icon_big -%}
      {%- block linkto_about -%}
        <a href="{{ url_for('info', pagename='about') }}" class="link_on_top_about">{{ icon_big('information-circle') }}<span>{{ _('About') }}</span></a>
      {%- endblock -%}
      {%- block linkto_donate -%}
        {%- if donation_url -%}
        <a href="{{ donation_url }}" class="link_on_top_donate">{{ icon_big('heart') }}<span>{{ _('Donate') }}</span></a>
        {%- endif -%}
      {%- endblock -%}
      {%- block linkto_preferences -%}
        <a href="{{ url_for('preferences') }}" class="link_on_top_preferences">{{ icon_big('settings') }}<span>{{ _('Preferences') }}</span></a>
      {%- endblock -%}
      {%- block linkto_musai -%}
        <a href="https://musai.codemusic.ca" class="link_on_top_musai">{{ icon_big('musical-notes') }}<span>{{ _('Musai') }}</span></a>
      {%- endblock -%}
    </nav>
    {% block header %}
    {% endblock %}
    {% block content %}
    {% endblock %}
  </main>
  <footer>
    <p>
      <a href="https://musai.codemusic.ca"><strong>MusaiSearch</strong></a> — powered by SearXNG, N8N, Redmine, and Ollama<br>
      <a href="https://codemusic.ca">CodeMusic Construction</a> in association with <a href="https://dtour.codemusic.ca">DTour Designs</a>
    </p>
  </footer>
  {% if get_setting('ui.allow_musairesult_iframes') %}
  <div id="musaiOverlay" aria-hidden="true" data-origin-id="">
    <div id="musaiOverlayTopbar">
      <a class="musai-logo" href="https://search.codemusic.ca" title="Back to MusaiSearch">
        <img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt="Musai">
        <span class="wordmark"><span class="musai">Musai</span><span class="search">Search</span></span>
      </a>
      <form id="musaiOverlaySearch" class="musai-search" method="GET" action="{{ url_for('search') }}" role="search">
        <input id="musaiOverlayQ" name="q" type="text" placeholder="{{ _('Search for...') }}" autocomplete="off" autocapitalize="none" spellcheck="false" autocorrect="off" dir="auto">
        <button id="musaiOverlaySubmit" type="submit" aria-label="{{ _('search') }}">{{ _('Search') }}</button>
      </form>
      <div class="toolbar-spacer"></div>
      <button type="button" id="musaiOverlayCloseReturn" title="Close and return to results">Close &amp; Return</button>
    </div>
    <div id="musaiOverlayLoading" aria-hidden="true">
      <div class="ai-typing-bubble mystical-glow">
        <span class="ai-typing-icon"><img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt=""></span>
        <span class="ai-typing-label">{{ _('Summoning portal') }}</span>
        <span class="ai-typing-dot mystical-dots"></span>
        <span class="ai-typing-dot mystical-dots" style="animation-delay:.2s"></span>
        <span class="ai-typing-dot mystical-dots" style="animation-delay:.4s"></span>
      </div>
    </div>
    <iframe id="musaiOverlayFrame" src="about:blank" sandbox="allow-scripts allow-forms allow-same-origin allow-popups allow-popups-to-escape-sandbox"></iframe>
  </div>
  {% endif %}
  
  {% if get_setting('ui.allow_musairesult_iframes') %}
  <script>
    (function attachMusaiOverlay()
    {
      try
      {
        var overlay = document.getElementById('musaiOverlay');
        if (!overlay)
        {
          return;
        }
        var rootHtml = document.documentElement;
        var frame = document.getElementById('musaiOverlayFrame');
        var loadingVeil = document.getElementById('musaiOverlayLoading');
        var btnCloseReturn = document.getElementById('musaiOverlayCloseReturn');
        var searchForm = document.getElementById('musaiOverlaySearch');
        var searchInput = document.getElementById('musaiOverlayQ');
        var logoLink = document.querySelector('#musaiOverlayTopbar .musai-logo');
        // Fallback state to recover if the iframe can't load (X-Frame-Options / CSP)
        var currentTargetUrl = '';
        var fallbackTimer = null;
        var lastKnownUrl = '';
        var initialOverlayUrl = '';
        var initialLoadDone = false;
        var loadCount = 0;
        var navigatedAway = false;

        var updateLastKnownUrl = function()
        {
          try
          {
            var newUrl = '';
            try
            {
              if (frame && frame.contentWindow && frame.contentWindow.location)
              {
                newUrl = frame.contentWindow.location.href || '';
              }
            }
            catch (_) { /* cross-origin, ignore */ }
            if (!newUrl)
            {
              try { newUrl = (frame && frame.src) || ''; } catch (_) { /* no-op */ }
            }
            if (newUrl)
            {
              lastKnownUrl = newUrl;
            }
          }
          catch (_) { /* no-op */ }
        };
        var showUrlInSearchInput = function(url)
        {
          try
          {
            if (!searchInput) { return; }
            var value = '';
            try { value = deMortyUrl(url || '') || url || ''; } catch (_) { value = url || ''; }
            if (value) { searchInput.value = value; }
          }
          catch (_) { /* no-op */ }
        };

        var errorDialog = document.querySelector('.dialog-error');
        // Morty helpers to ensure iframe URLs are proxied and signed with hash
        var SIGN_WEBHOOK = 'https://n8n.codemusic.ca/webhook/sign-morty';
        var mortyPrefix = ("{{ (get_setting('server.result_proxy.url') or '')|e }}" || '').trim();
        var mortyPrefixPath = (function()
        {
          try
          {
            return (new URL(mortyPrefix, window.location.href).pathname) || mortyPrefix;
          }
          catch (_)
          {
            return mortyPrefix;
          }
        })();
        try { console.debug('[MortySign] config', { mortyPrefix: mortyPrefix, mortyPrefixPath: mortyPrefixPath }); } catch (_) {}
        var hasMortyHash = function(url)
        {
          try { return /[?&](?:mortyhash|hash)=/.test(url); } catch (_) { return false; }
        };
        var isMortyUrl = function(url)
        {
          try
          {
            if (!mortyPrefix) { return false; }
            var s = url || '';
            if (!s) { return false; }
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0)
            {
              var u = new URL(s, window.location.href);
              var href = u.href || '';
              var path = u.pathname || '';
              return (href.indexOf(mortyPrefix) === 0) || (path.indexOf(mortyPrefixPath) === 0);
            }
            return (s.indexOf(mortyPrefix) === 0) || (s.indexOf(mortyPrefixPath) === 0);
          }
          catch (_) { return false; }
        };
        // Decide whether a URL should be proxied via Morty based on file extension and allowed inline MIME types
        var shouldUseMortyForUrl = function(url)
        {
          try
          {
            var s = String(url || '');
            if (!s) { return true; }
            // Strip query and fragment
            var clean = s.split('#')[0].split('?')[0];
            var lastSlash = clean.lastIndexOf('/');
            var lastDot = clean.lastIndexOf('.');
            // No extension → treat as unknown type → allow Morty
            if (lastDot <= lastSlash) { return true; }
            var ext = clean.slice(lastDot + 1).toLowerCase();
            // Map common extensions to MIME. Only map those we care about; unknown → allow Morty
            var extToMime = {
              // HTML
              'html': 'text/html', 'htm': 'text/html', 'xhtml': 'application/xhtml+xml',
              // CSS
              'css': 'text/css',
              // Images
              'gif': 'image/gif', 'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'pjpeg': 'image/pjpeg', 'webp': 'image/webp',
              'tif': 'image/tiff', 'tiff': 'image/tiff', 'ico': 'image/vnd.microsoft.icon', 'cur': 'image/x-icon', 'bmp': 'image/bmp', 'dib': 'image/x-ms-bmp',
              // Fonts
              'otf': 'application/font-otf', 'ttf': 'application/font-ttf', 'woff': 'application/font-woff', 'eot': 'application/vnd.ms-fontobject',
              // Common media we want to bypass Morty for (map so we can disallow)
              'mp3': 'audio/mpeg', 'wav': 'audio/wav', 'flac': 'audio/flac', 'm4a': 'audio/mp4', 'ogg': 'audio/ogg', 'oga': 'audio/ogg',
              'mp4': 'video/mp4', 'm4v': 'video/mp4', 'webm': 'video/webm', 'ogv': 'video/ogg', 'mkv': 'video/x-matroska',
              // Other common download types we should not proxy inside the iframe
              'pdf': 'application/pdf', 'zip': 'application/zip', 'gz': 'application/gzip', 'rar': 'application/vnd.rar'
            };
            var allowedInline = {
              'text/html': true,
              'application/xhtml+xml': true,
              'text/css': true,
              'image/gif': true,
              'image/png': true,
              'image/jpeg': true,
              'image/pjpeg': true,
              'image/webp': true,
              'image/tiff': true,
              'image/vnd.microsoft.icon': true,
              'image/bmp': true,
              'image/x-ms-bmp': true,
              'image/x-icon': true,
              'application/font-otf': true,
              'application/font-ttf': true,
              'application/font-woff': true,
              'application/vnd.ms-fontobject': true
            };
            var mime = extToMime[ext] || '';
            // Unknown type → allow Morty; Known and allowed → allow Morty; Known and not allowed → bypass Morty
            if (!mime) { return true; }
            return !!allowedInline[mime];
          }
          catch (_)
          {
            return true;
          }
        };
        var mortyProxify = function(url)
        {
          try
          {
            if (!mortyPrefix || !url) { return url; }
            // Respect eligibility: bypass Morty for disallowed media types
            if (!shouldUseMortyForUrl(url)) { return url; }
            if (isMortyUrl(url)) { return url; }
            if (url.indexOf('http://') === 0 || url.indexOf('https://') === 0)
            {
              var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
              return mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(url);
            }
            return url;
          }
          catch (_) { return url; }
        };
        var deMortyUrl = function(url)
        {
          try
          {
            var s = url || '';
            if (!s || !isMortyUrl(s)) { return s; }
            var u = new URL(s, window.location.href);
            // Prefer query-param style
            var mu = u.searchParams && u.searchParams.get ? (u.searchParams.get('mortyurl') || '') : '';
            if (mu) { return mu; }
            // Fallback: path-style /morty/https/...
            var path = u.pathname || '';
            var base = mortyPrefixPath || '/morty/';
            var i = path.indexOf(base);
            var suffix = (i >= 0) ? path.slice(i + base.length) : path;
            if (suffix.indexOf('https/') === 0) { return 'https://' + suffix.slice(6); }
            if (suffix.indexOf('http/') === 0) { return 'http://' + suffix.slice(5); }
            return s;
          }
          catch (_) { return url; }
        };
        var stableUrlString = function(input)
        {
          try { return new URL(input, window.location.href).href; } catch (_) { return input || ''; }
        };
        var signMortyUrl = function(url)
        {
          return new Promise(function(resolve)
          {
            var candidate = stableUrlString(url);
            if (!candidate)
            {
              resolve(candidate);
              return;
            }
            // Always sign the plain target URL; if Morty-style passed, extract mortyurl first
            var plainTarget = isMortyUrl(candidate) ? deMortyUrl(candidate) : candidate;
            var buildMorty = function(target, hash)
            {
              try
              {
                var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
                var signed = mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(target);
                if (hash) { signed += '&mortyhash=' + String(hash).toLowerCase(); }
                return signed;
              }
              catch (_) { return candidate; }
            };
            // If already has mortyhash, keep as-is
            if (isMortyUrl(candidate) && hasMortyHash(candidate))
            {
              resolve(candidate);
              return;
            }
            var didResolve = false;
            var settle = function(value)
            {
              if (didResolve) { return; }
              didResolve = true;
              resolve(value || buildMorty(plainTarget));
            };
            try
            {
              fetch(SIGN_WEBHOOK, {
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/json' }, (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function') ? window.musaiN8N.getAuthHeader() : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }),
                body: JSON.stringify({ url: plainTarget })
              }).then(function(r)
              {
                if (!r.ok) { throw new Error('HTTP ' + r.status); }
                return r.json().catch(function(){ return { url: plainTarget }; });
              }).then(function(data)
              {
                var nextUrl = (data && data.signed_url) || '';
                var mh = (data && (data.mortyhash || data.hash)) || '';
                if (!nextUrl)
                {
                  nextUrl = buildMorty(plainTarget, mh);
                }
                try { console.debug('[MusaiOverlay] signer POST result', { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) }); } catch (_) {}
                // If key is unset on Morty, mortyhash may be omitted; that's fine
                settle(nextUrl || buildMorty(plainTarget, mh));
              }).catch(function()
              {
                var urlParam = encodeURIComponent(plainTarget);
                fetch(SIGN_WEBHOOK + '?url=' + urlParam, {
                  headers: (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function') ? window.musaiN8N.getAuthHeader() : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }
                }).then(function(r)
                {
                  if (!r.ok) { throw new Error('HTTP ' + r.status); }
                  return r.json().catch(function(){ return { url: plainTarget }; });
                }).then(function(data)
                {
                  var nextUrl = (data && data.signed_url) || '';
                  var mh = (data && (data.mortyhash || data.hash)) || '';
                  if (!nextUrl)
                  {
                    nextUrl = buildMorty(plainTarget, mh);
                  }
                  try { console.debug('[MusaiOverlay] signer GET result', { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) }); } catch (_) {}
                  settle(nextUrl || buildMorty(plainTarget, mh));
                }).catch(function()
                {
                  // Fallback: unsigned open (works when MORTY_KEY is unset)
                  settle(buildMorty(plainTarget));
                });
              });
            }
            catch (_) { settle(buildMorty(plainTarget)); }
          });
        };
        var openOverlay = function(url, originId, options)
        {
          overlay.setAttribute('aria-hidden', 'false');
          try { overlay.setAttribute('data-loading', 'true'); } catch (_) { /* no-op */ }
          try { rootHtml && rootHtml.classList.add('musai-overlay-open'); } catch (_) { /* no-op */ }
          if (originId) { overlay.dataset.originId = originId; }
          try { frame.src = 'about:blank'; } catch (_) {}
          try { lastKnownUrl = ''; initialOverlayUrl = ''; } catch (_) { /* no-op */ }
          initialLoadDone = false;
          loadCount = 0;
          navigatedAway = false;
          // Clear any previous fallback timer
          try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
          // Suppress any page-level error dialog so its close (×) does not float above the iframe
          if (errorDialog) { errorDialog.style.display = 'none'; }
          // Compute proxied + signed URL for Morty (if configured), then load
          try
          {
            var forceNoMorty = options && options.forceNoMorty === true;
            var sourceUrl = options && options.sourceUrl ? String(options.sourceUrl) : '';
            var allowMorty = forceNoMorty ? false : shouldUseMortyForUrl(sourceUrl || (url || ''));
            var candidate = allowMorty ? mortyProxify(url || '') : (url || '');
            var loadFinal = function(finalUrl)
            {
              try { console.debug('[MusaiOverlay] load iframe', { finalUrl: finalUrl, hasHash: /[?&]hash=/.test(finalUrl || '') }); } catch (_) {}
              // Track the intended target for fallbacks
              try { currentTargetUrl = finalUrl || url || ''; } catch (_) { currentTargetUrl = finalUrl || ''; }
              try { frame.src = finalUrl || 'about:blank'; } catch (_) { frame.src = 'about:blank'; }
              try { lastKnownUrl = finalUrl || ''; initialOverlayUrl = lastKnownUrl; } catch (_) { /* no-op */ }
              try { showUrlInSearchInput(deMortyUrl(finalUrl || url || '')); } catch (_) { /* no-op */ }
              // If the iframe fails to load (common when a site forbids embedding),
              // open the URL in a new tab and close the overlay to avoid a blank screen
              try {
                if (fallbackTimer) { clearTimeout(fallbackTimer); }
                var targetForFallback = currentTargetUrl || url || finalUrl || '';
                // Do not set any fallback timer for Morty URLs; they must remain in-frame
                if (!isMortyUrl(targetForFallback))
                {
                  fallbackTimer = setTimeout(function()
                  {
                    try
                    {
                      if (overlay.getAttribute('aria-hidden') === 'false' && !initialLoadDone && loadCount === 0)
                      {
                        try { window.open(targetForFallback, '_blank', 'noopener'); } catch (_) {}
                        try { console.warn('[MusaiOverlay] iframe likely blocked; opened in new tab and closed overlay'); } catch (_) {}
                        try { closeOverlay(); } catch (_) {}
                      }
                    }
                    catch (_) { /* no-op */ }
                  }, 2500);
                }
              } catch (_) { /* no-op */ }
            };
            if (allowMorty && mortyPrefix && candidate)
            {
              try { signMortyUrl(candidate).then(loadFinal).catch(function(){ loadFinal(candidate); }); }
              catch (_) { loadFinal(candidate); }
            }
            else
            {
              loadFinal(candidate || url || '');
            }
          }
          catch (_) { /* no-op */ }
          // Ensure AI dock remains visible; content padding already accounts for it
        };
        var closeOverlay = function()
        {
          overlay.setAttribute('aria-hidden', 'true');
          try { overlay.removeAttribute('data-loading'); } catch (_) { /* no-op */ }
          try { rootHtml && rootHtml.classList.remove('musai-overlay-open'); } catch (_) { /* no-op */ }
          try { frame.src = 'about:blank'; } catch (_) {}
          // Clear any pending fallback since we're closing
          try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
          // Restore error dialog visibility when leaving overlay
          if (errorDialog) { errorDialog.style.display = ''; }
        };

        document.addEventListener('click', function(e)
        {
          var trigger = e.target.closest && e.target.closest('button.musai-open-iframe');
          if (!trigger) { return; }
          e.preventDefault();
          var url = trigger.getAttribute('data-url') || '';
          var sourceUrl = trigger.getAttribute('data-source-url') || '';
          var originId = trigger.getAttribute('data-origin-id') || '';
          if (url) { openOverlay(url, originId, { sourceUrl: sourceUrl }); }
        });

        var performCloseReturn = function()
        {
          var originId = overlay.dataset.originId || '';
          closeOverlay();
          if (originId)
          {
            var el = document.getElementById(originId);
            if (el && el.scrollIntoView)
            {
              el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        };
        btnCloseReturn && btnCloseReturn.addEventListener('click', performCloseReturn);

        // Track iframe navigations: same-origin via contentWindow, cross-origin via src
        try {
          frame && frame.addEventListener('load', function()
          {
            // Loading succeeded (at least at the browser level); cancel fallback
            try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
            loadCount += 1;
            // Hide loading veil after first successful load
            try {
              if (!initialLoadDone) { overlay.removeAttribute('data-loading'); }
            } catch (_) { /* no-op */ }
            // If the loaded page is a Morty URL, attempt to hide Morty UI chrome inside the iframe
            try
            {
              var srcNow = (frame && frame.src) || '';
              if (isMortyUrl(srcNow))
              {
                try
                {
                  var doc = frame.contentDocument || (frame.contentWindow && frame.contentWindow.document) || null;
                  if (doc)
                  {
                    // Inject a minimal stylesheet to hide known Morty header/toolbars
                    var style = doc.createElement('style');
                    style.textContent = [
                      'header, .header, #header { display: none !important; }',
                      '.morty-header, .morty-topbar, .morty-toolbar { display: none !important; }',
                      '#topbar, .topbar, .toolbar { display: none !important; }',
                      'body { margin-top: 0 !important; }'
                    ].join('\n');
                    doc.head && doc.head.appendChild(style);
                    // Also remove any element that contains the “Morty” label commonly shown by proxies
                    var maybeHeaders = doc.querySelectorAll('header, .header, #header, .morty-header, .morty-topbar, .morty-toolbar, #topbar, .topbar, .toolbar');
                    for (var i = 0; i < maybeHeaders.length; i++)
                    {
                      var el = maybeHeaders[i];
                      var txt = (el && (el.innerText || el.textContent) || '').toLowerCase();
                      if (txt.indexOf('morty') !== -1 || txt.indexOf('proxy') !== -1)
                      {
                        try { el.parentNode && el.parentNode.removeChild(el); } catch (_) { /* no-op */ }
                      }
                    }
                  }
                }
                catch (_) { /* cross-origin or CSP; ignore */ }
              }
            }
            catch (_) { /* no-op */ }
            // Update last known URL when possible
            try { updateLastKnownUrl(); } catch (_) { /* no-op */ }
            try { showUrlInSearchInput(lastKnownUrl || (frame && frame.src) || ''); } catch (_) { /* no-op */ }
            if (!initialLoadDone)
            {
              initialLoadDone = true;
              return;
            }
            // Any subsequent load implies navigation away from the original page
            try
            {
              if (loadCount > 1)
              {
                // If we can compare URLs and they differ, mark navigated; otherwise assume navigated
                var current = lastKnownUrl || '';
                if (!current || !initialOverlayUrl || current !== initialOverlayUrl)
                {
                  navigatedAway = true;
                }
                else
                {
                  // Same URL after load (rare), keep current flag
                  navigatedAway = navigatedAway || true;
                }
              }
            }
            catch (_) { /* no-op */ }
          }, true);
        } catch (_) { /* no-op */ }

        // Accept cooperative URL updates from embedded pages
        try
        {
          window.addEventListener('message', function(ev)
          {
            try
            {
              if (!frame || !frame.contentWindow || ev.source !== frame.contentWindow) { return; }
              var data = ev.data;
              var candidate = '';
              if (typeof data === 'string')
              {
                candidate = data;
              }
              else if (data && typeof data === 'object')
              {
                if (typeof data.url === 'string') { candidate = data.url; }
                else if (typeof data.href === 'string') { candidate = data.href; }
                else if (data.location)
                {
                  if (typeof data.location === 'string') { candidate = data.location; }
                  else if (typeof data.location.href === 'string') { candidate = data.location.href; }
                }
                if (!candidate && (data.type === 'musai-location' || data.type === 'musai.overlay.location'))
                {
                  if (typeof data.value === 'string') { candidate = data.value; }
                }
              }
              if (candidate && typeof candidate === 'string')
              {
                try { candidate = new URL(candidate, lastKnownUrl || (frame && frame.src) || window.location.href).href; } catch (_) { /* no-op */ }
                lastKnownUrl = candidate;
                try { showUrlInSearchInput(candidate); } catch (_) { /* no-op */ }
              }
            }
            catch (_) { /* no-op */ }
          }, false);
        }
        catch (_) { /* no-op */ }

        // Submit handler for overlay search: navigate main app to results
        if (searchForm && searchInput)
        {
          searchForm.addEventListener('submit', function(ev)
          {
            try
            {
              ev.preventDefault();
              ev.stopPropagation();
              var q = (searchInput.value || '').trim();
              if (!q) { return; }
              var hasScheme = function(value) { return /^(?:[a-z][a-z0-9+.-]*):\/\//i.test(value); };
              var looksLikeUrl = function(value)
              {
                if (!value || /\s/.test(value)) { return false; }
                if (hasScheme(value)) { return true; }
                if (/^www\./i.test(value)) { return true; }
                if (/^(?:localhost)(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return true; }
                if (/^(?:\d{1,3})(?:\.\d{1,3}){3}(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return true; }
                return /^[^\s]+\.[a-z]{2,}(?:[\/?#].*)?$/i.test(value);
              };
              var normalizeUrl = function(value)
              {
                if (!value) { return value; }
                if (hasScheme(value)) { return value; }
                if (/^www\./i.test(value)) { return 'https://' + value; }
                if (/^(?:localhost|\d{1,3}(?:\.\d{1,3}){3})(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return 'http://' + value; }
                return 'https://' + value;
              };
              // If AI is currently thinking, confirm before navigating away
              try
              {
                if (window.musaiAI && typeof window.musaiAI.isBusy === 'function' && window.musaiAI.isBusy())
                {
                  var ok = window.confirm('Musai is thinking. Starting a new search will cancel the response. Continue?');
                  if (!ok) { return; }
                }
              }
              catch (_) { /* no-op */ }
              // If input looks like a URL, navigate inside overlay directly without Morty
              if (looksLikeUrl(q))
              {
                var dest = normalizeUrl(q);
                try { openOverlay(dest, '', { forceNoMorty: true }); } catch (_) { /* no-op */ }
                return;
              }
              // Otherwise, close overlay and redirect to search results
              try { closeOverlay(); } catch (_) { /* no-op */ }
              try { if (window.musaiAI && typeof window.musaiAI.markInternalNav === 'function') { window.musaiAI.markInternalNav(); } } catch (_) { /* no-op */ }
              var base = searchForm.getAttribute('action') || "{{ url_for('search') }}";
              var url = base + '?q=' + encodeURIComponent(q);
              try { window.location.href = url; } catch (_) { /* no-op */ }
            }
            catch (_) { /* no-op */ }
          });
        }

        // Guard navigation via logo when AI busy
        if (logoLink)
        {
          logoLink.addEventListener('click', function(e)
          {
            try
            {
              if (window.musaiAI && typeof window.musaiAI.isBusy === 'function' && window.musaiAI.isBusy())
              {
                var proceed = window.confirm('Musai is thinking. Navigating home will cancel the response. Continue?');
                if (!proceed)
                {
                  e.preventDefault();
                  e.stopPropagation();
                }
              }
            }
            catch (_) { /* no-op */ }
          });
        }

        // ESC closes overlay
        document.addEventListener('keydown', function(e)
        {
          if (overlay.getAttribute('aria-hidden') === 'false' && (e.key === 'Escape' || e.keyCode === 27))
          {
            e.preventDefault();
            performCloseReturn();
          }
        });

        // Expose current overlay URL for AI dock to send to backend
        window.musaiOverlayAPI = {
          isOpen: function()
          {
            return overlay.getAttribute('aria-hidden') === 'false';
          },
          currentUrl: function()
          {
            try { return (lastKnownUrl || (frame && frame.src) || '') ; }
            catch (_) { return ''; }
          },
          hasNavigatedAway: function()
          {
            try { return !!navigatedAway; } catch (_) { return false; }
          },
          state: function()
          {
            try
            {
              return {
                isOpen: overlay.getAttribute('aria-hidden') === 'false',
                initialUrl: initialOverlayUrl || '',
                lastKnownUrl: lastKnownUrl || '',
                loadCount: loadCount,
                navigatedAway: !!navigatedAway
              };
            }
            catch (_) { return { isOpen: false, initialUrl: '', lastKnownUrl: '', loadCount: 0, navigatedAway: false }; }
          },
          lastKnownUrl: function()
          {
            try { return lastKnownUrl || ''; }
            catch (_) { return ''; }
          },
          // Extract salient, symbol-trimmed text from the same-origin iframe document
          readableText: function(options)
          {
            try
            {
              var maxChars = (options && options.maxChars) || 2000;
              // Ensure same-origin access is permitted
              try { if (!frame || !frame.contentWindow) { return ''; } frame.contentWindow.location.href; } catch (_) { return ''; }
              var doc = null;
              try { doc = frame.contentDocument || (frame.contentWindow && frame.contentWindow.document) || null; } catch (__) { doc = null; }
              if (!doc || !doc.body) { return ''; }
              var raw = '';
              try { raw = (doc.body.innerText || doc.body.textContent || ''); } catch (___) { raw = ''; }
              if (!raw) { return ''; }
              // Normalize whitespace early to reduce cognitive load
              var normalized = raw.replace(/\s+/g, ' ').trim();
              // Strip non-informational symbols while preserving core punctuation
              try { normalized = normalized.replace(/[^\p{L}\p{N}\s\.,;:\-\(\)\!\?\'\"]/gu, ' '); } catch (_) { normalized = normalized.replace(/[^A-Za-z0-9\s\.,;:\-\(\)\!\?\'\"]/g, ' '); }
              normalized = normalized.replace(/\s{2,}/g, ' ').trim();
              if (maxChars > 0 && normalized.length > maxChars)
              {
                normalized = normalized.slice(0, Math.max(0, maxChars - 1)) + '…';
              }
              return normalized;
            }
            catch (_) { return ''; }
          },
          // Build a bracketed context block for AI consumption
          contextBlock: function(options)
          {
            try
            {
              var text = this.readableText(options || {});
              if (!text) { return ''; }
              var url = '';
              try { url = lastKnownUrl || (frame && frame.src) || ''; } catch (_) { url = ''; }
              return '[Current Context:\n' + text + '\nURL: ' + url + '\n]';
            }
            catch (_) { return ''; }
          },
          open: function(url, originId)
          {
            try { openOverlay(url, originId); } catch (_) {}
          },
          close: function()
          {
            try { performCloseReturn(); } catch (_) {}
          }
        };
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  {% endif %}
  <script type="module" src="{{ url_for('static', filename='js/searxng.core.min.js') }}" client_settings="{{ client_settings }}"></script>
  <script>
    (function ensureMortyLinksAreSigned()
    {
      try
      {
        var SIGN_WEBHOOK = 'https://n8n.codemusic.ca/webhook/sign-morty';
        var mortyPrefix = ("{{ (get_setting('server.result_proxy.url') or '')|e }}" || '').trim();
        var mortyPrefixPath = (function()
        {
          try
          {
            return (new URL(mortyPrefix, window.location.href).pathname) || mortyPrefix;
          }
          catch (_)
          {
            return mortyPrefix;
          }
        })();
        try { console.debug('[MortySign] config', { mortyPrefix: mortyPrefix, mortyPrefixPath: mortyPrefixPath }); } catch (_) {}

        var hasMortyHash = function(url)
        {
          try
          {
            return /[?&](?:mortyhash|hash)=/.test(url);
          }
          catch (_) { return false; }
        };

        var isMortyUrl = function(url)
        {
          try
          {
            if (!mortyPrefix) { return false; }
            var s = url || '';
            if (!s) { return false; }
            // Accept absolute and relative URLs
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0)
            {
              var u = new URL(s, window.location.href);
              var href = u.href || '';
              var path = u.pathname || '';
              return (href.indexOf(mortyPrefix) === 0) || (path.indexOf(mortyPrefixPath) === 0);
            }
            return (s.indexOf(mortyPrefix) === 0) || (s.indexOf(mortyPrefixPath) === 0);
          }
          catch (_) { return false; }
        };

        var stableUrlString = function(input)
        {
          try
          {
            var u = new URL(input, window.location.href);
            return u.href;
          }
          catch (_)
          {
            return input || '';
          }
        };
        var deMortyUrl = function(url)
        {
          try
          {
            var s = url || '';
            if (!s || !isMortyUrl(s)) { return s; }
            var u = new URL(s, window.location.href);
            // Prefer query-param style first (e.g., /morty/?mortyurl=...)
            try
            {
              var mu = (u.searchParams && u.searchParams.get) ? (u.searchParams.get('mortyurl') || '') : '';
              if (mu) { return mu; }
            }
            catch (_) { /* no-op */ }
            // Fallback: path-style /morty/https/...
            var path = u.pathname || '';
            var base = mortyPrefixPath || '/morty/';
            var i = path.indexOf(base);
            var suffix = (i >= 0) ? path.slice(i + base.length) : path;
            if (suffix.indexOf('https/') === 0) { return 'https://' + suffix.slice(6); }
            if (suffix.indexOf('http/') === 0) { return 'http://' + suffix.slice(5); }
            return s;
          }
          catch (_) { return url; }
        };

        // Decide whether a URL should be proxied via Morty based on file extension and allowed inline MIME types
        var shouldUseMortyForUrl = function(url)
        {
          try
          {
            var s = String(url || '');
            if (!s) { return true; }
            var clean = s.split('#')[0].split('?')[0];
            var lastSlash = clean.lastIndexOf('/');
            var lastDot = clean.lastIndexOf('.');
            if (lastDot <= lastSlash) { return true; }
            var ext = clean.slice(lastDot + 1).toLowerCase();
            var extToMime = {
              'html': 'text/html', 'htm': 'text/html', 'xhtml': 'application/xhtml+xml',
              'css': 'text/css',
              'gif': 'image/gif', 'png': 'image/png', 'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'pjpeg': 'image/pjpeg', 'webp': 'image/webp',
              'tif': 'image/tiff', 'tiff': 'image/tiff', 'ico': 'image/vnd.microsoft.icon', 'cur': 'image/x-icon', 'bmp': 'image/bmp', 'dib': 'image/x-ms-bmp',
              'otf': 'application/font-otf', 'ttf': 'application/font-ttf', 'woff': 'application/font-woff', 'eot': 'application/vnd.ms-fontobject',
              'mp3': 'audio/mpeg', 'wav': 'audio/wav', 'flac': 'audio/flac', 'm4a': 'audio/mp4', 'ogg': 'audio/ogg', 'oga': 'audio/ogg',
              'mp4': 'video/mp4', 'm4v': 'video/mp4', 'webm': 'video/webm', 'ogv': 'video/ogg', 'mkv': 'video/x-matroska',
              'pdf': 'application/pdf', 'zip': 'application/zip', 'gz': 'application/gzip', 'rar': 'application/vnd.rar'
            };
            var allowedInline = {
              'text/html': true,
              'application/xhtml+xml': true,
              'text/css': true,
              'image/gif': true,
              'image/png': true,
              'image/jpeg': true,
              'image/pjpeg': true,
              'image/webp': true,
              'image/tiff': true,
              'image/vnd.microsoft.icon': true,
              'image/bmp': true,
              'image/x-ms-bmp': true,
              'image/x-icon': true,
              'application/font-otf': true,
              'application/font-ttf': true,
              'application/font-woff': true,
              'application/vnd.ms-fontobject': true
            };
            var mime = extToMime[ext] || '';
            if (!mime) { return true; }
            return !!allowedInline[mime];
          }
          catch (_)
          {
            return true;
          }
        };

        var signUrl = function(url)
        {
          return new Promise(function(resolve)
          {
            var candidate = stableUrlString(url);
            try { console.debug('[MortySign] signUrl start', { candidate: candidate }); } catch (_) {}
            if (!candidate)
            {
              resolve(candidate);
              return;
            }
            var plainTarget = isMortyUrl(candidate) ? deMortyUrl(candidate) : candidate;
            // If target should not be proxied by Morty (e.g., media), return direct URL
            try { if (!shouldUseMortyForUrl(plainTarget)) { resolve(plainTarget); return; } } catch (_) {}
            var buildMorty = function(target, hash)
            {
              try
              {
                var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
                var built = mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(target);
                if (hash) { built += '&mortyhash=' + String(hash).toLowerCase(); }
                return built;
              }
              catch (_) { return candidate; }
            };
            // If already Morty with hash, keep as-is
            if (isMortyUrl(candidate) && hasMortyHash(candidate))
            {
              resolve(candidate);
              return;
            }

            var didResolve = false;
            var settle = function(value)
            {
              if (didResolve) { return; }
              didResolve = true;
              resolve(value || buildMorty(plainTarget));
            };

            try
            {
              fetch(SIGN_WEBHOOK, {
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/json' }, (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function') ? window.musaiN8N.getAuthHeader() : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }),
                body: JSON.stringify({ url: plainTarget })
              }).then(function(r)
              {
                if (!r.ok) { throw new Error('HTTP ' + r.status); }
                return r.json().catch(function()
                {
                  return { url: plainTarget };
                });
              }).then(function(data)
              {
                var nextUrl = (data && data.signed_url) || '';
                var mh = (data && (data.mortyhash || data.hash)) || '';
                if (!nextUrl)
                {
                  nextUrl = buildMorty(plainTarget, mh);
                }
                try { console.debug('[MortySign] signUrl POST result', { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) }); } catch (_) {}
                settle(nextUrl || buildMorty(plainTarget, mh));
              }).catch(function()
              {
                // Secondary: GET ?url=...
                var urlParam = encodeURIComponent(plainTarget);
                fetch(SIGN_WEBHOOK + '?url=' + urlParam, {
                  headers: (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function') ? window.musaiN8N.getAuthHeader() : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }
                }).then(function(r)
                {
                  if (!r.ok) { throw new Error('HTTP ' + r.status); }
                  return r.json().catch(function()
                  {
                    return { url: plainTarget };
                  });
                }).then(function(data)
                {
                  var nextUrl = (data && data.signed_url) || '';
                  var mh = (data && (data.mortyhash || data.hash)) || '';
                  if (!nextUrl)
                  {
                    nextUrl = buildMorty(plainTarget, mh);
                  }
                  try { console.debug('[MortySign] signUrl GET result', { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) }); } catch (_) {}
                  settle(nextUrl || buildMorty(plainTarget, mh));
                }).catch(function()
                {
                  settle(buildMorty(plainTarget));
                });
              });
            }
            catch (_)
            {
              settle(buildMorty(plainTarget));
            }
          });
        };

        var upgradeAnchor = function(a)
        {
          try
          {
            if (!a || a.dataset.mortySigned === '1') { return; }
            var href = a.getAttribute('href') || '';
            // If this Morty URL points to a disallowed media type, revert to direct link
            try
            {
              if (isMortyUrl(href))
              {
                var plain = deMortyUrl(href);
                if (!shouldUseMortyForUrl(plain))
                {
                  a.setAttribute('href', plain);
                  a.dataset.mortySigned = '1';
                  return;
                }
              }
            }
            catch (_) { /* no-op */ }
            if (!isMortyUrl(href) || hasMortyHash(href))
            {
              a.dataset.mortySigned = '1';
              return;
            }
            signUrl(href).then(function(signed)
            {
              try
              {
                if (signed && typeof signed === 'string')
                {
                  var finalHref = signed;
                  // If Morty key is set, finalHref should contain mortyhash; if not, keep mortyurl-only (key unset)
                  a.setAttribute('href', finalHref);
                }
              }
              catch (_) {}
              a.dataset.mortySigned = '1';
            });
          }
          catch (_) { /* no-op */ }
        };

        var upgradeButton = function(btn)
        {
          try
          {
            if (!btn || btn.dataset.mortySigned === '1') { return; }
            var url = btn.getAttribute('data-url') || '';
            var needsSigning = isMortyUrl(url) && !hasMortyHash(url);
            if (!isMortyUrl(url) || hasMortyHash(url))
            {
              btn.dataset.mortySigned = '1';
              try { btn.removeAttribute('disabled'); } catch (_) {}
              return;
            }
            if (needsSigning)
            {
              try { btn.setAttribute('disabled', 'disabled'); } catch (_) {}
            }
            try { console.debug('[MortySign] upgradeButton before', { url: url }); } catch (_) {}
            signUrl(url).then(function(signed)
            {
              try
              {
                if (signed && typeof signed === 'string')
                {
                  var finalUrl = signed;
                  btn.setAttribute('data-url', finalUrl);
                }
              }
              catch (_) {}
              btn.dataset.mortySigned = '1';
              try { btn.removeAttribute('disabled'); } catch (_) {}
              try { console.debug('[MortySign] upgradeButton after', { signed: signed, hasMortyhash: /[?&]mortyhash=/.test(signed || '') }); } catch (_) {}
            });
          }
          catch (_) { /* no-op */ }
        };

        var upgradeAll = function(root)
        {
          try
          {
            var scope = root || document;
            // Process all anchors so media links proxied by server can be unwrapped
            var anchors = scope.querySelectorAll('a[href]');
            for (var i = 0; i < anchors.length; i++) { upgradeAnchor(anchors[i]); }
            var buttons = scope.querySelectorAll('button.musai-open-iframe');
            for (var j = 0; j < buttons.length; j++) { upgradeButton(buttons[j]); }
          }
          catch (_) { /* no-op */ }
        };

        if (mortyPrefix)
        {
          if (document.readyState === 'loading')
          {
            document.addEventListener('DOMContentLoaded', function()
            {
              try { upgradeAll(document); } catch (_) { /* no-op */ }
            });
          }
          else
          {
            upgradeAll(document);
          }

          // Observe dynamically inserted results (infinite scroll, etc.)
          try
          {
            var obs = new MutationObserver(function(muts)
            {
              for (var k = 0; k < muts.length; k++)
              {
                var m = muts[k];
                if (m && m.addedNodes && m.addedNodes.length)
                {
                  for (var n = 0; n < m.addedNodes.length; n++)
                  {
                    var node = m.addedNodes[n];
                    if (node && node.nodeType === 1)
                    {
                      upgradeAll(node);
                    }
                  }
                }
              }
            });
            obs.observe(document.documentElement, { childList: true, subtree: true });
          }
          catch (_) { /* no-op */ }
        }
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  <script>
    (function guardMusaiOverlayAndAIDock()
    {
      try
      {
        var overlay = document.getElementById('musaiOverlay');
        var html = document.documentElement;
        if (!overlay || overlay.getAttribute('aria-hidden') !== 'false')
        {
          try { html.classList.remove('musai-overlay-open'); } catch (_) { /* no-op */ }
        }
      }
      catch (_) { /* no-op */ }
      try
      {
        var ai = document.getElementById('ai_chat');
        if (!ai) { return; }
        var display = (window.getComputedStyle ? window.getComputedStyle(ai).display : ai.style.display) || '';
        if (display === 'none')
        {
          ai.style.display = 'flex';
        }
      }
      catch (_) { /* no-op */ }
    })();
  </script>
</body>
</html>
