<!DOCTYPE html>
<html class="no-js theme-{{ preferences.get_value('simple_style') or get_setting('ui.theme_args.simple_style') or 'auto' }} center-alignment-{{ preferences.get_value('center_alignment') and 'yes' or 'no' }}" lang="{{ locale_rfc5646 }}" {% if rtl %} dir="rtl"{% endif %}>
<head>
  <meta charset="UTF-8">
  <meta name="endpoint" content="{{ endpoint }}">
  <meta name="description" content="MusaiSearch — a privacy-respecting, purple-steel metasearch experience">
  <meta name="keywords" content="MusaiSearch, search, search engine, metasearch, music, code, purple steel">
  <meta name="generator" content="searxng/{{ searx_version }}">
  <meta name="referrer" content="no-referrer">
  <meta name="robots" content="noarchive">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <meta name="theme-color" content="#1e2030">
  <script>
    (function synchronizeThemeFromQuery()
    {
      try
      {
        var root = document.documentElement;
        var search = window.location.search || '';
        var cognitiveThemeParam = null;
        if (search.length > 1)
        {
          var params = new URLSearchParams(search);
          var raw = params.get('theme');
          if (raw)
          {
            raw = String(raw).toLowerCase();
            if (raw === 'light' || raw === 'dark' || raw === 'auto' || raw === 'black')
            {
              cognitiveThemeParam = raw;
            }
          }
        }

        var memoryThemeKey = 'searxng.theme';
        var storedTheme = null;
        try { storedTheme = localStorage.getItem(memoryThemeKey); } catch (_) { storedTheme = null; }
        var serverTheme = (function()
        {
          try
          {
            var match = (root.className || '').match(/\btheme-(auto|light|dark|black)\b/);
            return match ? match[1] : null;
          }
          catch (_) { return null; }
        })();
        var endpoint = (function()
        {
          try
          {
            var m = document.querySelector('meta[name="endpoint"]');
            return m ? m.getAttribute('content') || '' : '';
          }
          catch (_) { return ''; }
        })();

        // Resolve theme precedence:
        // 1) URL param wins
        // 2) On preferences page, server wins (so user changes apply) and update storage
        // 3) Elsewhere, localStorage wins to keep experience consistent across navigation
        var preferServer = endpoint === 'preferences';
        var perceivedTheme = cognitiveThemeParam || (preferServer ? (serverTheme || storedTheme) : (storedTheme || serverTheme));

        if (perceivedTheme)
        {
          var cls = root.className || '';
          cls = cls.replace(/(^|\s)theme-(auto|light|dark|black)(?=\s|$)/, ' ').replace(/\s{2,}/g, ' ').trim();
          root.className = (cls ? cls + ' ' : '') + 'theme-' + perceivedTheme;
          // Persist resolved theme so subsequent navigations (e.g., after search) stay consistent
          try { localStorage.setItem(memoryThemeKey, perceivedTheme); } catch (_) { /* no-op */ }

          var meta = document.querySelector('meta[name="theme-color"]');
          var color = '#1e2030';
          if (perceivedTheme === 'light') { color = '#eafaf7'; }
          else if (perceivedTheme === 'black') { color = '#000000'; }
          else if (perceivedTheme === 'auto')
          {
            var localHour = (new Date()).getHours();
            var isDark = !(localHour >= 7 && localHour < 19);
            color = isDark ? '#1e2030' : '#eafaf7';
          }
          if (meta) { meta.setAttribute('content', color); }
          root.style.backgroundColor = color;
          try { if (document.body) { document.body.style.backgroundColor = color; } } catch (_) { /* no-op */ }
        }
      }
      catch (_) { /* no-op */ }
    })();
  </script>
  <style>
    /* Paint-safe fallback to avoid white flash before CSS loads */
    html,
    body {
      background: #1e2030;
      color: #ececf4;
    }
    /* Reserve gutter to prevent layout shifts when scrollbar appears/disappears */
    html { scrollbar-gutter: stable both-edges; }
    html.theme-light,
    html.theme-light body {
      background: #eafaf7;
      color: #222222;
    }
    html.theme-black,
    html.theme-black body {
      background: #000000;
      color: #e5e7eb;
    }
  </style>
  <style>
    /* Small inline Musai icon next to titles */
    .musai-open-iframe {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 6px;
      padding: 0;
      background: transparent;
      border: 2px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      vertical-align: middle;
      /* Ensure this sits above any row-wide overlay link */
      position: relative;
      z-index: 5;
      pointer-events: auto;
    }
    /* Remove morty border indicators from Musai button */
    .musai-inline-icon {
      width: 16px;
      height: 16px;
      opacity: .88;
      transition: transform .15s ease, opacity .15s ease, filter .15s ease;
    }
    .musai-open-iframe:hover .musai-inline-icon {
      opacity: 1;
      transform: scale(1.15);
      filter: brightness(1.15);
    }

    /* Create a stacking context so the inline button can layer above stretched links */
    .result h3 { position: relative; }
    /* Lower the z-index of the row overlay compared to the Musai button (if any is set) */
    .result .url_header { z-index: 1; }

    /* Fullscreen overlay to host iframe + top bar */
    #musaiOverlay {
      position: fixed;
      inset: 0;
      background: var(--musai-bg);
      z-index: 980; /* below AI chat (999) but above rest */
      display: none;
      flex-direction: column;
      /* Prevent outer-page scroll chaining and shifts */
      overscroll-behavior: contain;
      overflow: hidden;
    }
    #musaiOverlay[aria-hidden="false"] { display: flex; }
    #musaiOverlayTopbar {
      display: flex;
      align-items: center;
      gap: 12px;
      /* Keep clear of the notch on iPhone */
      padding: calc(10px + env(safe-area-inset-top)) 14px 10px 14px;
      background: linear-gradient(165deg, rgba(58,26,94,0.94), rgba(14,22,52,0.92));
      border-bottom: 1px solid rgba(149,114,255,0.45);
      box-shadow: 0 8px 20px rgba(18,16,36,0.45);
      backdrop-filter: blur(14px) saturate(140%);
      position: relative;
      z-index: 2; /* keep above loading veil */
    }
    #musaiOverlayTopbar .musai-logo {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--musai-text);
      text-decoration: none;
      font-weight: 600;
    }
    #musaiOverlayTopbar .musai-logo img { width: 18px; height: 18px; }
    /* Gradient wordmark for MusaiSearch in overlay */
    #musaiOverlayTopbar .musai-logo .wordmark
    {
      display: inline-flex;
      align-items: baseline;
      gap: 2px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    #musaiOverlayTopbar .musai-logo .wordmark .musai
    {
      background: linear-gradient(90deg, #0ea5a3 0%, #22c55e 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }
    #musaiOverlayTopbar .musai-logo .wordmark .search
    {
      background: linear-gradient(90deg, #f59e0b 0%, #84cc16 60%, #22c55e 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }
    #musaiOverlayTopbar form.musai-search {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: 8px;
      flex: 1;
    }
    #musaiOverlayTopbar form.musai-search input[type="text"] {
      width: 100%;
      min-width: 140px;
      height: 44px;
      padding: 0 14px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,255,0.35);
      background: rgba(15,23,42,0.55);
      color: var(--musai-text);
      -webkit-appearance: none;
      appearance: none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      transition: border .2s ease, box-shadow .2s ease;
    }
    #musaiOverlayTopbar form.musai-search input[type="text"]:focus {
      outline: none;
      border-color: rgba(129,140,248,0.7);
      box-shadow: 0 0 0 2px rgba(129,140,248,0.35);
    }
    #musaiOverlayTopbar form.musai-search button[type="submit"] {
      background: linear-gradient(120deg, #38bdf8, #a855f7);
      color: #fff;
      border-radius: 16px;
      border: 0;
      height: 44px;
      padding: 0 16px;
      cursor: pointer;
      flex: 0 0 auto;
      box-shadow: 0 12px 24px rgba(56,189,248,0.28);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    #musaiOverlayTopbar form.musai-search button[type="submit"]:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(148,163,255,0.3);
    }
    #musaiOverlayTopbar form.musai-search button[type="submit"]:active {
      transform: translateY(1px);
    }
    /* Clear button in overlay search/address bar */
    #musaiOverlayTopbar #musaiOverlayClear {
      background: transparent;
      color: var(--musai-muted);
      border: 0;
      height: 44px;
      width: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 1;
      border-radius: 12px;
      cursor: pointer;
      flex: 0 0 auto;
    }
    #musaiOverlayTopbar #musaiOverlayClear:hover { color: var(--musai-text); background: rgba(255,255,255,0.06); }
    #musaiOverlayTopbar #musaiOverlayClear.hidden { display: none; }
    /* Neutralize any native clear affordances that may render oddly in iframes */
    #musaiOverlayTopbar input::-webkit-search-cancel-button { -webkit-appearance: none; }
    #musaiOverlayTopbar input::-ms-clear { display: none; width: 0; height: 0; }
    /* Portal affordance when iframe is proxied through Morty */
    #musaiOverlayTopbar form.musai-search input[type="text"].is-proxied
    {
      border-color: rgba(34,197,94,.85); /* green-500 */
      background-image: linear-gradient(90deg, rgba(34,197,94,.25), rgba(250,204,21,.25)); /* green → yellow */
      background-origin: border-box;
      background-clip: padding-box, border-box;
      box-shadow: 0 0 0 2px rgba(34,197,94,.35), 0 0 18px rgba(250,204,21,.35);
      animation: portalFlow 2.2s ease-in-out infinite, portalPulse 3.6s ease-in-out infinite;
    }
    @keyframes portalFlow
    {
      0%   { box-shadow: 0 0 0 2px rgba(34,197,94,.35), 0 0 12px rgba(250,204,21,.25); }
      50%  { box-shadow: 0 0 0 2px rgba(250,204,21,.45), 0 0 18px rgba(34,197,94,.35); }
      100% { box-shadow: 0 0 0 2px rgba(34,197,94,.35), 0 0 12px rgba(250,204,21,.25); }
    }
    @keyframes portalPulse
    {
      0%, 100% { filter: saturate(1) brightness(1); }
      50%      { filter: saturate(1.15) brightness(1.05); }
    }
    /* Perceptual salience: subtle, magical shimmer for the active portal */
    @keyframes mysticalShimmer
    {
      0%, 100%
      {
        filter: saturate(1) brightness(1);
        box-shadow: 0 0 0 rgba(167,139,250,0), 0 0 0 rgba(34,197,94,0);
      }
      50%
      {
        filter: saturate(1.06) brightness(1.03);
        box-shadow: 0 0 0 2px rgba(167,139,250,.25), 0 10px 32px rgba(34,197,94,.18);
      }
    }
    #musaiOverlayTopbar .toolbar-spacer { flex: 0 0 auto; width: 0; }
    #musaiOverlayTopbar button {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 12px;
      border: 0;
      padding: 8px 12px;
      cursor: pointer;
    }
    #musaiOverlayTopbar button:hover { filter: brightness(1.1); }
    /* Close & Return button — align with Copilot gradient button */
    #musaiOverlayTopbar #musaiOverlayCloseReturn {
      background: linear-gradient(120deg, #38bdf8, #a855f7);
      color: #fff;
      border-radius: 16px;
      height: 44px;
      padding: 0 16px;
      box-shadow: 0 12px 24px rgba(56,189,248,0.28);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    #musaiOverlayTopbar #musaiOverlayCloseReturn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(148,163,255,0.3);
      filter: none;
    }
    #musaiOverlayTopbar #musaiOverlayCloseReturn:active {
      transform: translateY(1px);
    }

    /* Light theme variants for overlay toolbar */
    html.theme-light #musaiOverlayTopbar,
    html.theme-auto.est-light #musaiOverlayTopbar {
      background: linear-gradient(170deg, rgba(248,250,252,0.92), rgba(226,232,240,0.88));
      border-bottom-color: rgba(148,163,184,0.45);
      box-shadow: 0 6px 18px rgba(148,163,184,0.35);
      backdrop-filter: blur(14px) saturate(140%);
    }
    html.theme-light #musaiOverlayTopbar form.musai-search input[type="text"],
    html.theme-auto.est-light #musaiOverlayTopbar form.musai-search input[type="text"] {
      background: rgba(241,245,249,0.92);
      color: #0f172a;
      border-color: rgba(148,163,184,0.45);
    }
    #musaiOverlayFrame {
      flex: 1;
      border: 0;
      width: 100%;
      display: block; /* avoid inline baseline layout quirks */
      transform: translateZ(0); /* layer promotion for stability */
    }
    /* When overlay is visible and not loading, give iframe a gentle shimmer */
    #musaiOverlay[aria-hidden="false"]:not([data-loading="true"]) #musaiOverlayFrame
    {
      will-change: filter, box-shadow;
      animation: mysticalShimmer 4.2s ease-in-out infinite;
    }
    @media (prefers-reduced-motion: reduce)
    {
      #musaiOverlay[aria-hidden="false"]:not([data-loading="true"]) #musaiOverlayFrame { animation: none; }
    }
    /* Mystical loading veil shown while iframe is fetching */
    #musaiOverlayLoading {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: radial-gradient(ellipse at 50% 40%, rgba(107,91,149,.18), rgba(30,32,48,.88));
      pointer-events: none; /* keep toolbar interactive */
      z-index: 1; /* above iframe */
    }
    #musaiOverlay[data-loading="true"] #musaiOverlayLoading { display: flex; }
    /* While loading, keep iframe visually hidden to avoid proxy chrome flash */
    #musaiOverlay[data-loading="true"] #musaiOverlayFrame {
      visibility: hidden;
    }
    /* Harmonize bubble colors over the veil */
    #musaiOverlayLoading .ai-typing-bubble {
      background: rgba(107,91,149,.18);
      border-color: rgba(107,91,149,.45);
    }
    /* When no portal key is provided (direct open), make bubble opaque for readability */
    #musaiOverlay[data-direct="true"] #musaiOverlayLoading .ai-typing-bubble {
      background: rgba(10,12,20,1);
      border-color: rgba(107,91,149,.60);
      box-shadow: 0 8px 28px rgba(0,0,0,.45);
    }
  </style>
  <script>
    (function setThemeColorImmediate()
    {
      try
      {
        var cls = document.documentElement.className || '';
        var isAuto = /(^|\s)theme-auto(\s|$)/.test(cls);
        var light = '#eafaf7';
        var dark = '#1e2030';
        var black = '#000000';
        var color = dark;
        if (/(^|\s)theme-light(\s|$)/.test(cls))
        {
          color = light;
        }
        else if (/(^|\s)theme-black(\s|$)/.test(cls))
        {
          color = black;
        }
        else if (isAuto)
        {
          var localHour = (new Date()).getHours();
          var isDark = !(localHour >= 7 && localHour < 19);
          color = isDark ? dark : light;
        }
        var meta = document.querySelector('meta[name="theme-color"]');
        if (meta) { meta.setAttribute('content', color); }
        document.documentElement.style.backgroundColor = color;
        if (document.body) { document.body.style.backgroundColor = color; }
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  <script>
    (function defineN8NAuth()
    {
      try
      {
        var rawCredentials = 'siteuser:codemusai';
        var token = (window.btoa ? ('Basic ' + btoa(rawCredentials)) : 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp');
        window.musaiN8N = window.musaiN8N || {};
        window.musaiN8N.authToken = token;
        window.musaiN8N.getAuthHeader = function()
        {
          return { 'Authorization': window.musaiN8N.authToken };
        };
      }
      catch (_)
      {
        window.musaiN8N = window.musaiN8N || {};
        window.musaiN8N.authToken = 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp';
        window.musaiN8N.getAuthHeader = function()
        {
          return { 'Authorization': window.musaiN8N.authToken };
        };
      }
    })();
  </script>
  <title>{% block title %}{% endblock %}{{ instance_name }}</title>
  {% block meta %}{% endblock %}
  <!-- Social sharing defaults -->
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="{{ instance_name }}">
  <meta property="og:title" content="{{ instance_name }}">
  <meta property="og:description" content="MusaiSearch — a privacy-respecting, purple-steel metasearch experience">
  <meta property="og:image" content="{{ url_for('static', filename='img/musai_social.png', _external=True) }}">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="{{ instance_name }}">
  <meta name="twitter:description" content="MusaiSearch — a privacy-respecting, purple-steel metasearch experience">
  <meta name="twitter:image" content="{{ url_for('static', filename='img/musai_social.png', _external=True) }}">
  {% if rtl %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/searxng-rtl.min.css') }}" type="text/css" media="screen">
  {% else %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/searxng-ltr.min.css') }}" type="text/css" media="screen">
  {% endif %}
  {% if get_setting('server.limiter') or get_setting('server.public_instance') %}
  <link rel="stylesheet" href="{{ url_for('client_token', token=link_token) }}" type="text/css">
  {% endif %}
  <script>
    // update the css
    document.documentElement.classList.remove('no-js');
    document.documentElement.classList.add('js');
  </script>
  <script>
    (function detectInIframe()
    {
      try
      {
        if (window.top !== window.self)
        {
          document.documentElement.classList.add('in-iframe');
        }
      }
      catch (e)
      {
        document.documentElement.classList.add('in-iframe');
      }
    })();
  </script>
  <script>
    (function applyLocalAutoTheme()
    {
      try
      {
        var root = document.documentElement;
        if (!/(^|\s)theme-auto(\s|$)/.test(root.className)) { return; }
        var apply = function()
        {
          var hour = (new Date()).getHours();
          var isDark = !(hour >= 7 && hour < 19);
          root.classList.remove('est-light', 'est-dark');
          root.classList.add(isDark ? 'est-dark' : 'est-light');
          var color = isDark ? '#1e2030' : '#eafaf7';
          var meta = document.querySelector('meta[name="theme-color"]');
          if (meta) { meta.setAttribute('content', color); }
        };
        apply();
        setInterval(apply, 300000); // refresh every 5 minutes
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  {% block head %}
  <link title="{{ instance_name }}" type="application/opensearchdescription+xml" rel="search" href="{{ opensearch_url }}">
  {% endblock %}
  <link rel="icon" href="{{ url_for('static', filename='img/favicon.png') }}" sizes="any">
  <link rel="apple-touch-icon" href="{{ url_for('static', filename='img/favicon.png') }}">
  <style>
    :root {
      --musai-primary: #6e62a6; /* deeper purple-steel */
      --musai-accent: #9aa3c7;  /* cooler steel accent */
      --musai-bg: #1e2030;      /* slightly cooler base */
      --musai-bg-2: #2a2e42;    /* purple-steel surface */
      --musai-text: #ececf4;
      --musai-muted: #aab0c8;
    }
    /* Light mode palette and surfaces */
    html.theme-light {
      --musai-primary: #0f766e; /* teal-700 */
      --musai-accent: #14b8a6;  /* teal-500 */
      --musai-bg: #eafaf7;      /* very light teal */
      --musai-bg-2: #dff5f0;    /* very light teal (accent) */
      --musai-text: #222222;    /* dark text for contrast */
      --musai-muted: #506a6a;   /* muted teal-gray */
    }
    @media (prefers-color-scheme: light) {
      html.theme-auto {
        --musai-primary: #0f766e;
        --musai-accent: #14b8a6;
        --musai-bg: #eafaf7;
        --musai-bg-2: #dff5f0;
        --musai-text: #222222;
        --musai-muted: #506a6a;
      }
    }
    body {
      background: var(--musai-bg);
      color: var(--musai-text);
    }
    /* Keep content clear of the docked AI bar */
    main {
      padding-bottom: calc(120px + env(safe-area-inset-bottom));
    }
    /* When AI chat is collapsed, reduce the cognitive footprint at the bottom */
    html.ai-chat-collapsed main {
      padding-bottom: calc(56px + env(safe-area-inset-bottom));
    }
    a { color: var(--musai-muted); }
    a:hover { color: var(--musai-accent); }
    /* Ensure general text elements always inherit theme-aware font color */
    h1, h2, h3, h4, h5, h6,
    p, li, dt, dd,
    th, td,
    label, summary, figcaption
    {
      color: var(--color-base-font);
    }
    /* Ensure Musai badge text contrasts per theme (white on dark) */
    #links_on_top .link_on_top_musai span { color: var(--musai-text); }
    /* Home page title behaves like a text logo; make it about 2x larger */
    #main_index .title h1
    {
      font-size: 3rem;
      line-height: 1.1;
      margin: 0 0 8px 0;
    }
    /* Home page title-image: scale any image inside .title by ~30% */
    #main_index .title img
    {
      transform: scale(1.3);
      transform-origin: center;
      display: inline-block;
    }
    /* Do not recolor custom logo assets */
    #search_logo svg circle,
    #search_logo svg path,
    #search_logo svg rect { stroke: inherit; fill: inherit; }
    #search_logo img, #search_logo picture { display: block; height: 106px; width: auto; }
    /* Home page only: scale logo to be about four times baseline (double previous) */
    #main_index #search_logo img,
    #main_index #search_logo picture
    {
      height: 424px;
    }
    /* Create healthy spacing between the logo and the search input */
    #search_header
    {
      display: flex;
      align-items: center;
      column-gap: 16px;
    }
    /* Home page: stack logo above the search bar and center them */
    #main_index #search_header
    {
      flex-direction: column;
      align-items: center;
      row-gap: 12px;
    }
    /* Home page: center the search input and set a sensible width */
    #main_index #search_view .search_box
    {
      width: min(900px, calc(100vw - 56px));
      margin: 0 auto;
    }
    /* Search page only: gently nudge the logo for better visual alignment */
    #main_search #search_logo
    {
      position: relative;
      left: -10px; /* shift left by 10px */
      top: -2px;  /* shift up by ~2px */
    }
    /* Results page only: add extra breathing room below the logo/header */
    #main_results #search_header
    {
      padding-bottom: 16px;
    }
    /* Results page (desktop): allow the search input to span available width */
    @media (min-width: 641px) {
      #main_results #search_view { flex: 1 1 auto; min-width: 240px; }
      #main_results #search_view .search_box { width: 100%; }
      #main_results #search_view #q { width: 100%; }
    }
    /* Results page only: reduce logo size by ~30% from baseline (106px → 74px) */
    #main_results #search_logo img,
    #main_results #search_logo picture
    {
      height: 74px;
    }
    /* Pages with simple header: make the top-left logo about twice as large */
    .page_with_header img.logo
    {
      height: 212px;
      width: auto;
      display: block;
    }
    .search_box {
      background: rgba(46,50,66,.6);
      border: 1px solid var(--musai-primary);
      box-shadow: 0 4px 24px rgba(0,0,0,.35);
      border-radius: 14px;
      /* Layout for input, clear affordance, and submit button */
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      column-gap: 8px;
      padding: 6px 8px;
    }
    /* Aesthetic: subtle focus ring when typing for attentional feedback */
    .search_box:focus-within {
      box-shadow: 0 6px 28px rgba(0,0,0,.45), 0 0 0 2px rgba(167,139,250,.35);
      border-color: #a78bfa;
    }
    @media (prefers-color-scheme: light) { html.theme-auto .search_box { background: rgba(255,255,255,.9); } }
    html.theme-light .search_box { background: rgba(255,255,255,.9); }
    /* Use theme-aware input text color to ensure readability on light/dark */
    #q { color: var(--color-search-font); }
    #q::placeholder { color: #aab0c8; opacity: .9; }
    /* Room for the clear affordance when inline */
    #q
    {
      width: 100%;
      min-width: 0;
    }
    /* Clear button positioning and affordance */
    #clear_search
    {
      background: transparent;
      color: var(--musai-muted);
      border: 0;
      padding: 2px 6px;
      font-size: 18px;
      line-height: 1;
      border-radius: 8px;
      cursor: pointer;
      opacity: .9;
      align-self: center;
    }
    #clear_search:hover { color: var(--musai-text); background: rgba(255,255,255,0.06); opacity: 1; }
    #clear_search.empty
    {
      width: 0;
      padding: 0;
      margin: 0;
      opacity: 0;
      pointer-events: none;
    }
    /* Prevent iOS Safari auto-zoom on focus */
    @media (max-width: 640px) {
      #q { font-size: 16px; }
    }
    #send_search {
      background: var(--musai-primary);
      color: #fff;
      border-radius: 12px;
      border: 0;
    }
    #send_search:hover { filter: brightness(1.1); }
    footer { color: var(--musai-muted); }
    /* Add breathing room and slightly lower the categories (General, Images, Videos, etc.) */
    #categories {
      margin-top: 6px; /* nudge down to avoid feeling too high */
      padding-bottom: 12px;
    }
    /* Allow search types to wrap to a second line if needed to avoid crowding */
    #categories_container { flex-wrap: wrap; }
    .categories_toolbar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    #categories_icon_toggle {
      background: rgba(148,163,255,0.15);
      border: 1px solid rgba(148,163,255,0.35);
      color: var(--musai-text);
      border-radius: 999px;
      padding: 6px 14px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.82rem;
      letter-spacing: .05em;
      text-transform: uppercase;
      transition: background .2s ease, box-shadow .2s ease, border .2s ease;
    }
    #categories_icon_toggle .icon {
      font-size: .9rem;
      color: var(--musai-primary);
      transition: transform .2s ease;
    }
    #categories_icon_toggle:hover {
      background: rgba(148,163,255,0.25);
      box-shadow: 0 6px 18px rgba(15,23,42,0.2);
    }
    #categories_icon_toggle[aria-pressed="true"] {
      background: linear-gradient(120deg, rgba(56,189,248,0.25), rgba(168,85,247,0.35));
      border-color: rgba(129,140,248,0.55);
      color: rgba(15,23,42,0.85);
      box-shadow: 0 10px 28px rgba(129,140,248,0.25);
    }
    #categories_icon_toggle[aria-pressed="true"] .icon {
      transform: rotate(22deg) scale(1.2);
      color: rgba(79,70,229,0.9);
    }
    #categories_container.icon-only .category_name {
      display: none;
    }
    #categories_container.icon-only .category_button,
    #categories_container.icon-only .category_checkbox label {
      justify-content: center;
      gap: 0;
      padding-inline: 12px;
    }
    #categories_container.icon-only .category_checkbox label svg,
    #categories_container.icon-only .category_button svg {
      margin: 0 auto;
    }
    #categories_container.icon-only #categories_more_toggle .category_name {
      display: inline;
      margin-left: 6px;
    }
    /* Dark-mode tuning: harmonize default SearXNG variables to Musai palette */
    html.theme-dark,
    html.theme-black,
    html.theme-auto.est-dark
    {
      /* Baseline text contrast */
      --color-base-font: #e6e8ef; /* higher-contrast body text */
      --color-base-font-rgb: 230,232,239;

      /* Accents and interactive elements */
      --color-url-font: #aab0c8; /* general links */
      --color-result-link-font: #a78bfa; /* result titles */
      --color-result-link-font-highlight: #c4b5fd;
      --color-result-link-visited-font: #c4b5fd;
      --color-categories-item-selected-font: #a78bfa;
      --color-categories-item-border-selected: #a78bfa;
      --color-btn-background: #6e62a6; /* Musai primary for buttons */
      --color-btn-font: #ffffff;
      --color-search-background: #2a2e42; /* search field surface */
      --color-search-font: #ececf4; /* search field text */

      /* Surfaces */
      --color-header-background: #1e2030;
      --color-sidebar-background: #2a2e42;
      --color-result-background: #2a2e42;
      --color-result-border: #3b3f57;
      --color-result-url-font: #cbd5e1;

      /* Secondary/meta text */
      --color-sidebar-font: #f8fafc; /* sidebar and infobox text */
      --color-result-engines-font: #c0c6dc; /* engine list badges */
      --color-result-publishdate-font: #aab3cf; /* timestamps */
      --color-answer-font: #e6e8ef; /* answers block */
    }
    /* Mobile: swap categories row for a compact dropdown */
    #categories_mobile { display: none; }
    @media (max-width: 640px) {
      #categories { display: none; }
      #categories_mobile { display: block; padding: 6px 0 12px; }
      #categories_mobile select {
        width: 100%;
        padding: 10px 12px;
        background: rgba(46,50,66,.6);
        border: 1px solid var(--musai-primary);
        color: var(--musai-text);
        border-radius: 10px;
      }
    }
    @media (max-width: 640px) {
      #main_search #search_header,
      #main_results #search_header {
        flex-direction: column;
        align-items: stretch;
      }
      #main_search #search_logo,
      #main_results #search_logo {
        align-self: center;
      }
      #main_search #search_view,
      #main_results #search_view {
        width: 100%;
      }
      #main_search #search_view .search_box,
      #main_results #search_view .search_box {
        width: 100%;
      }
      #main_search #categories_mobile,
      #main_results #categories_mobile {
        width: 100%;
      }
    }
    /* Keep categories/search types away from the top-right utility links
       (apply on search and results pages only; not on the home page) */
    @media (min-width: 1025px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 160px; /* space for About / Preferences */
      }
    }
    @media (min-width: 768px) and (max-width: 1024px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 110px;
      }
    }
    /* Small landscape tablets / narrow laptops: reserve room for top-right links */
    @media (min-width: 641px) and (max-width: 767px) {
      #main_search #search_header,
      #main_results #search_header,
      #main_search #categories,
      #main_results #categories {
        padding-right: 88px;
      }
    }
    /* AI copilot — docked luminous panel */
    #ai_chat {
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      width: min(960px, calc(100vw - 24px));
      margin: 0;
      padding: 0;
      z-index: 999;
      pointer-events: none;
    }
    #ai_chat .ai-panel-shell {
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 18px clamp(16px, 4vw, 28px) calc(18px + env(safe-area-inset-bottom));
      border-radius: 24px 24px 0 0;
      background: linear-gradient(165deg, rgba(58,26,94,0.94), rgba(14,22,52,0.92));
      border: 1px solid rgba(149,114,255,0.55);
      box-shadow: 0 -8px 40px rgba(18,16,36,0.65), 0 0 80px rgba(94,234,212,0.25);
      backdrop-filter: blur(20px) saturate(160%);
      position: relative;
      overflow: hidden;
      transition: box-shadow .3s ease, transform .45s cubic-bezier(.22,1,.36,1);
    }
    #ai_chat .ai-panel-shell::before,
    #ai_chat .ai-panel-shell::after {
      content: '';
      position: absolute;
      inset: -40% -10%;
      background: radial-gradient(circle at 20% 30%, rgba(72,227,230,0.18), transparent 65%),
                  radial-gradient(circle at 80% 20%, rgba(168,85,247,0.25), transparent 70%),
                  radial-gradient(circle at 50% 80%, rgba(34,197,94,0.18), transparent 70%);
      transform: rotate(12deg);
      opacity: .75;
      mix-blend-mode: screen;
      animation: aiAurora 18s ease-in-out infinite;
      pointer-events: none;
    }
    #ai_chat .ai-panel-shell::after {
      animation-delay: -9s;
      opacity: .55;
      filter: blur(4px);
    }
    @keyframes aiAurora {
      0% { transform: rotate(8deg) scale(1); opacity: .65; }
      45% { transform: rotate(14deg) scale(1.08); opacity: .85; }
      100% { transform: rotate(4deg) scale(1); opacity: .6; }
    }
    #ai_chat .ai-panel-header {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
      z-index: 1;
    }
    #ai_chat .ai-brand {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: rgba(241,245,249,0.92);
      filter: drop-shadow(0 2px 8px rgba(20,20,35,.4));
    }
    #ai_chat .ai-brand img {
      width: 24px;
      height: 24px;
      filter: drop-shadow(0 0 6px rgba(94,234,212,.45));
    }
    #ai_chat .ai-brand .label {
      background: linear-gradient(120deg, #38bdf8, #a855f7, #f472b6);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-fill-color: transparent;
    }
    #ai_chat .ai-toggle {
      background: rgba(148,163,255,0.22);
      color: #f1f5f9;
      border-radius: 999px;
      border: 1px solid rgba(148,163,255,0.45);
      height: 38px;
      width: 46px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      transition: transform .25s ease, background .25s ease, box-shadow .25s ease;
      box-shadow: 0 4px 18px rgba(13,16,32,.35);
    }
    #ai_chat .ai-toggle:hover {
      background: rgba(148,163,255,0.35);
      transform: translateY(-1px);
      box-shadow: 0 8px 24px rgba(13,16,32,.45);
    }
    #ai_chat .ai-header-actions {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #ai_chat #ai_chat_status {
      color: rgba(226,232,240,0.85);
      font-size: .78rem;
      letter-spacing: .05em;
      text-transform: uppercase;
    }
    #ai_chat .ai-panel-body {
      display: flex;
      flex-direction: column;
      gap: 14px;
      position: relative;
      z-index: 1;
      transition: max-height .45s cubic-bezier(.22,1,.36,1), opacity .3s ease;
      max-height: clamp(220px, 38vh, 420px);
    }
    #ai_chat.collapsed .ai-panel-body {
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      pointer-events: none;
    }
    #ai_chat.collapsed .ai-panel-shell {
      padding-top: 12px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      gap: 8px;
      box-shadow: 0 -4px 24px rgba(18,16,36,0.55);
    }
    #ai_chat.collapsed .ai-panel-shell::before,
    #ai_chat.collapsed .ai-panel-shell::after {
      opacity: .45;
    }
    #ai_chat_output {
      position: relative;
      background: rgba(12,16,36,0.55);
      border: 1px solid rgba(148,163,255,0.35);
      border-radius: 16px;
      padding: 16px;
      max-height: clamp(160px, 32vh, 360px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      white-space: pre-wrap;
      color: #f1f5f9;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    #ai_chat_output[hidden] {
      display: none !important;
    }
    #ai_chat.collapsed #ai_chat_output {
      display: none;
    }
    #ai_chat_output .ai-hide {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(15,23,42,0.35);
      color: #ffffff;
      border: 1px solid rgba(148,163,255,0.35);
      padding: 4px 8px;
      border-radius: 999px;
      line-height: 1;
      font-size: 16px;
      cursor: pointer;
      opacity: .85;
      transition: background .25s ease, opacity .25s ease;
    }
    #ai_chat_output .ai-hide:hover {
      opacity: 1;
      background: rgba(30,41,78,0.55);
    }
    #ai_chat form {
      display: flex;
      align-items: stretch;
      flex-wrap: wrap;
      gap: 12px;
      margin: 0;
    }
    #ai_chat #ai_mode {
      background: rgba(148,163,255,0.18);
      color: #e2e8f0;
      border-radius: 14px;
      border: 1px solid rgba(148,163,255,0.35);
      height: 44px;
      padding: 0 14px;
      font-weight: 600;
      letter-spacing: .04em;
      text-transform: uppercase;
      flex: 0 0 auto;
    }
    #ai_chat .ai-pov-control {
      position: relative;
      display: inline-flex;
      align-items: center;
      flex: 0 0 auto;
    }
    #ai_chat #ai_perspective {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }
    #ai_chat label.ai-pov-switch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 0 16px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,255,0.32);
      background: rgba(148,163,255,0.18);
      color: #f8fafc;
      cursor: pointer;
      font-size: .82rem;
      letter-spacing: .09em;
      text-transform: uppercase;
      transition: background .25s ease, box-shadow .25s ease, border .25s ease;
    }
    #ai_chat label.ai-pov-switch .sparkle {
      font-size: 0.9rem;
      opacity: .75;
      transition: transform .25s ease, opacity .25s ease;
    }
    #ai_chat #ai_perspective:checked + label.ai-pov-switch {
      background: linear-gradient(120deg, rgba(56,189,248,0.45), rgba(168,85,247,0.52));
      border-color: rgba(192,132,252,0.7);
      box-shadow: 0 0 18px rgba(129,140,248,0.52);
    }
    #ai_chat #ai_perspective:checked + label.ai-pov-switch .sparkle {
      opacity: 1;
      transform: rotate(12deg) scale(1.15);
    }
    #ai_chat textarea {
      flex: 1 1 220px;
      min-width: 0;
      height: auto;
      min-height: 40px;
      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,255,0.35);
      background: rgba(15,23,42,0.55);
      color: #f8fafc;
      resize: none;
      line-height: 1.45;
      overflow-y: auto;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      transition: border .2s ease, box-shadow .2s ease;
    }
    #ai_chat textarea:focus {
      outline: none;
      border-color: rgba(129,140,248,0.7);
      box-shadow: 0 0 0 2px rgba(129,140,248,0.35);
    }
    #ai_chat #ai_chat_send {
      background: linear-gradient(120deg, #38bdf8, #a855f7);
      color: #fff;
      border-radius: 16px;
      border: 0;
      height: 44px;
      width: 54px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(56,189,248,0.35);
      transition: transform .2s ease, box-shadow .2s ease;
    }
    #ai_chat #ai_chat_send:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(148,163,255,0.35);
    }
    #ai_chat #ai_chat_send:active {
      transform: translateY(1px);
    }
    #ai_chat #ai_backToTop {
      background: rgba(148,163,255,0.22);
      color: #fff;
      border-radius: 999px;
      border: 1px solid rgba(148,163,255,0.45);
      height: 38px;
      width: 38px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0;
      line-height: 1;
      cursor: pointer;
      transition: transform .25s ease, background .25s ease;
    }
    #ai_chat #ai_backToTop svg { width: 18px; height: 18px; display: block; }
    #ai_chat #ai_backToTop:hover {
      background: rgba(148,163,255,0.35);
      transform: translateY(-1px);
    }
    #ai_chat input[disabled],
    #ai_chat textarea[disabled],
    #ai_chat button[disabled] {
      opacity: .55;
      cursor: not-allowed;
      box-shadow: none;
    }
    @media (min-width: 641px) {
      #ai_chat #ai_mode { display: none; }
    }
    @media (max-width: 1024px) {
      #ai_chat { width: calc(100% - 12px); }
    }
    @media (prefers-reduced-motion: reduce) {
      #ai_chat .ai-panel-shell {
        transition: none;
      }
      #ai_chat .ai-panel-shell::before,
      #ai_chat .ai-panel-shell::after {
        animation: none;
      }
    }
    @media (max-width: 640px) {
      #ai_chat .ai-panel-shell {
        padding: 16px 14px calc(16px + env(safe-area-inset-bottom));
        gap: 12px;
        backdrop-filter: blur(14px) saturate(150%);
        box-shadow: 0 -6px 30px rgba(18,16,36,0.55), 0 0 60px rgba(94,234,212,0.2);
      }
      #ai_chat .ai-panel-shell::before,
      #ai_chat .ai-panel-shell::after {
        opacity: .55;
        animation-duration: 26s;
      }
      #ai_chat form {
        gap: 10px;
      }
      #ai_chat textarea {
        flex-basis: 100%;
      }
      #ai_chat #ai_chat_send {
        width: 48px;
        height: 48px;
        font-size: 20px;
      }
    }
    html.theme-light #ai_chat .ai-panel-shell,
    html.theme-auto.est-light #ai_chat .ai-panel-shell {
      background: linear-gradient(170deg, rgba(248,250,252,0.92), rgba(226,232,240,0.88));
      border-color: rgba(148,163,184,0.45);
      box-shadow: 0 -8px 36px rgba(148,163,184,0.4), 0 0 60px rgba(14,165,233,0.18);
    }
    html.theme-light #ai_chat_output,
    html.theme-auto.est-light #ai_chat_output {
      background: rgba(241,245,249,0.92);
      color: #0f172a;
      border-color: rgba(148,163,184,0.45);
    }
    html.theme-light #ai_chat #ai_chat_status,
    html.theme-auto.est-light #ai_chat #ai_chat_status {
      color: rgba(100,116,139,0.85);
    }
    html.in-iframe #ai_chat { width: calc(100% - 12px); }
    @media (prefers-reduced-transparency: reduce) {
      #ai_chat .ai-panel-shell,
      html.theme-light #ai_chat .ai-panel-shell,
      html.theme-auto.est-light #ai_chat .ai-panel-shell {
        backdrop-filter: none;
        background: var(--musai-bg-2);
        box-shadow: 0 -4px 24px rgba(18,16,36,0.45);
      }
    }
    @supports not ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))) {
      #ai_chat .ai-panel-shell,
      html.theme-light #ai_chat .ai-panel-shell,
      html.theme-auto.est-light #ai_chat .ai-panel-shell {
        backdrop-filter: none;
        background: var(--musai-bg-2);
      }
    }
    /* Typing indicator bubble (Musai-style) */
    .ai-typing-bubble {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(107,91,149,.10);
      border: 1px solid rgba(107,91,149,.45);
      box-shadow: 0 2px 16px rgba(0,0,0,.25);
      position: relative;
      overflow: hidden;
    }
    .ai-typing-bubble .ai-typing-icon {
      font-size: 16px;
      line-height: 1;
    }
    .ai-typing-bubble .ai-typing-icon img { width: 16px; height: 16px; display: block; }
    .ai-typing-bubble .ai-typing-label {
      font-size: 0.95rem;
      color: var(--musai-text);
      opacity: .9;
    }
    .ai-typing-bubble .ai-typing-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #a78bfa; /* purple-400 */
    }
    /* Quantum-mode typing bubble color variants */
    .ai-typing-bubble.red { background: rgba(220,38,38,.10); border-color: rgba(185,28,28,.55); }
    .ai-typing-bubble.red .ai-typing-dot { background: #ef4444; }
    .ai-typing-bubble.blue { background: rgba(37,99,235,.10); border-color: rgba(29,78,216,.55); }
    .ai-typing-bubble.blue .ai-typing-dot { background: #60a5fa; }
    .ai-typing-bubble.violet { background: rgba(124,58,237,.10); border-color: rgba(109,40,217,.55); }
    .ai-typing-bubble.violet .ai-typing-dot { background: #a78bfa; }
    html.theme-light .ai-typing-bubble {
      background: rgba(20,184,166,.10);
      border-color: rgba(20,184,166,.45);
    }
    /* Glow and dots animation */
    @keyframes mysticalGlow {
      0%, 100% { box-shadow: 0 0 14px rgba(167,139,250,.25); }
      50% { box-shadow: 0 0 22px rgba(167,139,250,.45); }
    }
    @keyframes mysticalDots {
      0%, 80%, 100% { transform: scale(0.8); opacity: 0.6; }
      40% { transform: scale(1.15); opacity: 1; }
    }
    .mystical-glow {
      animation: mysticalGlow 2s ease-in-out infinite;
    }
    .mystical-dots {
      animation: mysticalDots 1.4s ease-in-out infinite;
      display: inline-block;
    }
    /* Main response bubble (purplish) */
    .ai-main-bubble {
      background: #6e62a6; /* steel purple (opaque) */
      border: 1px solid #4f3f85; /* deeper steel border for contrast */
      color: #ffffff; /* ensure high-contrast text */
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 8px;
      white-space: pre-wrap;
    }
    /* Quantum-mode main bubble color variants (applied per message) */
    .ai-main-bubble.red { background: #dc2626; border-color: #b91c1c; color: #ffffff; }
    .ai-main-bubble.blue { background: #2563eb; border-color: #1d4ed8; color: #ffffff; }
    .ai-main-bubble.violet { background: #7c3aed; border-color: #6d28d9; color: #ffffff; }
    /* POV toggles and panels (red = logical, blue = creative) */
    .ai-pov-toggle-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 8px 0 6px 0;
      flex-wrap: wrap;
    }
    .ai-pov-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid transparent;
      cursor: pointer;
      user-select: none;
      background: rgba(255,255,255,0.06);
      color: var(--musai-text);
    }
    .ai-pov-toggle[disabled] {
      opacity: .5;
      cursor: not-allowed;
    }
    .ai-pov-toggle.red {
      border-color: #b91c1c;
      background: #dc2626;
      color: #ffffff;
    }
    .ai-pov-toggle.red.active {
      background: #b91c1c;
      box-shadow: inset 0 0 0 1px #7f1d1d;
    }
    .ai-pov-toggle.blue {
      border-color: #1d4ed8;
      background: #2563eb;
      color: #ffffff;
    }
    .ai-pov-toggle.blue.active {
      background: #1d4ed8;
      box-shadow: inset 0 0 0 1px #1e3a8a;
    }
    /* New: Perspective (violet) bubble toggle */
    .ai-pov-toggle.violet {
      border-color: #6d28d9;
      background: #7c3aed;
      color: #ffffff;
    }
    /* Show the Perspective header when either collapse mode is active */
    .ai-pov-toggle.violet { display: none; }
    html.ai-chat-collapsed .ai-pov-toggle.violet,
    html.ai-chat-output-collapsed .ai-pov-toggle.violet { display: inline-flex; }
    .ai-pov-toggle.violet.active {
      background: #6d28d9;
      box-shadow: inset 0 0 0 1px #4c1d95;
    }
    .ai-pov-panel {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 10px;
      margin-top: 6px;
      white-space: pre-wrap;
      font-size: 0.95rem;
    }
    .ai-pov-panel.red {
      background: #dc2626;
      border-color: #b91c1c;
      color: #ffffff;
    }
    .ai-pov-panel.blue {
      background: #2563eb;
      border-color: #1d4ed8;
      color: #ffffff;
    }
    .ai-pov-panel.violet {
      background: #7c3aed;
      border-color: #6d28d9;
      color: #ffffff;
    }

    /* Collapsible AI response bubble behavior when clicking outside */
    /* Two collapse modes:
       - ai-chat-collapsed: whole toolbar shrinks (via toggle)
       - ai-chat-output-collapsed: only the response bubble collapses to header
    */
    html.ai-chat-collapsed #ai_chat_output,
    html.ai-chat-output-collapsed #ai_chat_output {
      padding: 0;
      border: 0;
      box-shadow: none;
      max-height: 0;
      overflow: hidden;
      background: transparent;
    }
    html.ai-chat-collapsed #ai_chat_output .ai-main-bubble,
    html.ai-chat-collapsed #ai_chat_output .ai-pov-panel,
    html.ai-chat-output-collapsed #ai_chat_output .ai-main-bubble,
    html.ai-chat-output-collapsed #ai_chat_output .ai-pov-panel {
      display: none !important;
    }
    html.ai-chat-collapsed #ai_chat_output .ai-hide,
    html.ai-chat-output-collapsed #ai_chat_output .ai-hide {
      display: none !important;
    }
    /* Mobile refinements for iPhone widths */
    @media (max-width: 640px) {
      /* So header elements don’t overflow */
      #search_header { flex-wrap: wrap; row-gap: 8px; }
      #search_logo img, #search_logo picture { height: 74px; }
      /* Home page only: keep the larger proportion on small screens */
      #main_index #search_logo img, #main_index #search_logo picture { height: 148px; }

      /* Keep header logo proportionate on small screens */
      .page_with_header img.logo { height: 148px; }

      /* Larger touch targets and readable text to avoid auto-zoom */
      #ai_chat textarea { min-height: 48px; font-size: 16px; }
      #ai_chat label.ai-pov-switch { height: 44px; }
      #ai_chat #ai_chat_send { height: 52px; width: 52px; font-size: 20px; }
      #ai_chat .ai-toggle { height: 44px; width: 44px; font-size: 18px; }

      /* Ensure the panel still reads as raised on compact screens */
      #ai_chat .ai-panel-shell { border-radius: 20px 20px 0 0; }

      /* Keep the back-to-top button clear of the AI bar */
      #backToTop { bottom: calc(88px + env(safe-area-inset-bottom)); }
      /* If collapsed on small screens, further reduce the offset */
      html.ai-chat-collapsed #backToTop { bottom: calc(56px + env(safe-area-inset-bottom)); }
    }
  </style>
  <style>
    /* EST-based overrides for auto theme */
    html.theme-auto.est-light {
      --musai-primary: #0f766e;
      --musai-accent: #14b8a6;
      --musai-bg: #eafaf7;
      --musai-bg-2: #dff5f0;
      --musai-text: #222222;
      --musai-muted: #506a6a;
    }
    html.theme-auto.est-dark {
      --musai-primary: #6e62a6;
      --musai-accent: #9aa3c7;
      --musai-bg: #1e2030;
      --musai-bg-2: #2a2e42;
      --musai-text: #ececf4;
      --musai-muted: #aab0c8;
    }
    html.theme-auto.est-light .search_box { background: rgba(255,255,255,.9); }
    html.theme-auto.est-dark .search_box { background: rgba(46,50,66,.6); }
  </style>
  <style>
    /* Hide banner element */
    #banner
    {
      display: none !important;
    }
  </style>
  <style>
    /* Dock: keep flush with bottom edge on all pages */
    body.index_endpoint #ai_chat { bottom: 0; }
  </style>
  <style>
    /* Ensure AI dock remains flush on results and embedded contexts */
    body.search_endpoint #ai_chat,
    body.results_endpoint #ai_chat
    {
      bottom: 0;
    }
    html.in-iframe #ai_chat
    {
      bottom: 0;
    }
    html.musai-overlay-open #ai_chat
    {
      bottom: 0;
    }
  </style>
</head>
<body class="{{ endpoint }}_endpoint" >
  <main id="main_{{  self._TemplateReference__context.name|replace("simple/", "")|replace(".html", "") }}" class="{{body_class}}">
    {% if errors %}
        <div class="dialog-error" role="alert">
            <a href="#" class="close" aria-label="close" title="close">×</a>
            <ul>
            {% for message in errors %}
                <li>{{ message }}</li>
            {% endfor %}
            </ul>
        </div>
    {% endif %}

    <nav id="links_on_top">
      {%- from 'simple/icons.html' import icon_big -%}
      {%- block linkto_about -%}
        <a href="{{ url_for('info', pagename='about') }}" class="link_on_top_about">{{ icon_big('information-circle') }}<span>{{ _('About') }}</span></a>
      {%- endblock -%}
      {%- block linkto_donate -%}
        {%- if donation_url -%}
        <a href="{{ donation_url }}" class="link_on_top_donate">{{ icon_big('heart') }}<span>{{ _('Donate') }}</span></a>
        {%- endif -%}
      {%- endblock -%}
      {%- block linkto_preferences -%}
        <a href="{{ url_for('preferences') }}" class="link_on_top_preferences">{{ icon_big('settings') }}<span>{{ _('Preferences') }}</span></a>
      {%- endblock -%}
      {%- block linkto_musai -%}
        <a href="https://musai.codemusic.ca" class="link_on_top_musai">{{ icon_big('musical-notes') }}<span>{{ _('Musai') }}</span></a>
      {%- endblock -%}
    </nav>
    {% block header %}
    {% endblock %}
    {% block content %}
    {% endblock %}
  </main>
  {% if endpoint != 'index' %}
  <section id="ai_chat" aria-label="AI assistant"
    data-q="{{ (q or '')|e }}"
    data-categories="{{ (selected_categories and selected_categories|join(',') or '')|e }}"
    data-pageno="{{ (pageno or 1) }}"
    data-time-range="{{ (time_range or '')|e }}"
    data-language="{{ (current_language or '')|e }}"
    data-safesearch="{{ (safesearch or '')|e }}"
    data-logo="{{ url_for('static', filename='img/logo_musai_symbol.png') }}">
    <div class="ai-panel-shell mystical-glow">
      <div class="ai-panel-header">
        <button id="ai_chat_toggle" class="ai-toggle" type="button" aria-label="Collapse AI assistant" title="Collapse">▾</button>
        <span class="ai-brand">
          <img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt="">
          <span class="label">Musai Copilot</span>
        </span>
        <div class="ai-header-actions">
          <small id="ai_chat_status" aria-live="polite"></small>
          <button id="ai_backToTop" type="button" title="Back to top" aria-label="Back to top" hidden>
            {% from 'simple/icons.html' import icon_big %}{{ icon_big('navigate-up') }}
          </button>
        </div>
      </div>
      <div class="ai-panel-body">
        <div id="ai_chat_output" hidden></div>
        <form id="ai_chat_form" aria-label="Ask Musai..." action="javascript:void(0)">
          <select id="ai_mode" aria-label="Mode">
            <option value="chat" selected>Chat</option>
            <option value="search">Search</option>
          </select>
          <div class="ai-pov-control">
            <input id="ai_perspective" type="checkbox" checked aria-label="Perspective Thinking">
            <label for="ai_perspective" class="ai-pov-switch" title="Perspective Thinking (POV)"><span class="sparkle" aria-hidden="true">✧</span><span class="text">POV</span></label>
          </div>
          <textarea id="ai_chat_input" rows="1" autocomplete="off" placeholder="Ask Musai..." inputmode="text" enterkeyhint="send" autocapitalize="sentences" aria-label="Ask Musai"></textarea>
          <button id="ai_chat_send" type="submit" title="Send" aria-label="Send">↵</button>
        </form>
      </div>
    </div>
  </section>
  {% endif %}
  <footer>
    <p>
      <a href="https://musai.codemusic.ca"><strong>MusaiSearch</strong></a> — powered by SearXNG, N8N, Redmine, and Ollama<br>
      <a href="https://codemusic.ca">CodeMusic Construction</a> in association with <a href="https://dtour.codemusic.ca">DTour Designs</a>
    </p>
  </footer>
  {% if get_setting('ui.allow_musairesult_iframes') %}
  <div id="musaiOverlay" aria-hidden="true" data-origin-id="">
    <div id="musaiOverlayTopbar">
      <a class="musai-logo" href="https://search.codemusic.ca" title="Back to MusaiSearch">
        <img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt="Musai">
        <span class="wordmark"><span class="musai">Musai</span><span class="search">Search</span></span>
      </a>
      <form id="musaiOverlaySearch" class="musai-search" method="GET" action="{{ url_for('search') }}" role="search">
        <input id="musaiOverlayQ" name="q" type="text" placeholder="{{ _('Search for...') }}" autocomplete="off" autocapitalize="none" spellcheck="false" autocorrect="off" dir="auto">
        <button id="musaiOverlayClear" type="button" title="{{ _('Clear') }}" aria-label="{{ _('Clear') }}">×</button>
        <button id="musaiOverlaySubmit" type="submit" aria-label="{{ _('search') }}">{{ _('Search') }}</button>
      </form>
      <div class="toolbar-spacer"></div>
      <button type="button" id="musaiOverlayCloseReturn" title="Close and return to results">Close &amp; Return</button>
    </div>
    <div id="musaiOverlayLoading" aria-hidden="true">
      <div class="ai-typing-bubble mystical-glow">
        <span class="ai-typing-icon"><img src="{{ url_for('static', filename='img/logo_musai_symbol.png') }}" alt=""></span>
        <span class="ai-typing-label">{{ _('Establishing Portal…') }}</span>
        <span class="ai-typing-dot mystical-dots"></span>
        <span class="ai-typing-dot mystical-dots" style="animation-delay:.2s"></span>
        <span class="ai-typing-dot mystical-dots" style="animation-delay:.4s"></span>
      </div>
    </div>
    <iframe id="musaiOverlayFrame" src="about:blank" sandbox="allow-scripts allow-forms allow-same-origin allow-popups allow-popups-to-escape-sandbox"></iframe>
  </div>
  {% endif %}
  
  {% if get_setting('ui.allow_musairesult_iframes') %}
  <script>
    (function attachMusaiOverlay()
    {
      try
      {
        var overlay = document.getElementById('musaiOverlay');
        if (!overlay)
        {
          return;
        }
        var rootHtml = document.documentElement;
        var frame = document.getElementById('musaiOverlayFrame');
        var loadingVeil = document.getElementById('musaiOverlayLoading');
        var btnCloseReturn = document.getElementById('musaiOverlayCloseReturn');
        var searchForm = document.getElementById('musaiOverlaySearch');
        var searchInput = document.getElementById('musaiOverlayQ');
        var searchClearBtn = document.getElementById('musaiOverlayClear');
        var searchSubmitBtn = document.getElementById('musaiOverlaySubmit');
        var logoLink = document.querySelector('#musaiOverlayTopbar .musai-logo');
        // Fallback state to recover if the iframe can't load (X-Frame-Options / CSP)
        var currentTargetUrl = '';
        var fallbackTimer = null;
        var lastKnownUrl = '';
        var initialOverlayUrl = '';
        var initialLoadDone = false;
        var loadCount = 0;
        var navigatedAway = false;

        // Cognitive hygiene: hide Morty chrome as early as possible
        var hideMortyChromeEarly = function(targetFrame)
        {
          try
          {
            var f = targetFrame || frame;
            if (!f) { return; }
            var doc = f.contentDocument || (f.contentWindow && f.contentWindow.document) || null;
            if (!doc || !doc.head) { return; }
            // If we already injected, skip
            if (doc.getElementById('musai-morty-suppress')) { return; }
            var style = doc.createElement('style');
            style.id = 'musai-morty-suppress';
            style.textContent = [
              'header, .header, #header { display: none !important; }',
              '.morty-header, .morty-topbar, .morty-toolbar, #mortyheader, #morty-header, #mortyHeader, .mortyheader { display: none !important; }',
              '#topbar, .topbar, .toolbar { display: none !important; }',
              'footer, .footer, #footer { display: none !important; }',
              '.morty-footer, .morty-bottombar, #morty-bottombar, .morty-banner, .morty-notice, .morty-bottom { display: none !important; }',
              '.fixed-bottom, .sticky-bottom { display: none !important; }',
              'body { margin-top: 0 !important; margin-bottom: 0 !important; }',
              'html { scrollbar-gutter: stable both-edges; }'
            ].join('\n');
            doc.head.appendChild(style);
          }
          catch (_) { /* cross-origin or CSP; ignore */ }
        };

        var updateLastKnownUrl = function()
        {
          try
          {
            var newUrl = '';
            try
            {
              if (frame && frame.contentWindow && frame.contentWindow.location)
              {
                newUrl = frame.contentWindow.location.href || '';
              }
            }
            catch (_) { /* cross-origin, ignore */ }
            if (!newUrl)
            {
              try { newUrl = (frame && frame.src) || ''; } catch (_) { /* no-op */ }
            }
            if (newUrl)
            {
              lastKnownUrl = newUrl;
            }
          }
          catch (_) { /* no-op */ }
        };
        function reflectClearButton()
        {
          try
          {
            if (!searchInput || !searchClearBtn) { return; }
            var hasValue = !!(searchInput.value && searchInput.value.length);
            if (hasValue) { searchClearBtn.classList.remove('hidden'); }
            else { searchClearBtn.classList.add('hidden'); }
          }
          catch (_) { /* no-op */ }
        }
        // Cognitive affordance: reflect intent (Search vs Go) based on perceived URL-ness
        var hasScheme = function(value)
        {
          try { return /^(?:[a-z][a-z0-9+.-]*):\/\//i.test(value || ''); }
          catch (_) { return false; }
        };
        var looksLikeUrl = function(value)
        {
          try
          {
            var s = (value || '').trim();
            if (!s || /\s/.test(s)) { return false; }
            if (hasScheme(s)) { return true; }
            if (/^www\./i.test(s)) { return true; }
            if (/^(?:localhost)(?::\d+)?(?:[\/?#].*)?$/i.test(s)) { return true; }
            if (/^(?:\d{1,3})(?:\.\d{1,3}){3}(?::\d+)?(?:[\/?#].*)?$/i.test(s)) { return true; }
            return /^[^\s]+\.[a-z]{2,}(?:[\/?#].*)?$/i.test(s);
          }
          catch (_) { return false; }
        };
        var reflectSubmitAffordance = function()
        {
          try
          {
            if (!searchInput || !searchSubmitBtn) { return; }
            var q = (searchInput.value || '').trim();
            var go = looksLikeUrl(q);
            var label = go ? 'Go' : 'Search';
            searchSubmitBtn.textContent = label;
            searchSubmitBtn.setAttribute('aria-label', label.toLowerCase());
            try { searchInput.setAttribute('enterkeyhint', go ? 'go' : 'search'); } catch (_) { /* no-op */ }
          }
          catch (_) { /* no-op */ }
        };

        var showUrlInSearchInput = function(url)
        {
          try
          {
            if (!searchInput) { return; }
            var value = '';
            try { value = deMortyUrl(url || '') || url || ''; } catch (_) { value = url || ''; }
            if (value) { searchInput.value = value; }
            reflectClearButton();
            reflectSubmitAffordance();
          }
          catch (_) { /* no-op */ }
        };
        // Adjust loading narrative to reflect portal state
        var setLoadingMessage = function(text)
        {
          try
          {
            var label = document.querySelector('#musaiOverlayLoading .ai-typing-label');
            if (label && typeof text === 'string' && text)
            {
              label.textContent = text;
            }
          }
          catch (_) { /* no-op */ }
        };
        // Visual salience: make proxy state cognitively obvious on the input field
        var reflectProxyState = function(url)
        {
          try
          {
            if (!searchInput) { return; }
            if (isMortyUrl(url || ''))
            {
              searchInput.classList.add('is-proxied');
            }
            else
            {
              searchInput.classList.remove('is-proxied');
            }
          }
          catch (_) { /* no-op */ }
        };

        var errorDialog = document.querySelector('.dialog-error');
        // Morty helpers to ensure iframe URLs are proxied and signed with hash
        var SIGN_WEBHOOK = 'https://n8n.codemusic.ca/webhook/sign-morty';
        var mortyPrefix = ("{{ (get_setting('server.result_proxy.url') or '')|e }}" || '').trim();
        var mortyPrefixPath = (function()
        {
          try
          {
            return (new URL(mortyPrefix, window.location.href).pathname) || mortyPrefix;
          }
          catch (_)
          {
            return mortyPrefix;
          }
        })();
        try { console.debug('[MortySign] config', { mortyPrefix: mortyPrefix, mortyPrefixPath: mortyPrefixPath }); } catch (_) {}
        var hasMortyHash = function(url)
        {
          try { return /[?&](?:mortyhash|hash)=/.test(url); } catch (_) { return false; }
        };
        var isMortyUrl = function(url)
        {
          try
          {
            if (!mortyPrefix) { return false; }
            var s = url || '';
            if (!s) { return false; }
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0)
            {
              var u = new URL(s, window.location.href);
              var href = u.href || '';
              var path = u.pathname || '';
              return (href.indexOf(mortyPrefix) === 0) || (path.indexOf(mortyPrefixPath) === 0);
            }
            return (s.indexOf(mortyPrefix) === 0) || (s.indexOf(mortyPrefixPath) === 0);
          }
          catch (_) { return false; }
        };
        // shouldUseMortyForUrl removed; eligibility is now decided during signing
        var mortyProxify = function(url)
        {
          try
          {
            if (!mortyPrefix || !url) { return url; }
            if (isMortyUrl(url)) { return url; }
            if (url.indexOf('http://') === 0 || url.indexOf('https://') === 0)
            {
              var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
              return mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(url);
            }
            return url;
          }
          catch (_) { return url; }
        };
        var deMortyUrl = function(url)
        {
          try
          {
            var s = url || '';
            if (!s || !isMortyUrl(s)) { return s; }
            var u = new URL(s, window.location.href);
            // Prefer query-param style
            var mu = u.searchParams && u.searchParams.get ? (u.searchParams.get('mortyurl') || '') : '';
            if (mu) { return mu; }
            // Fallback: path-style /morty/https/...
            var path = u.pathname || '';
            var base = mortyPrefixPath || '/morty/';
            var i = path.indexOf(base);
            var suffix = (i >= 0) ? path.slice(i + base.length) : path;
            if (suffix.indexOf('https/') === 0) { return 'https://' + suffix.slice(6); }
            if (suffix.indexOf('http/') === 0) { return 'http://' + suffix.slice(5); }
            return s;
          }
          catch (_) { return url; }
        };
        var stableUrlString = function(input)
        {
          try { return new URL(input, window.location.href).href; } catch (_) { return input || ''; }
        };
        var signMortyUrl = function(url)
        {
          return new Promise(function(resolve)
          {
            var candidate = stableUrlString(url);
            if (!candidate)
            {
              resolve(candidate);
              return;
            }
            // Always sign the plain target URL; if Morty-style passed, extract mortyurl first
            var plainTarget = isMortyUrl(candidate) ? deMortyUrl(candidate) : candidate;
            var buildMorty = function(target, hash)
            {
              try
              {
                var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
                var signed = mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(target);
                if (hash) { signed += '&mortyhash=' + String(hash).toLowerCase(); }
                return signed;
              }
              catch (_) { return candidate; }
            };
            // If already has mortyhash, keep as-is
            if (isMortyUrl(candidate) && hasMortyHash(candidate))
            {
              resolve(candidate);
              return;
            }
            var didResolve = false;
            var settle = function(value)
            {
              if (didResolve) { return; }
              didResolve = true;
              resolve(value || buildMorty(plainTarget));
            };
            // Helper function to handle connection errors and retry with proper headers
            var attemptSigning = function(usePost, attemptNumber)
            {
              if (attemptNumber > 3) {
                console.warn('[MortySign] Max retry attempts reached for', plainTarget);
                settle(buildMorty(plainTarget));
                return;
              }

              var headers = Object.assign(
                { 'Content-Type': 'application/json' },
                (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function')
                  ? window.musaiN8N.getAuthHeader()
                  : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }
              );

              // For connection issues, add Connection: close header on retry attempts
              if (attemptNumber > 1) {
                headers['Connection'] = 'close';
                console.debug('[MortySign] Adding Connection: close header for attempt', attemptNumber);
              }

              var fetchPromise;
              if (usePost) {
                fetchPromise = fetch(SIGN_WEBHOOK, {
                  method: 'POST',
                  headers: headers,
                  body: JSON.stringify({ url: plainTarget })
                });
              } else {
                var urlParam = encodeURIComponent(plainTarget);
                fetchPromise = fetch(SIGN_WEBHOOK + '?url=' + urlParam, {
                  method: 'GET',
                  headers: headers
                });
              }

              fetchPromise.then(function(r)
              {
                if (!r.ok) { throw new Error('HTTP ' + r.status); }
                return r.json().catch(function(){ return { url: plainTarget }; });
              }).then(function(data)
              {
                var nextUrl = (data && data.signed_url) || '';
                var mh = (data && (data.mortyhash || data.hash)) || '';
                if (!nextUrl)
                {
                  nextUrl = buildMorty(plainTarget, mh);
                }
                try {
                  console.debug('[MortySign] signing success on attempt', attemptNumber, { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) });
                } catch (_) {}
                settle(nextUrl || buildMorty(plainTarget, mh));
              }).catch(function(error)
              {
                var errorMsg = error.message || '';
                var isConnectionError = errorMsg.includes('connection') ||
                                       errorMsg.includes('ECONNRESET') ||
                                       errorMsg.includes('closed') ||
                                       errorMsg.includes('before returning the first response byte');

                console.debug('[MortySign] attempt', attemptNumber, 'failed:', errorMsg, { isConnectionError: isConnectionError });

                if (isConnectionError) {
                  // Retry with different approach for connection errors
                  if (usePost) {
                    // First retry: switch to GET method
                    setTimeout(function() {
                      attemptSigning(false, attemptNumber + 1);
                    }, 1000 * attemptNumber); // Exponential backoff
                  } else {
                    // Second retry: try POST again with Connection: close
                    setTimeout(function() {
                      attemptSigning(true, attemptNumber + 1);
                    }, 1000 * attemptNumber);
                  }
                } else if (usePost) {
                  // For non-connection errors, try GET fallback
                  setTimeout(function() {
                    attemptSigning(false, attemptNumber + 1);
                  }, 500);
                } else {
                  // Final fallback: build unsigned URL
                  console.warn('[MortySign] All signing attempts failed for', plainTarget, errorMsg);
                  settle(buildMorty(plainTarget));
                }
              });
            };

            // Start with POST attempt
            attemptSigning(true, 1);
          });
        };
        var openOverlay = function(url, originId, options)
        {
          overlay.setAttribute('aria-hidden', 'false');
          try { overlay.setAttribute('data-loading', 'true'); } catch (_) { /* no-op */ }
          try { rootHtml && rootHtml.classList.add('musai-overlay-open'); } catch (_) { /* no-op */ }
          if (originId) { overlay.dataset.originId = originId; }
          try { frame.src = 'about:blank'; } catch (_) {}
          try { lastKnownUrl = ''; initialOverlayUrl = ''; } catch (_) { /* no-op */ }
          initialLoadDone = false;
          loadCount = 0;
          navigatedAway = false;
          try { setLoadingMessage('Portal stabilizing…'); } catch (_) { /* no-op */ }
          try { searchInput && searchInput.classList.remove('is-proxied'); } catch (_) { /* no-op */ }
          try { reflectClearButton(); } catch (_) { /* no-op */ }
          try { reflectSubmitAffordance(); } catch (_) { /* no-op */ }
          // Clear any previous fallback timer
          try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
          // Suppress any page-level error dialog so its close (×) does not float above the iframe
          if (errorDialog) { errorDialog.style.display = 'none'; }
          // Compute proxied + signed URL for Morty (if configured), then load
          try
          {
            var forceNoMorty = options && options.forceNoMorty === true;
            var sourceUrl = options && options.sourceUrl ? String(options.sourceUrl) : '';
            var allowMorty = !forceNoMorty;
            var candidate = allowMorty ? mortyProxify(url || '') : (url || '');
            var loadFinal = function(finalUrl)
            {
              try { console.debug('[MusaiOverlay] load iframe', { finalUrl: finalUrl, hasHash: /[?&]hash=/.test(finalUrl || '') }); } catch (_) {}
              // Track the intended target for fallbacks
              try { currentTargetUrl = finalUrl || url || ''; } catch (_) { currentTargetUrl = finalUrl || ''; }
              try { frame.src = finalUrl || 'about:blank'; } catch (_) { frame.src = 'about:blank'; }
              try { lastKnownUrl = finalUrl || ''; initialOverlayUrl = lastKnownUrl; } catch (_) { /* no-op */ }
              try { showUrlInSearchInput(deMortyUrl(finalUrl || url || '')); } catch (_) { /* no-op */ }
              // Begin early, repeated attempts to inject Morty suppression until load event
              try
              {
                var earlyTries = 0;
                var earlyTimer = setInterval(function()
                {
                  earlyTries += 1;
                  try { hideMortyChromeEarly(frame); } catch (_) { /* no-op */ }
                  if (earlyTries > 20) { clearInterval(earlyTimer); }
                }, 100);
              }
              catch (_) { /* no-op */ }
              try
              {
                if (isMortyUrl(finalUrl || '')) { setLoadingMessage('Portal stabilizing…'); overlay && overlay.removeAttribute('data-direct'); }
                else { setLoadingMessage('Portal stabilizing…'); overlay && overlay.setAttribute('data-direct', 'true'); }
                reflectProxyState(finalUrl || '');
              }
              catch (_) { /* no-op */ }
              // If the iframe fails to load (common when a site forbids embedding),
              // open the URL in a new tab and close the overlay to avoid a blank screen
              try {
                if (fallbackTimer) { clearTimeout(fallbackTimer); }
                var targetForFallback = currentTargetUrl || url || finalUrl || '';
                // Do not set any fallback timer for Morty URLs; they must remain in-frame
                if (!isMortyUrl(targetForFallback))
                {
                  fallbackTimer = setTimeout(function()
                  {
                    try
                    {
                      if (overlay.getAttribute('aria-hidden') === 'false' && !initialLoadDone && loadCount === 0)
                      {
                        try { window.open(targetForFallback, '_blank', 'noopener'); } catch (_) {}
                        try { console.warn('[MusaiOverlay] iframe likely blocked; opened in new tab and closed overlay'); } catch (_) {}
                        try { closeOverlay(); } catch (_) {}
                      }
                    }
                    catch (_) { /* no-op */ }
                  }, 2500);
                }
              } catch (_) { /* no-op */ }
            };
            if (allowMorty && mortyPrefix && candidate)
            {
              // Optimistic load for faster perceived performance; upgrade to signed URL when ready
              loadFinal(candidate);
              try {
                signMortyUrl(candidate).then(function(signed)
                {
                  try
                  {
                    if (signed && typeof signed === 'string' && signed !== candidate)
                    {
                      try { frame.src = signed; } catch (_) { /* no-op */ }
                      try { showUrlInSearchInput(deMortyUrl(signed)); } catch (_) { /* no-op */ }
                      try { reflectProxyState(signed); } catch (_) { /* no-op */ }
                    }
                  }
                  catch (_) { /* no-op */ }
                }).catch(function(){ /* keep optimistic load */ });
              }
              catch (_) { /* keep optimistic load */ }
            }
            else
            {
              try { setLoadingMessage('Portal stabilizing…'); overlay && overlay.setAttribute('data-direct', 'true'); } catch (_) { /* no-op */ }
              loadFinal(candidate || url || '');
            }
          }
          catch (_) { /* no-op */ }
          // Ensure AI dock remains visible; content padding already accounts for it
        };
        var closeOverlay = function()
        {
          overlay.setAttribute('aria-hidden', 'true');
          try { overlay.removeAttribute('data-loading'); } catch (_) { /* no-op */ }
          try { overlay.removeAttribute('data-direct'); } catch (_) { /* no-op */ }
          try { rootHtml && rootHtml.classList.remove('musai-overlay-open'); } catch (_) { /* no-op */ }
          try { frame.src = 'about:blank'; } catch (_) {}
          // Clear any pending fallback since we're closing
          try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
          // Restore error dialog visibility when leaving overlay
          if (errorDialog) { errorDialog.style.display = ''; }
        };

        document.addEventListener('click', function(e)
        {
          var trigger = e.target.closest && e.target.closest('.musai-open-iframe');
          if (!trigger) { return; }
          e.preventDefault();
          try { e.stopPropagation(); } catch (_) { /* no-op */ }
          var url = '';
          try { url = (trigger.tagName === 'A') ? (trigger.getAttribute('href') || '') : (trigger.getAttribute('data-url') || ''); } catch (_) { url = trigger.getAttribute('data-url') || ''; }
          var sourceUrl = trigger.getAttribute('data-source-url') || '';
          var originId = trigger.getAttribute('data-origin-id') || '';
          if (url) { openOverlay(url, originId, { sourceUrl: sourceUrl }); }
        }, true);

        var performCloseReturn = function()
        {
          var originId = overlay.dataset.originId || '';
          closeOverlay();
          if (originId)
          {
            var el = document.getElementById(originId);
            if (el && el.scrollIntoView)
            {
              el.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        };
        btnCloseReturn && btnCloseReturn.addEventListener('click', performCloseReturn);

        // Clear button behavior for overlay search/address field
        try
        {
          if (searchInput)
          {
            searchInput.addEventListener('input', function()
            {
              try { reflectClearButton(); } catch (_) { /* no-op */ }
              try { reflectSubmitAffordance(); } catch (_) { /* no-op */ }
            });
          }
          if (searchClearBtn)
          {
            searchClearBtn.addEventListener('click', function()
            {
              try { searchInput.value = ''; } catch (_) {}
              try { searchInput.focus(); } catch (_) {}
              try { reflectClearButton(); } catch (_) {}
              try { reflectSubmitAffordance(); } catch (_) { /* no-op */ }
            });
            // Initialize visibility on first load
            try { reflectClearButton(); } catch (_) {}
            try { reflectSubmitAffordance(); } catch (_) { /* no-op */ }
          }
        }
        catch (_) { /* no-op */ }

        // Track iframe navigations: same-origin via contentWindow, cross-origin via src
        try {
          frame && frame.addEventListener('load', function()
          {
            // Loading succeeded (at least at the browser level); cancel fallback
            try { if (fallbackTimer) { clearTimeout(fallbackTimer); fallbackTimer = null; } } catch (_) { /* no-op */ }
            loadCount += 1;
            // Determine current iframe src
            var srcNow = (frame && frame.src) || '';
            var isBlank = !srcNow || srcNow === 'about:blank';
            // Hide loading veil only after the first non-blank load
            try
            {
              if (!initialLoadDone && !isBlank)
              {
                overlay.removeAttribute('data-loading');
              }
            }
            catch (_) { /* no-op */ }
            // If the loaded page is a Morty URL, attempt to hide Morty UI chrome inside the iframe
            try
            {
              if (isMortyUrl(srcNow))
              {
                try
                {
                  var doc = frame.contentDocument || (frame.contentWindow && frame.contentWindow.document) || null;
                  if (doc)
                  {
                    // Inject a minimal stylesheet to hide known Morty header/toolbars
                    var style = doc.createElement('style');
                    style.textContent = [
                      'header, .header, #header { display: none !important; }',
                      '.morty-header, .morty-topbar, .morty-toolbar, #mortyheader, #morty-header, #mortyHeader, .mortyheader { display: none !important; }',
                      '#topbar, .topbar, .toolbar { display: none !important; }',
                      // Common Morty/footer/banner selectors observed across deployments
                      'footer, .footer, #footer { display: none !important; }',
                      '.morty-footer, .morty-bottombar, #morty-bottombar, .morty-banner, .morty-notice, .morty-bottom { display: none !important; }',
                      '.fixed-bottom, .sticky-bottom { display: none !important; }',
                      'body { margin-top: 0 !important; margin-bottom: 0 !important; }'
                    ].join('\n');
                    doc.head && doc.head.appendChild(style);
                    // Also remove any element that contains the “Morty” label commonly shown by proxies
                    var maybeHeaders = doc.querySelectorAll('header, .header, #header, .morty-header, .morty-topbar, .morty-toolbar, #mortyheader, #morty-header, #mortyHeader, .mortyheader, #topbar, .topbar, .toolbar');
                    for (var i = 0; i < maybeHeaders.length; i++)
                    {
                      var el = maybeHeaders[i];
                      var txt = (el && (el.innerText || el.textContent) || '').toLowerCase();
                      if (txt.indexOf('morty') !== -1 || txt.indexOf('proxy') !== -1)
                      {
                        try { el.parentNode && el.parentNode.removeChild(el); } catch (_) { /* no-op */ }
                      }
                    }
                    // Remove bottom banners/footers that announce proxified views
                    var maybeFooters = doc.querySelectorAll('footer, .footer, #footer, .morty-footer, .morty-bottombar, #morty-bottombar, .morty-banner, .morty-notice, .morty-bottom, .bottom, #bottom, .fixed-bottom, .sticky-bottom');
                    for (var j = 0; j < maybeFooters.length; j++)
                    {
                      var el2 = maybeFooters[j];
                      var txt2 = (el2 && (el2.innerText || el2.textContent) || '').toLowerCase();
                      if (txt2.indexOf('morty') !== -1 || txt2.indexOf('proxy') !== -1 || txt2.indexOf('proxified') !== -1 || txt2.indexOf('original site') !== -1)
                      {
                        try { el2.parentNode && el2.parentNode.removeChild(el2); } catch (_) { /* no-op */ }
                      }
                    }
                  }
                }
                catch (_) { /* cross-origin or CSP; ignore */ }
              }
            }
            catch (_) { /* no-op */ }
            // Update last known URL when possible
            try { updateLastKnownUrl(); } catch (_) { /* no-op */ }
            try { showUrlInSearchInput(lastKnownUrl || (frame && frame.src) || ''); } catch (_) { /* no-op */ }
            try { reflectProxyState(lastKnownUrl || (frame && frame.src) || ''); } catch (_) { /* no-op */ }
            if (!initialLoadDone)
            {
              // Consider initial load complete only once a real (non-blank) URL has loaded
              if (!isBlank)
              {
                initialLoadDone = true;
                return;
              }
            }
            // Any subsequent load implies navigation away from the original page
            try
            {
              if (loadCount > 1)
              {
                // If we can compare URLs and they differ, mark navigated; otherwise assume navigated
                var current = lastKnownUrl || '';
                if (!current || !initialOverlayUrl || current !== initialOverlayUrl)
                {
                  navigatedAway = true;
                }
                else
                {
                  // Same URL after load (rare), keep current flag
                  navigatedAway = navigatedAway || true;
                }
              }
            }
            catch (_) { /* no-op */ }
          }, true);
        } catch (_) { /* no-op */ }

        // Accept cooperative URL updates from embedded pages
        try
        {
          window.addEventListener('message', function(ev)
          {
            try
            {
              if (!frame || !frame.contentWindow || ev.source !== frame.contentWindow) { return; }
              var data = ev.data;
              var candidate = '';
              if (typeof data === 'string')
              {
                candidate = data;
              }
              else if (data && typeof data === 'object')
              {
                if (typeof data.url === 'string') { candidate = data.url; }
                else if (typeof data.href === 'string') { candidate = data.href; }
                else if (data.location)
                {
                  if (typeof data.location === 'string') { candidate = data.location; }
                  else if (typeof data.location.href === 'string') { candidate = data.location.href; }
                }
                if (!candidate && (data.type === 'musai-location' || data.type === 'musai.overlay.location'))
                {
                  if (typeof data.value === 'string') { candidate = data.value; }
                }
              }
              if (candidate && typeof candidate === 'string')
              {
                try { candidate = new URL(candidate, lastKnownUrl || (frame && frame.src) || window.location.href).href; } catch (_) { /* no-op */ }
                lastKnownUrl = candidate;
                try { showUrlInSearchInput(candidate); } catch (_) { /* no-op */ }
                try { reflectProxyState(candidate); } catch (_) { /* no-op */ }
              }
            }
            catch (_) { /* no-op */ }
          }, false);
        }
        catch (_) { /* no-op */ }

        // Submit handler for overlay search: navigate main app to results
        if (searchForm && searchInput)
        {
          searchForm.addEventListener('submit', function(ev)
          {
            try
            {
              ev.preventDefault();
              ev.stopPropagation();
              var q = (searchInput.value || '').trim();
              if (!q) { return; }
              // Use affordance heuristics defined above
              var normalizeUrl = function(value)
              {
                if (!value) { return value; }
                if (hasScheme(value)) { return value; }
                if (/^www\./i.test(value)) { return 'https://' + value; }
                if (/^(?:localhost|\d{1,3}(?:\.\d{1,3}){3})(?::\d+)?(?:[\/?#].*)?$/i.test(value)) { return 'http://' + value; }
                return 'https://' + value;
              };
              // If AI is currently thinking, confirm before navigating away
              try
              {
                if (window.musaiAI && typeof window.musaiAI.isBusy === 'function' && window.musaiAI.isBusy())
                {
                  var ok = window.confirm('Musai is thinking. Starting a new search will cancel the response. Continue?');
                  if (!ok) { return; }
                }
              }
              catch (_) { /* no-op */ }
              // If input looks like a URL, navigate inside overlay directly without Morty
              if (looksLikeUrl(q))
              {
                var dest = normalizeUrl(q);
                try { openOverlay(dest, '', { forceNoMorty: true }); } catch (_) { /* no-op */ }
                return;
              }
              // Otherwise, close overlay and redirect to search results
              try { closeOverlay(); } catch (_) { /* no-op */ }
              try { if (window.musaiAI && typeof window.musaiAI.markInternalNav === 'function') { window.musaiAI.markInternalNav(); } } catch (_) { /* no-op */ }
              var base = searchForm.getAttribute('action') || "{{ url_for('search') }}";
              var url = base + '?q=' + encodeURIComponent(q);
              try { window.location.href = url; } catch (_) { /* no-op */ }
            }
            catch (_) { /* no-op */ }
          });
        }

        // Guard navigation via logo when AI busy: return & exit instead of leaving
        if (logoLink)
        {
          logoLink.addEventListener('click', function(e)
          {
            try
            {
              if (window.musaiAI && typeof window.musaiAI.isBusy === 'function' && window.musaiAI.isBusy())
              {
                e.preventDefault();
                e.stopPropagation();
                // Follow the same path as the Close & Return button
                try { performCloseReturn(); } catch (_) { /* no-op */ }
                return;
              }
            }
            catch (_) { /* no-op */ }
          });
        }

        // ESC closes overlay
        document.addEventListener('keydown', function(e)
        {
          if (overlay.getAttribute('aria-hidden') === 'false' && (e.key === 'Escape' || e.keyCode === 27))
          {
            e.preventDefault();
            performCloseReturn();
          }
        });

        // Expose current overlay URL for AI dock to send to backend
        window.musaiOverlayAPI = {
          isOpen: function()
          {
            return overlay.getAttribute('aria-hidden') === 'false';
          },
          currentUrl: function()
          {
            try { return (lastKnownUrl || (frame && frame.src) || '') ; }
            catch (_) { return ''; }
          },
          hasNavigatedAway: function()
          {
            try { return !!navigatedAway; } catch (_) { return false; }
          },
          state: function()
          {
            try
            {
              return {
                isOpen: overlay.getAttribute('aria-hidden') === 'false',
                initialUrl: initialOverlayUrl || '',
                lastKnownUrl: lastKnownUrl || '',
                loadCount: loadCount,
                navigatedAway: !!navigatedAway
              };
            }
            catch (_) { return { isOpen: false, initialUrl: '', lastKnownUrl: '', loadCount: 0, navigatedAway: false }; }
          },
          lastKnownUrl: function()
          {
            try { return lastKnownUrl || ''; }
            catch (_) { return ''; }
          },
          // Extract salient, symbol-trimmed text from the same-origin iframe document
          readableText: function(options)
          {
            try
            {
              var maxChars = (options && options.maxChars) || 2000;
              // Ensure same-origin access is permitted
              try { if (!frame || !frame.contentWindow) { return ''; } frame.contentWindow.location.href; } catch (_) { return ''; }
              var doc = null;
              try { doc = frame.contentDocument || (frame.contentWindow && frame.contentWindow.document) || null; } catch (__) { doc = null; }
              if (!doc || !doc.body) { return ''; }
              var raw = '';
              try { raw = (doc.body.innerText || doc.body.textContent || ''); } catch (___) { raw = ''; }
              if (!raw) { return ''; }
              // Normalize whitespace early to reduce cognitive load
              var normalized = raw.replace(/\s+/g, ' ').trim();
              // Strip non-informational symbols while preserving core punctuation
              try
              {
                // Construct regex at runtime to avoid parse-time errors in browsers without Unicode property escapes
                var unicodeStrip;
                try { unicodeStrip = new RegExp("[^\\p{L}\\p{N}\\s\\.,;:\\-\\(\\)\\!\\?\\'\\\"]", "gu"); }
                catch (_) { unicodeStrip = null; }
                if (unicodeStrip)
                {
                  normalized = normalized.replace(unicodeStrip, ' ');
                }
                else
                {
                  normalized = normalized.replace(/[^A-Za-z0-9\s\.,;:\-\(\)\!\?\'\"]/g, ' ');
                }
              }
              catch (_)
              {
                normalized = normalized.replace(/[^A-Za-z0-9\s\.,;:\-\(\)\!\?\'\"]/g, ' ');
              }
              normalized = normalized.replace(/\s{2,}/g, ' ').trim();
              if (maxChars > 0 && normalized.length > maxChars)
              {
                normalized = normalized.slice(0, Math.max(0, maxChars - 1)) + '…';
              }
              return normalized;
            }
            catch (_) { return ''; }
          },
          // Build a bracketed context block for AI consumption
          contextBlock: function(options)
          {
            try
            {
              var text = this.readableText(options || {});
              if (!text) { return ''; }
              var url = '';
              try { url = lastKnownUrl || (frame && frame.src) || ''; } catch (_) { url = ''; }
              return '[Current Context:\n' + text + '\nURL: ' + url + '\n]';
            }
            catch (_) { return ''; }
          },
          open: function(url, originId)
          {
            try { openOverlay(url, originId); } catch (_) {}
          },
          close: function()
          {
            try { performCloseReturn(); } catch (_) {}
          }
        };
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  {% endif %}
  <script type="module" src="{{ url_for('static', filename='js/searxng.core.min.js') }}" client_settings="{{ client_settings }}"></script>
  <script src="{{ url_for('static', filename='js/ai_chat.js') }}" defer></script>
  <script>
    (function ensureMortyLinksAreSigned()
    {
      try
      {
        var SIGN_WEBHOOK = 'https://n8n.codemusic.ca/webhook/sign-morty';
        var mortyPrefix = ("{{ (get_setting('server.result_proxy.url') or '')|e }}" || '').trim();
        var mortyPrefixPath = (function()
        {
          try
          {
            return (new URL(mortyPrefix, window.location.href).pathname) || mortyPrefix;
          }
          catch (_)
          {
            return mortyPrefix;
          }
        })();
        try { console.debug('[MortySign] config', { mortyPrefix: mortyPrefix, mortyPrefixPath: mortyPrefixPath }); } catch (_) {}

        var hasMortyHash = function(url)
        {
          try
          {
            return /[?&](?:mortyhash|hash)=/.test(url);
          }
          catch (_) { return false; }
        };

        var isMortyUrl = function(url)
        {
          try
          {
            if (!mortyPrefix) { return false; }
            var s = url || '';
            if (!s) { return false; }
            // Accept absolute and relative URLs
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0)
            {
              var u = new URL(s, window.location.href);
              var href = u.href || '';
              var path = u.pathname || '';
              return (href.indexOf(mortyPrefix) === 0) || (path.indexOf(mortyPrefixPath) === 0);
            }
            return (s.indexOf(mortyPrefix) === 0) || (s.indexOf(mortyPrefixPath) === 0);
          }
          catch (_) { return false; }
        };

        var stableUrlString = function(input)
        {
          try
          {
            var u = new URL(input, window.location.href);
            return u.href;
          }
          catch (_)
          {
            return input || '';
          }
        };
        var deMortyUrl = function(url)
        {
          try
          {
            var s = url || '';
            if (!s || !isMortyUrl(s)) { return s; }
            var u = new URL(s, window.location.href);
            // Prefer query-param style first (e.g., /morty/?mortyurl=...)
            try
            {
              var mu = (u.searchParams && u.searchParams.get) ? (u.searchParams.get('mortyurl') || '') : '';
              if (mu) { return mu; }
            }
            catch (_) { /* no-op */ }
            // Fallback: path-style /morty/https/...
            var path = u.pathname || '';
            var base = mortyPrefixPath || '/morty/';
            var i = path.indexOf(base);
            var suffix = (i >= 0) ? path.slice(i + base.length) : path;
            if (suffix.indexOf('https/') === 0) { return 'https://' + suffix.slice(6); }
            if (suffix.indexOf('http/') === 0) { return 'http://' + suffix.slice(5); }
            return s;
          }
          catch (_) { return url; }
        };

        // shouldUseMortyForUrl removed; eligibility is now decided during signing

        var signUrl = function(url)
        {
          return new Promise(function(resolve)
          {
            var candidate = stableUrlString(url);
            try { console.debug('[MortySign] signUrl start', { candidate: candidate }); } catch (_) {}
            if (!candidate)
            {
              resolve(candidate);
              return;
            }
            var plainTarget = isMortyUrl(candidate) ? deMortyUrl(candidate) : candidate;
            var buildMorty = function(target, hash)
            {
              try
              {
                var sep = (mortyPrefix.indexOf('?') === -1) ? '?' : '&';
                var built = mortyPrefix + sep + 'mortyurl=' + encodeURIComponent(target);
                if (hash) { built += '&mortyhash=' + String(hash).toLowerCase(); }
                return built;
              }
              catch (_) { return candidate; }
            };
            // If already Morty with hash, keep as-is
            if (isMortyUrl(candidate) && hasMortyHash(candidate))
            {
              resolve(candidate);
              return;
            }

            var didResolve = false;
            var settle = function(value)
            {
              if (didResolve) { return; }
              didResolve = true;
              resolve(value || buildMorty(plainTarget));
            };

            // Helper function to handle connection errors and retry with proper headers
            var attemptSigning = function(usePost, attemptNumber)
            {
              if (attemptNumber > 3) {
                console.warn('[MortySign] Max retry attempts reached for', plainTarget);
                settle(buildMorty(plainTarget));
                return;
              }

              var headers = Object.assign(
                { 'Content-Type': 'application/json' },
                (window.musaiN8N && typeof window.musaiN8N.getAuthHeader === 'function')
                  ? window.musaiN8N.getAuthHeader()
                  : { 'Authorization': 'Basic c2l0ZXVzZXI6Y29kZW11c2Fp' }
              );

              // For connection issues, add Connection: close header on retry attempts
              if (attemptNumber > 1) {
                headers['Connection'] = 'close';
                console.debug('[MortySign] Adding Connection: close header for attempt', attemptNumber);
              }

              var fetchPromise;
              if (usePost) {
                fetchPromise = fetch(SIGN_WEBHOOK, {
                  method: 'POST',
                  headers: headers,
                  body: JSON.stringify({ url: plainTarget })
                });
              } else {
                var urlParam = encodeURIComponent(plainTarget);
                fetchPromise = fetch(SIGN_WEBHOOK + '?url=' + urlParam, {
                  method: 'GET',
                  headers: headers
                });
              }

              fetchPromise.then(function(r)
              {
                if (!r.ok) { throw new Error('HTTP ' + r.status); }
                return r.json().catch(function()
                {
                  return { url: plainTarget };
                });
              }).then(function(data)
              {
                var nextUrl = (data && data.signed_url) || '';
                var mh = (data && (data.mortyhash || data.hash)) || '';
                if (!nextUrl)
                {
                  nextUrl = buildMorty(plainTarget, mh);
                }
                try {
                  console.debug('[MortySign] signing success on attempt', attemptNumber, { target: plainTarget, hasMortyhash: /[?&]mortyhash=/.test(nextUrl) });
                } catch (_) {}
                settle(nextUrl || buildMorty(plainTarget, mh));
              }).catch(function(error)
              {
                var errorMsg = error.message || '';
                var isConnectionError = errorMsg.includes('connection') ||
                                       errorMsg.includes('ECONNRESET') ||
                                       errorMsg.includes('closed') ||
                                       errorMsg.includes('before returning the first response byte');

                console.debug('[MortySign] attempt', attemptNumber, 'failed:', errorMsg, { isConnectionError: isConnectionError });

                if (isConnectionError) {
                  // Retry with different approach for connection errors
                  if (usePost) {
                    // First retry: switch to GET method
                    setTimeout(function() {
                      attemptSigning(false, attemptNumber + 1);
                    }, 1000 * attemptNumber); // Exponential backoff
                  } else {
                    // Second retry: try POST again with Connection: close
                    setTimeout(function() {
                      attemptSigning(true, attemptNumber + 1);
                    }, 1000 * attemptNumber);
                  }
                } else if (usePost) {
                  // For non-connection errors, try GET fallback
                  setTimeout(function() {
                    attemptSigning(false, attemptNumber + 1);
                  }, 500);
                } else {
                  // Final fallback: build unsigned URL
                  console.warn('[MortySign] All signing attempts failed for', plainTarget, errorMsg);
                  settle(buildMorty(plainTarget));
                }
              });
            };

            // Start with POST attempt
            attemptSigning(true, 1);
          });
        };

        var upgradeAnchor = function(a)
        {
          try
          {
            if (!a || a.dataset.mortySigned === '1') { return; }
            var href = a.getAttribute('href') || '';
            if (!isMortyUrl(href) || hasMortyHash(href))
            {
              a.dataset.mortySigned = '1';
              return;
            }
            signUrl(href).then(function(signed)
            {
              try
              {
                if (signed && typeof signed === 'string')
                {
                  var finalHref = signed;
                  // If Morty key is set, finalHref should contain mortyhash; if not, keep mortyurl-only (key unset)
                  a.setAttribute('href', finalHref);
                }
              }
              catch (_) {}
              a.dataset.mortySigned = '1';
            });
          }
          catch (_) { /* no-op */ }
        };

        var upgradeButton = function(btn)
        {
          try
          {
            if (!btn || btn.dataset.mortySigned === '1') { return; }
            var url = btn.getAttribute('data-url') || '';
            var needsSigning = isMortyUrl(url) && !hasMortyHash(url);
            if (!isMortyUrl(url) || hasMortyHash(url))
            {
              btn.dataset.mortySigned = '1';
              try { btn.removeAttribute('disabled'); } catch (_) {}
              return;
            }
            // Never disable the button; allow user to click even while signing
            try { console.debug('[MortySign] upgradeButton before', { url: url }); } catch (_) {}
            signUrl(url).then(function(signed)
            {
              try
              {
                if (signed && typeof signed === 'string')
                {
                  var finalUrl = signed;
                  btn.setAttribute('data-url', finalUrl);
                }
              }
              catch (_) {}
              btn.dataset.mortySigned = '1';
              try { btn.removeAttribute('disabled'); } catch (_) {}
              try { console.debug('[MortySign] upgradeButton after', { signed: signed, hasMortyhash: /[?&]mortyhash=/.test(signed || '') }); } catch (_) {}
            });
          }
          catch (_) { /* no-op */ }
        };

        var upgradeAll = function(root)
        {
          try
          {
            var scope = root || document;
            // Process all anchors so media links proxied by server can be unwrapped
            var anchors = scope.querySelectorAll('a[href]');
            for (var i = 0; i < anchors.length; i++) { upgradeAnchor(anchors[i]); }
            var buttons = scope.querySelectorAll('button.musai-open-iframe');
            for (var j = 0; j < buttons.length; j++) { upgradeButton(buttons[j]); }
          }
          catch (_) { /* no-op */ }
        };

        if (mortyPrefix)
        {
          if (document.readyState === 'loading')
          {
            document.addEventListener('DOMContentLoaded', function()
            {
              try { upgradeAll(document); } catch (_) { /* no-op */ }
            });
          }
          else
          {
            upgradeAll(document);
          }

          // Observe dynamically inserted results (infinite scroll, etc.)
          try
          {
            var obs = new MutationObserver(function(muts)
            {
              for (var k = 0; k < muts.length; k++)
              {
                var m = muts[k];
                if (m && m.addedNodes && m.addedNodes.length)
                {
                  for (var n = 0; n < m.addedNodes.length; n++)
                  {
                    var node = m.addedNodes[n];
                    if (node && node.nodeType === 1)
                    {
                      upgradeAll(node);
                    }
                  }
                }
              }
            });
            obs.observe(document.documentElement, { childList: true, subtree: true });
          }
          catch (_) { /* no-op */ }
        }
      }
      catch (e) { /* no-op */ }
    })();
  </script>
  
</body>
</html>
