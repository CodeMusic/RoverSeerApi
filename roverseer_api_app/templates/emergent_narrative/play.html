<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>{{ narrative.title }} - Play</title>
    <link rel="stylesheet" href="/static/assets/personality-sliders.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial; 
            background: #1a1a1a; 
            color: #ffffff; 
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background 0.5s ease;
        }
        
        body.narrative-background {
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        
        body.narrative-background::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 26, 0.85);
            backdrop-filter: blur(3px);
            z-index: -1;
        }
        
        .header { 
            background: #1c1c1e; 
            color: white; 
            padding: 15px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        .narrative-header-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .narrative-thumbnail {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            object-fit: cover;
            background: #333;
            border: 1px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 1.2rem;
        }
        
        .narrative-title {
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .play-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .narrative-theater {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 700px;
        }
        
        .visual-hierarchy {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        .image-gallery {
            display: flex;
            align-items: center;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 0;
        }
        
        .hierarchy-image {
            position: relative;
            flex-shrink: 0;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .hierarchy-image:hover {
            transform: translateY(-2px);
        }
        
        .hierarchy-image img {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            object-fit: cover;
            border: 2px solid #444;
            transition: border-color 0.3s ease;
        }
        
        .hierarchy-image:hover img {
            border-color: #667eea;
        }
        
        .character-initial {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: #444;
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
        }
        
        .image-label {
            font-size: 0.7rem;
            color: #bbb;
            margin-top: 4px;
            font-weight: 500;
        }
        
        .narrative-image img {
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
        }
        
        .group-image img {
            border-color: #4caf50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3);
        }
        
        .character-thumbnails {
            display: flex;
            gap: 8px;
        }
        
        .control-panel {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            height: fit-content;
        }
        
        .narrative-status {
            background: #333;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .status-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-dormant { background: #555; color: #ddd; }
        .status-manifesting { background: #4caf50; color: white; }
        .status-paused { background: #ff9800; color: white; }
        .status-completed { background: #2196f3; color: white; }
        
        .interactions-display {
            flex: 1;
            background: #222;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            max-height: 500px;
            margin-bottom: 20px;
        }
        
        .interaction-message {
            margin-bottom: 15px;
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }
        
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            font-size: 1rem;
            line-height: 1.4;
        }
        
        .character-a .message-bubble {
            background: linear-gradient(135deg, #007AFF, #0051D8);
            color: white;
            border-bottom-left-radius: 4px;
            margin-left: auto;
            text-align: right;
        }
        
        .character-b .message-bubble {
            background: #2C2C2E;
            color: #FFFFFF;
            border: 1px solid #3A3A3C;
            border-bottom-right-radius: 4px;
            text-align: left;
        }
        
        .character-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .character-a {
            flex-direction: row-reverse;
        }
        
        .character-a .character-avatar {
            background: linear-gradient(135deg, #007AFF, #0051D8);
            color: white;
        }
        
        .character-b .character-avatar {
            background: #48484A;
            color: white;
        }
        
        .typing-indicator {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            margin-bottom: 15px;
            animation: messageSlideIn 0.4s ease-out;
        }
        
        .typing-bubble {
            background: #2C2C2E;
            border: 1px solid #3A3A3C;
            border-radius: 18px;
            border-bottom-right-radius: 4px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #8E8E93;
            animation: typingPulse 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingPulse {
            0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
            30% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes messageSlideIn {
            from { opacity: 0; transform: translateY(10px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
        }
        
        .scene-countdown {
            font-size: 0.9rem;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .countdown-critical {
            background: linear-gradient(135deg, #dc3545, #c82333) !important;
            animation: pulse 0.8s infinite !important;
        }
        
        .countdown-urgent {
            background: linear-gradient(135deg, #fd7e14, #e55700) !important;
            animation: pulse 1s infinite !important;
        }
        
        .countdown-warning {
            background: linear-gradient(135deg, #ffc107, #e0a800) !important;
            animation: pulse 1.2s infinite !important;
        }
        
        .message-timestamp {
            font-size: 0.7rem;
            color: #8E8E93;
            margin-top: 4px;
            text-align: center;
            opacity: 0.8;
        }
        
        .controls-section {
            margin-bottom: 20px;
        }
        
        .controls-grid {
            display: grid;
            gap: 10px;
            margin-bottom: 15px;
            grid-template-columns: 1fr 1fr;
        }
        
        .controls-grid .control-button {
            width: 100%;
        }
        
        .controls-grid .control-button:last-child {
            grid-column: 1 / -1;
        }
        
        .control-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .control-button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-button.pause {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }
        
        .control-button.advance {
            background: linear-gradient(135deg, #4caf50, #388e3c);
        }
        
        .output-mode-selector {
            margin-bottom: 15px;
        }
        
        .form-select {
            width: 100%;
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            color: #ffffff;
            font-size: 0.9rem;
        }
        
        .panel-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .influence-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .form-input {
            width: 100%;
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            color: #ffffff;
            font-size: 0.9rem;
        }
        
        .influence-duration {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .duration-input {
            width: 60px;
        }
        
        .active-influences {
            margin-top: 15px;
        }
        
        .influence-item {
            background: #444;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .influence-word {
            font-weight: 600;
            color: #ff9800;
        }
        
        .empty-theater {
            text-align: center;
            color: #888;
            font-style: italic;
            margin-top: 50px;
        }
        
        .narrator-announcement {
            margin-bottom: 20px;
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .narrator-bubble {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
            padding: 16px 20px;
            border-radius: 20px;
            max-width: 80%;
            text-align: center;
            position: relative;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-style: italic;
            font-weight: 500;
        }
        
        .narrator-bubble::before {
            content: '📢';
            position: absolute;
            top: -8px;
            left: -8px;
            background: #ff9800;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            border: 2px solid white;
        }
        
        .narrator-label {
            font-size: 0.8rem;
            color: #ff9800;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .loading-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .character-item {
            background: #333;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
        }
        
        .character-display-name {
            font-weight: 600;
        }
        
        .character-model {
            font-size: 0.8rem;
            color: #888;
        }
        
        @media (max-width: 768px) {
            .play-container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .control-panel {
                order: -1;
            }
            
            .visual-hierarchy {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .image-gallery {
                gap: 8px;
                padding: 5px 0;
            }
            
            .hierarchy-image img,
            .character-initial {
                width: 50px;
                height: 50px;
            }
            
            .image-label {
                font-size: 0.6rem;
            }
            
            .character-thumbnails {
                gap: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/emergent_narrative">← Back to Narratives</a>
        <div class="narrative-header-content">
            <div class="narrative-thumbnail">
                {% if narrative.image_path %}
                    <img src="{{ narrative.image_path }}" alt="{{ narrative.title }}" style="width: 100%; height: 100%; border-radius: 8px; object-fit: cover;">
                {% else %}
                    {{ narrative.title[:1] }}
                {% endif %}
            </div>
            <div class="narrative-title">{{ narrative.title }}</div>
        </div>
    </div>

    <div class="play-container">
        <div class="narrative-theater">
            <!-- Visual Hierarchy Section -->
            <div class="visual-hierarchy" id="visualHierarchy">
                <div class="image-gallery">
                    <!-- Narrative Image -->
                    {% if narrative.image_path %}
                    <div class="hierarchy-image narrative-image">
                        <img src="{{ narrative.image_path }}" alt="{{ narrative.title }}">
                        <div class="image-label">Story</div>
                    </div>
                    {% endif %}
                    
                    <!-- Group Image (populated dynamically if characters belong to groups) -->
                    <div class="hierarchy-image group-image" id="groupImage" style="display: none;">
                        <img src="" alt="Character Group">
                        <div class="image-label">Group</div>
                    </div>
                    
                    <!-- Character Thumbnails -->
                    <div class="character-thumbnails" id="characterThumbnails">
                        {% for character in narrative.characters %}
                        <div class="hierarchy-image character-image" data-character-id="{{ character.id }}">
                            {% if character.image_path %}
                                <img src="{{ character.image_path }}" alt="{{ character.name }}">
                            {% else %}
                                <div class="character-initial">{{ character.name[:1] }}</div>
                            {% endif %}
                            <div class="image-label">{{ character.name }}</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            
            <div class="narrative-status">
                <div class="status-header">
                    <h3>Narrative Status</h3>
                    <span class="status-badge status-{{ narrative.state }}" id="statusBadge">
                        {{ narrative.state.upper() }}
                    </span>
                </div>
                
                <div id="actInfo">
                    <strong>Current Act:</strong> Loading...
                </div>
                
                <div id="sceneInfo" style="margin-top: 10px;">
                    <strong>Current Scene:</strong> Loading...
                </div>
            </div>
            
            <div class="interactions-display" id="interactionsDisplay">
                <div class="empty-theater">
                    Narrative interactions will appear here when the story begins...
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="controls-section">
                <div class="panel-header">🎮 Narrative Controls</div>
                
                <div class="output-mode-selector">
                    <label style="display: block; margin-bottom: 5px;">Output Mode:</label>
                    <select class="form-select" id="outputMode">
                        <option value="text">📝 Text Only</option>
                        <option value="rover_audio">🔊 RoverSeer Speakers</option>
                        <option value="local_audio">🎵 Download Audio</option>
                    </select>
                </div>
                
                <div class="output-mode-selector">
                    <label style="display: block; margin-bottom: 5px;">Story Flow:</label>
                    <select class="form-select" id="autoAdvanceMode">
                        <option value="auto">🔄 Auto-flowing (like real conversation)</option>
                        <option value="manual">👆 Manual (click Next each time)</option>
                    </select>
                </div>
                
                <div id="statusHelp" style="background: #444; border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.8rem; color: #ccc;">
                    <div id="statusHelpText">Loading status...</div>
                    <button onclick="toggleDebug()" style="margin-top: 8px; background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">🔧 Debug</button>
                </div>
                
                <div id="debugPanel" style="background: #333; border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.7rem; color: #888; display: none;">
                    <div style="font-weight: bold; margin-bottom: 5px;">🔧 Debug Info:</div>
                    <div id="debugText" style="max-height: 200px; overflow-y: auto; background: #222; padding: 8px; border-radius: 4px; margin-bottom: 8px; white-space: pre-wrap; font-family: monospace;">No debug info yet...</div>
                    <div style="margin-top: 8px;">
                        <button onclick="runHealthCheck()" style="background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; margin-right: 5px;">🏥 Health Check</button>
                        <button onclick="repairNarrativeCharacters()" style="background: #d32f2f; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; margin-right: 5px;">🔧 Fix Characters</button>
                        <button onclick="document.getElementById('debugText').innerHTML = 'Debug cleared...'" style="background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">🗑️ Clear</button>
                    </div>
                </div>
                
                <div class="controls-grid">
                    <button class="control-button" id="startButton" onclick="startNarrative()">
                        ▶️ Start Narrative
                    </button>
                    <button class="control-button pause" id="pauseButton" onclick="pauseNarrative()">
                        ⏸️ Pause
                    </button>
                    <button class="control-button advance" id="advanceButton" onclick="advanceNarrative()">
                        ⏭️ Next Interaction
                    </button>
                    <button class="control-button" id="resetButton" onclick="resetNarrative()" style="background: linear-gradient(135deg, #f44336, #d32f2f); display: none;">
                        🔄 Reset to Start
                    </button>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">📢 Narrator Announcement</div>
                
                <div class="narrator-status" id="narratorStatus">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.9rem;">
                        <span>Announcements Used:</span>
                        <span id="narratorCount" style="font-weight: 600;">0/3</span>
                    </div>
                    <div style="background: #333; border-radius: 8px; height: 6px; overflow: hidden; margin-bottom: 15px;">
                        <div id="narratorProgress" style="background: linear-gradient(90deg, #4caf50, #8bc34a); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                
                <div class="narrator-form" id="narratorForm" style="display: none;">
                    <textarea class="form-input" 
                              id="narratorText" 
                              placeholder="Speak as the narrator..."
                              rows="3"
                              maxlength="300"></textarea>
                    
                    <div style="display: flex; gap: 8px; margin-top: 10px;">
                        <button class="control-button" id="narratorAnnounceButton" onclick="makeNarratorAnnouncement()" style="flex: 1;">
                            📢 Announce
                        </button>
                        <button class="control-button secondary" onclick="hideNarratorForm()" style="background: #555;">
                            Cancel
                        </button>
                    </div>
                </div>
                
                <button class="control-button" id="showNarratorButton" onclick="showNarratorForm()" style="display: block;">
                    📢 Add Narrator Voice
                </button>
                
                <div id="narratorLimitMessage" style="display: none; color: #ff9800; font-size: 0.85rem; text-align: center; margin-top: 10px; font-style: italic;">
                    Narrator limit reached. Use influences instead.
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🌟 Consciousness Influence</div>
                
                <div class="influence-form">
                    <input type="text" 
                           class="form-input" 
                           id="influenceWord" 
                           placeholder="Word of influence..."
                           maxlength="50">
                    
                    <select class="form-select" id="influenceTarget">
                        <option value="">All Characters</option>
                        {% for character in narrative.characters %}
                        <option value="{{ character.id }}">{{ character.name }}</option>
                        {% endfor %}
                    </select>
                    
                    <div class="influence-duration">
                        <span>Duration:</span>
                        <input type="number" 
                               class="form-input duration-input" 
                               id="influenceDuration" 
                               value="3" 
                               min="1" 
                               max="10">
                        <span>cycles</span>
                    </div>
                    
                    <button class="control-button" onclick="applyInfluence()">
                        Apply Influence
                    </button>
                </div>
                
                <div class="active-influences" id="activeInfluences">
                    <div style="color: #888; font-style: italic;">No active influences</div>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🎨 Character Colors</div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    {% for character in narrative.characters %}
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="color" 
                               id="color-{{ loop.index0 }}" 
                               data-character-index="{{ loop.index0 }}"
                               value="{% if loop.index0 == 0 %}#007AFF{% else %}#48484A{% endif %}"
                               style="width: 40px; height: 40px; border: none; border-radius: 8px; cursor: pointer;"
                               class="character-color-picker">
                        <div>
                            <div style="font-weight: 600;">{{ character.name }}</div>
                            <div style="font-size: 0.8rem; color: #888;">{{ character.model }}</div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🧠 Runtime Personality Editor</div>
                
                <div id="personalityEditor">
                    <!-- Personality editor will be dynamically rendered here -->
                </div>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                    <button type="button" onclick="showSyncPersonalityModal()" 
                            style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; width: 100%;">
                        🔄 Sync Traits from Character Library
                    </button>
                    <div style="font-size: 0.8rem; color: #888; margin-top: 5px; text-align: center;">
                        Load latest personality traits from character definitions
                    </div>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🎭 Characters Info</div>
                
                <div class="characters-list">
                    {% for character in narrative.characters %}
                    <div class="character-item">
                        <div class="character-display-name">{{ character.name }}</div>
                        <div class="character-model">{{ character.model }} ({{ character.voice }})</div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>

    <!-- Narrative data from server -->
    <script type="application/json" id="narrative-data">
        {{ narrative | tojson | safe }}
    </script>

    <script>
        const narrativeData = JSON.parse(document.getElementById('narrative-data').textContent);
        const narrativeId = narrativeData.id;
        let statusUpdateInterval;
        let isProcessing = false;
        let debugMode = false;
        let autoAdvanceTimer = null;
        let currentSceneInfo = null; // Store current scene character assignments
        let characterColorMap = new Map(); // Map character names to their assigned colors
        
        // ROYGBIV color palette for multiple characters
        const CHARACTER_COLORS = [
            '#FF3B30', // Red
            '#FF9500', // Orange
            '#FFD60A', // Yellow
            '#34C759', // Green
            '#007AFF', // Blue
            '#5856D6', // Indigo
            '#AF52DE', // Violet
            // Extended ROYGBIV variations for more characters
            '#FF6B6B', // Light Red
            '#FF8E53', // Light Orange
            '#FFF066', // Light Yellow
            '#51CF66', // Light Green
            '#339AF0'  // Light Blue
        ];
        let lastAudioUrl = null; // Store the last audio URL for replay
        let messageAudioMap = new Map(); // Map message elements to their audio URLs
        let personalityEditor = null; // Runtime personality editor instance
        let currentPersonalityAdjustments = {}; // Store temporary personality adjustments
        
        function toggleDebug() {
            debugMode = !debugMode;
            const debugPanel = document.getElementById('debugPanel');
            debugPanel.style.display = debugMode ? 'block' : 'none';
            if (debugMode) {
                updateDebugInfo('Debug mode enabled');
                setTimeout(() => runHealthCheck(), 100); // Run health check after a brief delay
            }
        }
        
        function updateDebugInfo(message) {
            if (!debugMode) return;
            const debugText = document.getElementById('debugText');
            const timestamp = new Date().toLocaleTimeString();
            
            // If this is the first message, clear the placeholder
            if (debugText.innerHTML === 'No debug info yet...') {
                debugText.innerHTML = '';
            }
            
            debugText.innerHTML += `[${timestamp}] ${message}\n`;
            debugText.scrollTop = debugText.scrollHeight;
        }
        
        function startStatusUpdates() {
            statusUpdateInterval = setInterval(updateNarrativeStatus, 2000);
        }
        
        async function updateNarrativeStatus() {
            try {
                updateDebugInfo(`Updating status for narrative ${narrativeId}`);
                const response = await fetch(`/emergent_narrative/status/${narrativeId}`);
                updateDebugInfo(`Status response: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const status = await response.json();
                updateDebugInfo(`Status data: ${JSON.stringify(status, null, 2)}`);
                
                // Extra debug for scene progress
                if (status.current_scene_info) {
                    updateDebugInfo(`SCENE PROGRESS DEBUG: ${status.current_scene_info.total_interactions}/${status.current_scene_info.required_interactions} interactions = ${status.current_scene_info.progress_text}`);
                }
                
                // Update status badge
                const badge = document.getElementById('statusBadge');
                badge.textContent = status.state.toUpperCase();
                badge.className = `status-badge status-${status.state}`;
                
                // Update act info
                const actInfo = document.getElementById('actInfo');
                if (status.current_act_info) {
                    actInfo.innerHTML = `
                        <strong>Act ${status.current_act_info.number}:</strong> 
                        ${status.current_act_info.theme}
                        <br><small>(${status.current_act + 1}/${status.total_acts})</small>
                    `;
                } else {
                    actInfo.innerHTML = '<strong>Current Act:</strong> Not started';
                }
                
                // Update scene info and store for character assignment
                const sceneInfo = document.getElementById('sceneInfo');
                if (status.current_scene_info) {
                    currentSceneInfo = status.current_scene_info; // Store for character styling
                    
                    let sceneContent = `
                        <strong>Scene ${status.current_scene_info.number}:</strong> 
                        ${status.current_scene_info.description}
                        <br><small>
                            ${status.current_scene_info.characters.join(' & ')} 
                            (${status.current_scene_info.progress_text} cycles complete)
                            <br>${status.current_scene_info.character_interactions || status.current_scene_info.total_interactions}/${status.current_scene_info.required_interactions} character exchanges
                        </small>
                    `;
                    
                    // Add countdown display if active
                    if (status.current_scene_info.countdown && status.current_scene_info.countdown.active) {
                        const countdown = status.current_scene_info.countdown;
                        let countdownClass = '';
                        let countdownIcon = '';
                        
                        if (countdown.remaining === 1) {
                            countdownClass = 'countdown-critical';
                            countdownIcon = '🔥';
                        } else if (countdown.remaining === 2) {
                            countdownClass = 'countdown-urgent';
                            countdownIcon = '⚡';
                        } else if (countdown.remaining === 3) {
                            countdownClass = 'countdown-warning';
                            countdownIcon = '⏰';
                        }
                        
                        sceneContent += `
                            <div class="scene-countdown ${countdownClass}" style="
                                background: linear-gradient(135deg, #ff6b35, #f7931e);
                                color: white;
                                padding: 8px 12px;
                                border-radius: 8px;
                                margin-top: 8px;
                                font-weight: 600;
                                text-align: center;
                                animation: pulse 1s infinite;
                            ">
                                ${countdownIcon} ${countdown.remaining} exchanges until scene completion!
                            </div>
                        `;
                    }
                    
                    sceneInfo.innerHTML = sceneContent;
                    
                    // Log character assignments for debugging
                    updateDebugInfo(`Scene ${status.current_scene_info.number} characters: ${status.current_scene_info.characters.join(' & ')}`);
                    
                    // Update character colors for the current scene
                    updateCharacterColorsForScene();
                } else {
                    currentSceneInfo = null;
                    sceneInfo.innerHTML = '<strong>Current Scene:</strong> Not started';
                }
                
                // Update control buttons
                updateControlButtons(status.state);
                
                // Update active influences
                updateActiveInfluences(status.active_influences);
                
                // Update narrator status
                updateNarratorStatus(status.narrator_status);
                
            } catch (error) {
                console.error('Failed to update status:', error);
                updateDebugInfo(`ERROR updating status: ${error.message}`);
                
                // Show error in status help
                const statusHelpText = document.getElementById('statusHelpText');
                statusHelpText.innerHTML = `❌ <strong>Connection Error</strong><br>Unable to get narrative status: ${error.message}`;
            }
        }
        
        function updateControlButtons(state) {
            const startButton = document.getElementById('startButton');
            const pauseButton = document.getElementById('pauseButton');
            const advanceButton = document.getElementById('advanceButton');
            const resetButton = document.getElementById('resetButton');
            const statusHelpText = document.getElementById('statusHelpText');
            const autoMode = document.getElementById('autoAdvanceMode').value;
            
            console.log('Updating buttons for state:', state);
            
            if (state === 'dormant') {
                startButton.disabled = false;
                startButton.textContent = '▶️ Start Narrative';
                pauseButton.disabled = true;
                advanceButton.disabled = true;
                resetButton.style.display = 'none';
                statusHelpText.innerHTML = '✨ <strong>Ready to Start</strong><br>Click "Start Narrative" to begin the story.';
            } else if (state === 'manifesting') {
                startButton.disabled = true;
                startButton.textContent = '▶️ Running...';
                pauseButton.disabled = false;
                advanceButton.disabled = isProcessing;
                resetButton.style.display = 'inline-block';
                
                if (autoMode === 'auto') {
                    statusHelpText.innerHTML = '🎭 <strong>Story Flowing</strong><br>Auto-advancing every 2-4 seconds. Use "Pause" to stop, "Next" to skip ahead, or "Reset" to start over.';
                } else {
                    statusHelpText.innerHTML = '🎭 <strong>Story in Progress</strong><br>Click "Next Interaction" to advance, "Pause" to stop, or "Reset" to start over.';
                }
            } else if (state === 'paused') {
                startButton.disabled = false;
                startButton.textContent = '▶️ Resume';
                pauseButton.disabled = true;
                advanceButton.disabled = isProcessing;
                resetButton.style.display = 'inline-block';
                statusHelpText.innerHTML = '⏸️ <strong>Story Paused</strong><br>Click "Resume" to continue, "Next Interaction" to advance manually, or "Reset" to start over.';
            } else if (state === 'completed') {
                startButton.disabled = true;
                startButton.textContent = '✅ Complete';
                pauseButton.disabled = true;
                advanceButton.disabled = true;
                resetButton.style.display = 'inline-block';
                statusHelpText.innerHTML = '🎉 <strong>Story Complete</strong><br>This narrative has finished. Click "Reset" to experience it again from the beginning.';
            }
        }
        
        function updateActiveInfluences(influences) {
            const container = document.getElementById('activeInfluences');
            
            if (influences.length === 0) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">No active influences</div>';
                return;
            }
            
            container.innerHTML = influences.map(inf => `
                <div class="influence-item">
                    <div class="influence-word">"${inf.word}"</div>
                    <div style="font-size: 0.8rem; color: #aaa;">
                        Target: ${inf.target || 'All Characters'}
                    </div>
                    <div style="font-size: 0.8rem; color: #4caf50;">
                        ${inf.remaining_cycles} cycles remaining
                    </div>
                </div>
            `).join('');
        }
        
        function updateNarratorStatus(narratorStatus) {
            if (!narratorStatus) return;
            
            const countElement = document.getElementById('narratorCount');
            const progressElement = document.getElementById('narratorProgress');
            const showButton = document.getElementById('showNarratorButton');
            const limitMessage = document.getElementById('narratorLimitMessage');
            
            // Update count display
            countElement.textContent = `${narratorStatus.used}/${narratorStatus.max}`;
            
            // Update progress bar
            const percentage = (narratorStatus.used / narratorStatus.max) * 100;
            progressElement.style.width = `${percentage}%`;
            
            // Change progress bar color based on usage
            if (percentage >= 100) {
                progressElement.style.background = 'linear-gradient(90deg, #f44336, #d32f2f)';
            } else if (percentage >= 66) {
                progressElement.style.background = 'linear-gradient(90deg, #ff9800, #f57c00)';
            } else {
                progressElement.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
            }
            
            // Show/hide narrator controls based on availability
            if (narratorStatus.available) {
                showButton.style.display = 'block';
                limitMessage.style.display = 'none';
                showButton.disabled = false;
            } else {
                showButton.style.display = 'none';
                limitMessage.style.display = 'block';
                // Hide narrator form if it's open
                hideNarratorForm();
            }
        }
        
        async function startNarrative() {
            console.log('Starting narrative:', narrativeId);
            updateDebugInfo(`Starting narrative: ${narrativeId}`);
            
            try {
                const response = await fetch(`/emergent_narrative/start/${narrativeId}`, {
                    method: 'POST'
                });
                
                console.log('Start response status:', response.status);
                updateDebugInfo(`Start response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Start result:', result);
                    updateDebugInfo(`Start result: ${JSON.stringify(result)}`);
                    updateNarrativeStatus();
                    
                    // Start auto-advance if enabled
                    startAutoAdvance();
                } else {
                    const errorText = await response.text();
                    console.error('Start error:', errorText);
                    updateDebugInfo(`Start ERROR: ${errorText}`);
                    alert(`Failed to start narrative: ${errorText}`);
                }
            } catch (error) {
                console.error('Start exception:', error);
                updateDebugInfo(`Start EXCEPTION: ${error.message}`);
                alert(`Error starting narrative: ${error.message}`);
            }
        }
        
        async function pauseNarrative() {
            stopAutoAdvance(); // Stop auto-advance when pausing
            
            try {
                const response = await fetch(`/emergent_narrative/pause/${narrativeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    updateNarrativeStatus();
                } else {
                    alert('Failed to pause narrative');
                }
            } catch (error) {
                alert(`Error pausing narrative: ${error.message}`);
            }
        }
        
        async function repairNarrativeCharacters() {
            updateDebugInfo('Attempting to repair character ID mismatches...');
            
            try {
                const response = await fetch(`/emergent_narrative/repair/${narrativeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateDebugInfo(`Repair result: ${JSON.stringify(result)}`);
                    alert('Character IDs repaired. Try advancing again.');
                    updateNarrativeStatus();
                } else {
                    const error = await response.text();
                    updateDebugInfo(`Repair failed: ${error}`);
                    alert('Failed to repair character IDs. You may need to reset the narrative.');
                }
            } catch (error) {
                updateDebugInfo(`Repair exception: ${error.message}`);
                alert('Error during repair. Try resetting the narrative.');
            }
        }
        
        async function advanceNarrative() {
            if (isProcessing) return;
            
            // Stop any pending auto-advance
            stopAutoAdvance();
            
            const button = document.getElementById('advanceButton');
            const originalText = button.textContent;
            
            isProcessing = true;
            button.disabled = true;
            button.innerHTML = '<span class="loading-indicator"></span> Processing...';
            
            updateDebugInfo('Starting narrative advance...');
            
            // Show typing indicator
            showTypingIndicator();
            
            try {
                const outputMode = document.getElementById('outputMode').value;
                updateDebugInfo(`Advance with output mode: ${outputMode}`);
                
                const response = await fetch(`/emergent_narrative/advance/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ output_mode: outputMode })
                });
                
                updateDebugInfo(`Advance response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Advance result:', result);
                    updateDebugInfo(`Advance result: ${JSON.stringify(result)}`);
                    
                    // Show auto-repair notification if repairs were made
                    if (result.auto_repairs_made) {
                        updateDebugInfo('✅ SMART AUTO-REPAIR: Character assignments automatically optimized for variety');
                        updateDebugInfo('🎭 Character rotation ensures different combinations across scenes');
                        // Optional: Show a brief toast notification to user
                        // showNotification('Character assignments automatically corrected', 'info');
                    }
                    
                    // Show notification if influences were cleared
                    if (result.influences_cleared) {
                        updateDebugInfo('🌟 INFLUENCES CLEARED: All consciousness influences reset for new scene');
                        // Show brief visual notification in influence section
                        const influenceSection = document.getElementById('activeInfluences');
                        if (influenceSection) {
                            influenceSection.innerHTML = '<div style="color: #4caf50; font-style: italic; animation: fadeIn 0.5s;">✨ All influences cleared for new scene</div>';
                            setTimeout(() => {
                                // This will get updated by the next status refresh
                                updateNarrativeStatus();
                            }, 2000);
                        }
                    }
                    
                    // Remove typing indicator
                    hideTypingIndicator();
                    
                    // If scene advanced to a new scene, clear the interactions display
                    if (result.narrative_advanced) {
                        updateDebugInfo('Scene advanced - clearing interactions display for new scene');
                        const container = document.getElementById('interactionsDisplay');
                        
                        // Show scene transition message with new characters
                        let newSceneMessage = '<div class="empty-theater">New scene starting...</div>';
                        if (result.next_character) {
                            newSceneMessage = `<div class="empty-theater">🎬 <strong>New Scene</strong><br/>Starting with ${result.next_character}</div>`;
                        }
                        
                        container.innerHTML = newSceneMessage;
                        
                        // Brief delay before adding the new interaction to show scene transition
                        setTimeout(() => {
                            // Force refresh of current scene info for character assignments
                            updateNarrativeStatus().then(() => {
                                const messageElement = addInteractionToDisplay(result);
                                // Ensure colors are updated for the new scene
                                updateCharacterColorsForScene();
                                
                                // Handle audio for new scene
                                if (result.audio_url) {
                                    setTimeout(() => playAudioFromUrl(result.audio_url, messageElement), 100);
                                }
                            });
                        }, 500);
                    } else {
                        // Add interaction to current scene
                        const messageElement = addInteractionToDisplay(result);
                        
                        // Handle audio for current scene interaction
                        if (result.audio_url) {
                            setTimeout(() => playAudioFromUrl(result.audio_url, messageElement), 100);
                        }
                    }
                    
                    updateNarrativeStatus();
                    
                    // Start next auto-advance if enabled and narrative is still running
                    if (!result.narrative_completed && !result.scene_completed) {
                        startAutoAdvance();
                    }
                    
                } else {
                    hideTypingIndicator();
                    const error = await response.text();
                    console.error('Advance error:', error);
                    updateDebugInfo(`Advance ERROR: ${error}`);
                    
                    // Try to extract more details from the error
                    let errorMessage = error;
                    try {
                        const errorObj = JSON.parse(error);
                        errorMessage = errorObj.detail || error;
                    } catch (e) {
                        // Error is not JSON, use as-is
                    }
                    
                    // Show user-friendly error message
                    alert(`Unable to advance narrative. The system will attempt to auto-repair and continue.\n\nTechnical details: ${errorMessage}`);
                    
                    // Attempt automatic repair
                    updateDebugInfo('Attempting automatic character repair...');
                    await repairNarrativeCharacters();
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('Advance exception:', error);
                updateDebugInfo(`Advance EXCEPTION: ${error.message}`);
                alert(`Error advancing narrative: ${error.message}`);
            } finally {
                isProcessing = false;
                button.disabled = false;
                button.textContent = originalText;
            }
        }
        
        function showTypingIndicator() {
            const container = document.getElementById('interactionsDisplay');
            
            // Remove empty state if present
            const emptyState = container.querySelector('.empty-theater');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Remove any existing typing indicator
            hideTypingIndicator();
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            
            typingDiv.innerHTML = `
                <div class="character-avatar">
                    <span>🤔</span>
                </div>
                <div class="typing-bubble">
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            
            container.appendChild(typingDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        function addInteractionToDisplay(result) {
            const container = document.getElementById('interactionsDisplay');
            
            // Remove empty state if present
            const emptyState = container.querySelector('.empty-theater');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Check if this is a narrator announcement
            if (result.character === 'NARRATOR' || result.type === 'narrator_announcement') {
                return addNarratorAnnouncementToDisplay(result);
            }
            
            // Find the character data to get image path
            let characterData = null;
            for (const char of narrativeData.characters) {
                if (char.name === result.character) {
                    characterData = char;
                    break;
                }
            }
            
            // Determine character type based on current scene assignments
            let isCharacterA = false;
            if (currentSceneInfo && currentSceneInfo.characters) {
                // Use actual scene character assignments if available
                const sceneCharacterA = currentSceneInfo.characters[0];
                isCharacterA = result.character === sceneCharacterA;
                updateDebugInfo(`Character assignment: ${result.character} is ${isCharacterA ? 'A' : 'B'} (Scene A: ${sceneCharacterA}, Scene B: ${currentSceneInfo.characters[1] || 'Unknown'})`);
            } else {
                // Fallback to alternating pattern
                const existingMessages = container.querySelectorAll('.interaction-message');
                const messageCount = existingMessages.length;
                isCharacterA = messageCount % 2 === 0;
                updateDebugInfo(`Character assignment fallback: ${result.character} is ${isCharacterA ? 'A' : 'B'} (message #${messageCount})`);
            }
            
            // Create avatar content
            let avatarContent;
            if (characterData && characterData.image_path) {
                avatarContent = `<img src="${characterData.image_path}" alt="${result.character}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
            } else {
                const characterInitials = result.character.split(' ').map(n => n[0]).join('').toUpperCase();
                avatarContent = characterInitials;
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `interaction-message character-${isCharacterA ? 'a' : 'b'}`;
            
            messageDiv.innerHTML = `
                <div class="character-avatar">
                    ${avatarContent}
                </div>
                <div class="message-bubble">
                    ${result.response}
                    ${result.influence_applied ? `<div style="font-size: 0.7rem; opacity: 0.8; margin-top: 6px; font-style: italic;">✨ "${result.influence_applied}"</div>` : ''}
                </div>
            `;
            
            container.appendChild(messageDiv);
            
            // Add timestamp after a brief delay for better UX
            setTimeout(() => {
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'message-timestamp';
                timestampDiv.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                container.appendChild(timestampDiv);
                container.scrollTop = container.scrollHeight;
            }, 100);
            
            container.scrollTop = container.scrollHeight;
            
            return messageDiv; // Return the message element for audio attachment
        }
        
        async function loadExistingInteractions() {
            // Load any existing interactions when page loads
            try {
                const response = await fetch(`/emergent_narrative/interactions/${narrativeId}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Loaded existing interactions:', data);
                    
                    const container = document.getElementById('interactionsDisplay');
                    
                    if (data.interactions && data.interactions.length > 0) {
                        // Clear empty state
                        container.innerHTML = '';
                        
                        // Add each existing interaction
                        data.interactions.forEach(interaction => {
                            addInteractionToDisplay(interaction);
                        });
                        
                        console.log(`Loaded ${data.interactions.length} existing interactions`);
                    } else {
                        // Show empty state
                        container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
                    }
                }
            } catch (error) {
                console.error('Failed to load existing interactions:', error);
                // Fallback to empty state
                const container = document.getElementById('interactionsDisplay');
                container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
            }
        }
        
        function playAudioFromUrl(url, messageElement = null) {
            if (!url) return;
            
            try {
                const audio = new Audio(url);
                lastAudioUrl = url; // Store for replay
                
                if (messageElement) {
                    messageAudioMap.set(messageElement, url);
                    addReplayButtonToMessage(messageElement, url);
                }
                
                updateDebugInfo(`Playing audio: ${url}`);
                audio.play().catch(e => {
                    console.log('Audio playback failed:', e);
                    updateDebugInfo(`Audio playback failed: ${e.message}`);
                });
                
                // Update the global replay button state
                updateGlobalReplayButton();
                
            } catch (e) {
                console.error('Error creating audio element:', e);
                updateDebugInfo(`Error creating audio: ${e.message}`);
            }
        }
        
        function addReplayButtonToMessage(messageElement, audioUrl) {
            // Check if replay button already exists
            if (messageElement.querySelector('.replay-button')) {
                return;
            }
            
            const replayButton = document.createElement('button');
            replayButton.className = 'replay-button';
            replayButton.innerHTML = '🔊';
            replayButton.title = 'Replay audio';
            replayButton.style.cssText = `
                background: rgba(0, 0, 0, 0.5);
                border: none;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                color: white;
                cursor: pointer;
                font-size: 12px;
                margin-left: 8px;
                opacity: 0.7;
                transition: opacity 0.2s;
            `;
            
            replayButton.addEventListener('mouseenter', function() {
                this.style.opacity = '1';
            });
            
            replayButton.addEventListener('mouseleave', function() {
                this.style.opacity = '0.7';
            });
            
            replayButton.addEventListener('click', function(e) {
                e.stopPropagation();
                playAudioFromUrl(audioUrl);
                updateDebugInfo(`Replaying audio for message`);
            });
            
            // Add to the message bubble
            const messageBubble = messageElement.querySelector('.message-bubble');
            if (messageBubble) {
                messageBubble.appendChild(replayButton);
            }
        }
        
        function updateGlobalReplayButton() {
            let replayButton = document.getElementById('global-audio-replay');
            
            if (!replayButton && lastAudioUrl) {
                // Create global replay button
                replayButton = document.createElement('button');
                replayButton.id = 'global-audio-replay';
                replayButton.className = 'control-button';
                replayButton.innerHTML = '🔊 Replay Last Audio';
                replayButton.style.cssText = `
                    background: linear-gradient(135deg, #6366f1, #8b5cf6);
                    margin-top: 10px;
                    width: 100%;
                `;
                
                replayButton.addEventListener('click', function() {
                    if (lastAudioUrl) {
                        playAudioFromUrl(lastAudioUrl);
                        updateDebugInfo('Replaying last audio from global button');
                    }
                });
                
                // Add to controls section
                const controlsSection = document.querySelector('.controls-section');
                if (controlsSection) {
                    controlsSection.appendChild(replayButton);
                }
            }
            
            if (replayButton) {
                if (lastAudioUrl) {
                    replayButton.disabled = false;
                    replayButton.style.opacity = '1';
                } else {
                    replayButton.disabled = true;
                    replayButton.style.opacity = '0.5';
                    // Hide the button if no audio has ever been played
                    if (messageAudioMap.size === 0) {
                        replayButton.style.display = 'none';
                    }
                }
            }
        }
        
        async function applyInfluence() {
            const word = document.getElementById('influenceWord').value.trim();
            const target = document.getElementById('influenceTarget').value;
            const duration = parseInt(document.getElementById('influenceDuration').value);
            
            if (!word) {
                alert('Please enter a word of influence');
                return;
            }
            
            try {
                const response = await fetch(`/emergent_narrative/influence/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        target_character: target || null,
                        duration_cycles: duration
                    })
                });
                
                if (response.ok) {
                    document.getElementById('influenceWord').value = '';
                    updateNarrativeStatus();
                } else {
                    alert('Failed to apply influence');
                }
            } catch (error) {
                alert(`Error applying influence: ${error.message}`);
            }
        }
        
        // Initialize personality editor for runtime adjustments
        function initializePersonalityEditor() {
            const container = document.getElementById('personalityEditor');
            if (!container) return;
            
            // Get default character for personality editing (first character in current scene)
            let defaultCharacter = null;
            if (currentSceneInfo && currentSceneInfo.characters && currentSceneInfo.characters.length > 0) {
                const characterName = currentSceneInfo.characters[0];
                defaultCharacter = narrativeData.characters.find(char => char.name === characterName);
            } else if (narrativeData.characters && narrativeData.characters.length > 0) {
                defaultCharacter = narrativeData.characters[0];
            }
            
            if (!defaultCharacter) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">No characters available for personality editing.</div>';
                return;
            }
            
            personalityEditor = new PersonalitySliders({
                initialValues: currentPersonalityAdjustments[defaultCharacter.id] || defaultCharacter.personality_traits || {},
                isRuntime: true,
                compact: true,
                onChange: (values, action) => {
                    handlePersonalityChange(defaultCharacter.id, values, action);
                }
            });
            
            personalityEditor.render(container);
            updateDebugInfo('Personality editor initialized');
        }
        
        function handlePersonalityChange(characterId, values, action) {
            if (action === 'apply') {
                // Apply temporary personality changes
                currentPersonalityAdjustments[characterId] = values;
                updateDebugInfo(`Applied personality changes for character ${characterId}: ${JSON.stringify(values, null, 2)}`);
                
                // Send personality adjustments to server for next interactions
                applyPersonalityAdjustments(characterId, values);
                
            } else if (action === 'reset') {
                // Reset to original values
                delete currentPersonalityAdjustments[characterId];
                updateDebugInfo(`Reset personality for character ${characterId}`);
                
                // Clear server-side adjustments
                clearPersonalityAdjustments(characterId);
            } else {
                // Live preview (just store locally, don't apply yet)
                updateDebugInfo(`Personality preview for character ${characterId}: ${JSON.stringify(values, null, 2)}`);
            }
        }
        
        async function applyPersonalityAdjustments(characterId, traits) {
            try {
                const response = await fetch(`/emergent_narrative/personality_adjustment/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: characterId,
                        personality_traits: traits,
                        temporary: true
                    })
                });
                
                if (response.ok) {
                    updateDebugInfo('✅ Personality adjustments applied to server');
                } else {
                    const error = await response.text();
                    updateDebugInfo(`❌ Failed to apply personality adjustments: ${error}`);
                }
            } catch (error) {
                updateDebugInfo(`❌ Error applying personality adjustments: ${error.message}`);
            }
        }
        
        async function clearPersonalityAdjustments(characterId) {
            try {
                const response = await fetch(`/emergent_narrative/personality_adjustment/${narrativeId}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: characterId
                    })
                });
                
                if (response.ok) {
                    updateDebugInfo('✅ Personality adjustments cleared on server');
                } else {
                    const error = await response.text();
                    updateDebugInfo(`❌ Failed to clear personality adjustments: ${error}`);
                }
            } catch (error) {
                updateDebugInfo(`❌ Error clearing personality adjustments: ${error.message}`);
            }
        }
        
        // Initialize dynamic scene-based character colors when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateDebugInfo('Page loaded, initializing...');
            updateDebugInfo(`Narrative ID: ${narrativeId}`);
            updateDebugInfo(`Narrative data: ${JSON.stringify(narrativeData, null, 2)}`);
            
            // Initialize visual enhancements
            initializeVisualHierarchy();
            assignCharacterColors(narrativeData.characters.map(char => char.name));
            updateCharacterThumbnailColors();
            
            updateNarrativeStatus();
            startStatusUpdates();
            loadExistingInteractions();
            initializePersonalityEditor();
            
            // Add auto-advance mode change listener
            document.getElementById('autoAdvanceMode').addEventListener('change', function() {
                const newMode = this.value;
                updateDebugInfo(`Auto-advance mode changed to: ${newMode}`);
                
                if (newMode === 'manual') {
                    stopAutoAdvance();
                }
                
                // Update status text to reflect new mode
                updateControlButtons(document.getElementById('statusBadge').textContent.toLowerCase());
            });
            
            updateDebugInfo('Initialization complete');
        });
        
        function initializeVisualHierarchy() {
            updateDebugInfo('Initializing visual hierarchy...');
            
            // Set narrative background if image exists
            if (narrativeData.image_path) {
                setNarrativeBackground(narrativeData.image_path);
            }
            
            // Load group images for characters (if they belong to groups)
            loadCharacterGroupImages();
            
            updateDebugInfo('Visual hierarchy initialized');
        }
        
        function setNarrativeBackground(imagePath) {
            updateDebugInfo(`Setting narrative background: ${imagePath}`);
            document.body.style.backgroundImage = `url('${imagePath}')`;
            document.body.classList.add('narrative-background');
        }
        
        async function loadCharacterGroupImages() {
            try {
                // Check if any characters have group_id
                const charactersWithGroups = narrativeData.characters.filter(char => char.group_id);
                
                if (charactersWithGroups.length === 0) {
                    updateDebugInfo('No characters belong to groups');
                    return;
                }
                
                // Get unique group IDs
                const groupIds = [...new Set(charactersWithGroups.map(char => char.group_id))];
                updateDebugInfo(`Found characters in ${groupIds.length} group(s): ${groupIds.join(', ')}`);
                
                // Load group information
                for (const groupId of groupIds) {
                    const response = await fetch(`/api/character_library/groups`);
                    if (response.ok) {
                        const data = await response.json();
                        const group = data.groups.find(g => g.id === groupId);
                        
                        if (group && group.image_path) {
                            updateDebugInfo(`Loading group image for ${group.name}: ${group.image_path}`);
                            showGroupImage(group);
                            break; // Show only the first group image found
                        }
                    }
                }
                
            } catch (error) {
                updateDebugInfo(`Error loading group images: ${error.message}`);
            }
        }
        
        function showGroupImage(group) {
            const groupImageElement = document.getElementById('groupImage');
            const img = groupImageElement.querySelector('img');
            const label = groupImageElement.querySelector('.image-label');
            
            img.src = group.image_path;
            img.alt = group.name;
            label.textContent = group.name;
            groupImageElement.style.display = 'block';
            
            updateDebugInfo(`Group image displayed: ${group.name}`);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            stopAutoAdvance();
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
        });

        async function resetNarrative() {
            if (!confirm('Are you sure you want to reset this narrative to the beginning? This will clear all progress and interactions.')) {
                return;
            }
            
            stopAutoAdvance(); // Stop auto-advance when resetting
            updateDebugInfo(`Resetting narrative: ${narrativeId}`);
            
            try {
                const response = await fetch(`/emergent_narrative/reset/${narrativeId}`, {
                    method: 'POST'
                });
                
                updateDebugInfo(`Reset response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Reset result:', result);
                    updateDebugInfo(`Reset result: ${JSON.stringify(result)}`);
                    
                    // Clear the interactions display
                    const container = document.getElementById('interactionsDisplay');
                    container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
                    
                    // Clear audio state
                    lastAudioUrl = null;
                    messageAudioMap.clear();
                    updateGlobalReplayButton();
                    updateDebugInfo('Audio state cleared on reset');
                    
                    // Update status
                    updateNarrativeStatus();
                    
                    alert('Narrative has been reset to the beginning.');
                } else {
                    const errorText = await response.text();
                    console.error('Reset error:', errorText);
                    updateDebugInfo(`Reset ERROR: ${errorText}`);
                    alert(`Failed to reset narrative: ${errorText}`);
                }
            } catch (error) {
                console.error('Reset exception:', error);
                updateDebugInfo(`Reset EXCEPTION: ${error.message}`);
                alert(`Error resetting narrative: ${error.message}`);
            }
        }

        async function runHealthCheck() {
            updateDebugInfo('=== RUNNING HEALTH CHECK ===');
            
            // Check narrative data
            updateDebugInfo(`Has narrative data: ${narrativeData ? 'YES' : 'NO'}`);
            if (narrativeData) {
                updateDebugInfo(`Narrative title: ${narrativeData.title}`);
                updateDebugInfo(`Narrative state: ${narrativeData.state}`);
                updateDebugInfo(`Characters count: ${narrativeData.characters ? narrativeData.characters.length : 0}`);
                updateDebugInfo(`Acts count: ${narrativeData.acts ? narrativeData.acts.length : 0}`);
            }
            
            // Test status endpoint
            try {
                const response = await fetch(`/emergent_narrative/status/${narrativeId}`);
                updateDebugInfo(`Status endpoint: ${response.status} ${response.statusText}`);
                if (response.ok) {
                    const data = await response.json();
                    updateDebugInfo(`Current state: ${data.state}`);
                    updateDebugInfo(`Current act: ${data.current_act}`);
                    updateDebugInfo(`Current scene: ${data.current_scene}`);
                }
            } catch (error) {
                updateDebugInfo(`Status endpoint ERROR: ${error.message}`);
            }
            
            // Test debug endpoint
            try {
                const response = await fetch(`/emergent_narrative/debug/${narrativeId}`);
                updateDebugInfo(`Debug endpoint: ${response.status} ${response.statusText}`);
                if (response.ok) {
                    const data = await response.json();
                    updateDebugInfo(`Server debug info: ${JSON.stringify(data, null, 2)}`);
                }
            } catch (error) {
                updateDebugInfo(`Debug endpoint ERROR: ${error.message}`);
            }
            
            updateDebugInfo('=== HEALTH CHECK COMPLETE ===');
        }

        function startAutoAdvance() {
            const autoMode = document.getElementById('autoAdvanceMode').value;
            if (autoMode === 'auto' && !isProcessing) {
                // Wait 2-4 seconds for realistic conversation flow
                const delay = 2000 + Math.random() * 2000; 
                updateDebugInfo(`Auto-advance scheduled in ${Math.round(delay/1000)}s`);
                
                autoAdvanceTimer = setTimeout(() => {
                    updateDebugInfo('Auto-advancing...');
                    advanceNarrative();
                }, delay);
            }
        }
        
        function stopAutoAdvance() {
            if (autoAdvanceTimer) {
                clearTimeout(autoAdvanceTimer);
                autoAdvanceTimer = null;
                updateDebugInfo('Auto-advance stopped');
            }
        }

        function updateCharacterColorsForScene() {
            if (!currentSceneInfo || !currentSceneInfo.characters) {
                return;
            }
            
            const sceneCharA = currentSceneInfo.characters[0];
            const sceneCharB = currentSceneInfo.characters[1];
            
            updateDebugInfo(`Updating colors for scene characters: ${sceneCharA} & ${sceneCharB}`);
            
            // Assign ROYGBIV colors to characters if not already assigned
            assignCharacterColors([sceneCharA, sceneCharB]);
            
            const colorA = characterColorMap.get(sceneCharA);
            const colorB = characterColorMap.get(sceneCharB);
            
            // Update the CSS styling for current scene characters
            updateCharacterStylesForScene(colorA, colorB);
            
            // Update the color picker section to show current scene characters
            updateColorPickersForScene(sceneCharA, sceneCharB, colorA, colorB);
            
            // Update character thumbnail borders
            updateCharacterThumbnailColors();
        }
        
        function assignCharacterColors(characterNames) {
            // Get all characters in the narrative for consistent color assignment
            const allCharacters = narrativeData.characters.map(char => char.name);
            
            allCharacters.forEach((charName, index) => {
                if (!characterColorMap.has(charName)) {
                    const colorIndex = index % CHARACTER_COLORS.length;
                    characterColorMap.set(charName, CHARACTER_COLORS[colorIndex]);
                    updateDebugInfo(`Assigned ${CHARACTER_COLORS[colorIndex]} to ${charName} (ROYGBIV index ${colorIndex})`);
                }
            });
        }
        
        function updateCharacterThumbnailColors() {
            const thumbnails = document.querySelectorAll('.character-image');
            thumbnails.forEach(thumbnail => {
                const characterId = thumbnail.dataset.characterId;
                const character = narrativeData.characters.find(char => char.id === characterId);
                if (character && characterColorMap.has(character.name)) {
                    const color = characterColorMap.get(character.name);
                    const img = thumbnail.querySelector('img');
                    const initial = thumbnail.querySelector('.character-initial');
                    
                    if (img) {
                        img.style.borderColor = color;
                        img.style.boxShadow = `0 0 0 2px ${color}40`;
                    } else if (initial) {
                        initial.style.borderColor = color;
                        initial.style.backgroundColor = color;
                    }
                }
            });
        }
        
        function updateCharacterStylesForScene(colorA, colorB) {
            const isLightColorA = isColorLight(colorA);
            const isLightColorB = isColorLight(colorB);
            const textColorA = isLightColorA ? '#000000' : '#FFFFFF';
            const textColorB = isLightColorB ? '#000000' : '#FFFFFF';
            
            // Create or update CSS rule for current scene characters
            let styleSheet = document.getElementById('dynamic-scene-character-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'dynamic-scene-character-styles';
                document.head.appendChild(styleSheet);
            }
            
            const rules = `
                .character-a .message-bubble {
                    background: ${colorA} !important;
                    color: ${textColorA} !important;
                }
                .character-a .character-avatar {
                    background: ${colorA} !important;
                    color: ${textColorA} !important;
                }
                .character-b .message-bubble {
                    background: ${colorB} !important;
                    color: ${textColorB} !important;
                }
                .character-b .character-avatar {
                    background: ${colorB} !important;
                    color: ${textColorB} !important;
                }
            `;
            
            styleSheet.textContent = rules;
        }
        
        function updateColorPickersForScene(charA, charB, colorA, colorB) {
            // Update the color picker section to show ALL characters with ROYGBIV assignments
            const panelHeaders = document.querySelectorAll('.panel-header');
            let colorSection = null;
            
            panelHeaders.forEach(header => {
                if (header.textContent.includes('Character Colors')) {
                    colorSection = header.closest('.controls-section');
                }
            });
            
            if (!colorSection) {
                updateDebugInfo('Could not find Character Colors section');
                return;
            }
            
            const panelContent = colorSection.querySelector('div[style*="flex-direction: column"]');
            if (!panelContent) {
                updateDebugInfo('Could not find color panel content area');
                return;
            }
            
            updateDebugInfo(`Updating color pickers for all characters (current scene: ${charA} & ${charB})`);
            
            // Build color picker HTML for all characters
            const allCharacters = narrativeData.characters;
            const characterPickers = allCharacters.map((character, index) => {
                const isCurrentScene = character.name === charA || character.name === charB;
                const characterColor = characterColorMap.get(character.name) || CHARACTER_COLORS[index % CHARACTER_COLORS.length];
                const colorName = getColorName(characterColor);
                
                return `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; ${isCurrentScene ? 'background: rgba(102, 126, 234, 0.1); padding: 8px; border-radius: 6px; border-left: 3px solid #667eea;' : ''}">
                        <input type="color" 
                               id="character-color-${character.id}" 
                               value="${characterColor}"
                               style="width: 40px; height: 40px; border: none; border-radius: 8px; cursor: pointer;"
                               onchange="updateCharacterColor('${character.name}', this.value)">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; ${isCurrentScene ? 'color: #667eea;' : ''}">${character.name}</div>
                            <div style="font-size: 0.8rem; color: #888;">
                                ${colorName} ${isCurrentScene ? '• Current Scene' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            panelContent.innerHTML = `
                ${characterPickers}
                <div style="margin-top: 12px; padding: 8px; background: #333; border-radius: 6px; font-size: 0.8rem; color: #aaa;">
                    🌈 ROYGBIV palette ensures distinct character recognition across scenes
                </div>
            `;
        }
        
        function getColorName(hexColor) {
            const colorNames = {
                '#FF3B30': 'Red',
                '#FF9500': 'Orange', 
                '#FFD60A': 'Yellow',
                '#34C759': 'Green',
                '#007AFF': 'Blue',
                '#5856D6': 'Indigo',
                '#AF52DE': 'Violet',
                '#FF6B6B': 'Light Red',
                '#FF8E53': 'Light Orange',
                '#FFF066': 'Light Yellow',
                '#51CF66': 'Light Green',
                '#339AF0': 'Light Blue'
            };
            
            return colorNames[hexColor] || 'Custom';
        }
        
        function updateCharacterColor(characterName, newColor) {
            // Update the stored color
            characterColorMap.set(characterName, newColor);
            updateDebugInfo(`Updated color for ${characterName}: ${newColor}`);
            
            // If this character is in the current scene, update scene styling
            if (currentSceneInfo && currentSceneInfo.characters.includes(characterName)) {
                updateCharacterColorsForScene();
            }
            
            // Update thumbnail colors
            updateCharacterThumbnailColors();
        }
        

        
        function isColorLight(color) {
            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
        }
        
        // Narrator announcement functions
        function showNarratorForm() {
            const form = document.getElementById('narratorForm');
            const button = document.getElementById('showNarratorButton');
            
            form.style.display = 'block';
            button.style.display = 'none';
            
            // Focus on the textarea
            document.getElementById('narratorText').focus();
            
            updateDebugInfo('Narrator form opened');
        }
        
        function hideNarratorForm() {
            const form = document.getElementById('narratorForm');
            const button = document.getElementById('showNarratorButton');
            
            form.style.display = 'none';
            button.style.display = 'block';
            
            // Clear the textarea
            document.getElementById('narratorText').value = '';
            
            updateDebugInfo('Narrator form closed');
        }
        
        async function makeNarratorAnnouncement() {
            const text = document.getElementById('narratorText').value.trim();
            
            if (!text) {
                alert('Please enter an announcement text');
                return;
            }
            
            const button = event.target;
            const originalText = button.textContent;
            
            try {
                button.disabled = true;
                button.textContent = '📢 Announcing...';
                
                updateDebugInfo(`Making narrator announcement: "${text}"`);
                
                const outputMode = document.getElementById('outputMode').value;
                
                const response = await fetch(`/emergent_narrative/narrator_announcement/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        output_mode: outputMode
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateDebugInfo(`Narrator announcement result: ${JSON.stringify(result)}`);
                    
                    // Add the announcement to the display
                    addNarratorAnnouncementToDisplay(result);
                    
                    // Hide the form
                    hideNarratorForm();
                    
                    // Play audio if available
                    if (result.audio_url) {
                        setTimeout(() => playAudioFromUrl(result.audio_url), 500);
                    }
                    
                    // Update narrator status display
                    if (result.narrator_status) {
                        updateNarratorStatus(result.narrator_status);
                    }
                    
                    // Update status to reflect the new interaction
                    updateNarrativeStatus();
                    
                } else if (response.status === 403) {
                    // Handle narrator limit reached
                    const error = await response.text();
                    updateDebugInfo(`Narrator limit reached: ${error}`);
                    
                    // Show user-friendly message
                    alert('⚠️ Narrator Limit Reached\n\nYou have used all available narrator announcements for this narrative. Use "Consciousness Influence" instead to affect the story.');
                    
                    // Hide the form and update UI
                    hideNarratorForm();
                    updateNarrativeStatus(); // This will update the narrator status UI
                    
                } else {
                    const error = await response.text();
                    updateDebugInfo(`Narrator announcement error: ${error}`);
                    alert(`Failed to make announcement: ${error}`);
                }
                
            } catch (error) {
                updateDebugInfo(`Narrator announcement exception: ${error.message}`);
                alert(`Error making announcement: ${error.message}`);
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        }
        
        function addNarratorAnnouncementToDisplay(result) {
            const container = document.getElementById('interactionsDisplay');
            
            // Remove empty state if present
            const emptyState = container.querySelector('.empty-theater');
            if (emptyState) {
                emptyState.remove();
            }
            
            const announcementDiv = document.createElement('div');
            announcementDiv.className = 'narrator-announcement';
            
            announcementDiv.innerHTML = `
                <div class="narrator-label">Narrator</div>
                <div class="narrator-bubble">
                    ${result.text}
                </div>
            `;
            
            container.appendChild(announcementDiv);
            
            // Add timestamp after a brief delay
            setTimeout(() => {
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'message-timestamp';
                timestampDiv.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                container.appendChild(timestampDiv);
                container.scrollTop = container.scrollHeight;
            }, 100);
            
            container.scrollTop = container.scrollHeight;
            
            // Store audio for replay if available
            if (result.audio_url) {
                lastAudioUrl = result.audio_url;
                updateGlobalReplayButton();
            }
            
            updateDebugInfo('Narrator announcement added to display');
            
            return announcementDiv;
        }
        
        // Update the control buttons function to show/hide narrator button based on state
        function updateNarratorButtonVisibility(state) {
            const narratorButton = document.getElementById('showNarratorButton');
            const narratorForm = document.getElementById('narratorForm');
            
            // Only show narrator option when narrative is actively running
            if (state === 'manifesting') {
                narratorButton.style.display = 'block';
            } else {
                narratorButton.style.display = 'none';
                // Hide form if it's open
                if (narratorForm.style.display === 'block') {
                    hideNarratorForm();
                }
            }
        }
        
        function showSyncPersonalityModal() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const characterOptions = narrativeData.characters.map(char => 
                `<option value="${char.name}">${char.name}</option>`
            ).join('');
            
            modal.innerHTML = `
                <div style="
                    background: #2a2a2a;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    border: 1px solid #333;
                ">
                    <h3 style="margin: 0 0 20px 0; color: #667eea;">Sync Personality Traits</h3>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600;">Select Character:</label>
                        <select id="syncCharacterSelect" style="
                            width: 100%;
                            background: #333;
                            border: 2px solid #444;
                            border-radius: 8px;
                            padding: 12px;
                            color: #ffffff;
                            font-size: 1rem;
                        ">
                            <option value="">Choose a character...</option>
                            ${characterOptions}
                        </select>
                    </div>
                    
                    <div style="background: rgba(255, 152, 0, 0.1); border-left: 3px solid #ff9800; padding: 15px; margin-bottom: 20px; border-radius: 0 8px 8px 0;">
                        <strong>⚠️ Runtime Sync</strong><br>
                        <span style="color: #aaa; font-size: 0.9rem;">
                            This will temporarily sync traits from the Character Library for the current play session. 
                            These changes won't affect the original narrative or character definitions.
                        </span>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button onclick="closeSyncModal()" style="
                            background: #555;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                        ">Cancel</button>
                        
                        <button onclick="syncSelectedCharacterTraits()" style="
                            background: linear-gradient(135deg, #667eea, #764ba2);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                        ">Sync Traits</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            window.currentSyncModal = modal;
        }
        
        function closeSyncModal() {
            if (window.currentSyncModal) {
                window.currentSyncModal.remove();
                window.currentSyncModal = null;
            }
        }
        
        async function syncSelectedCharacterTraits() {
            const select = document.getElementById('syncCharacterSelect');
            const selectedCharacterName = select.value;
            
            if (!selectedCharacterName) {
                alert('Please select a character to sync');
                return;
            }
            
            try {
                // Search for the character in the library
                const response = await fetch(`/api/character_library/characters?query=${encodeURIComponent(selectedCharacterName)}`);
                if (!response.ok) {
                    throw new Error('Failed to search character library');
                }
                
                const data = await response.json();
                const libraryCharacter = data.characters.find(c => c.name.toLowerCase() === selectedCharacterName.toLowerCase());
                
                if (!libraryCharacter) {
                    alert(`No character named "${selectedCharacterName}" found in the character library.`);
                    return;
                }
                
                updateDebugInfo(`Found library character ${libraryCharacter.name} with traits: ${JSON.stringify(libraryCharacter.personality_traits)}`);
                
                // Check if the library character has custom personality traits
                const hasCustomTraits = libraryCharacter.personality_traits && 
                    Object.keys(libraryCharacter.personality_traits).length > 0 &&
                    Object.values(libraryCharacter.personality_traits).some(value => value !== 5);
                
                if (!hasCustomTraits) {
                    alert(`Character "${selectedCharacterName}" in the library doesn't have customized personality traits (all values are defaults).`);
                    return;
                }
                
                // Apply the traits to the personality editor temporarily
                if (personalityEditor && typeof personalityEditor.setValues === 'function') {
                    personalityEditor.setValues(libraryCharacter.personality_traits);
                    updateDebugInfo(`Applied library traits to personality editor for ${selectedCharacterName}`);
                    
                    // Store as current adjustments for this character (find character ID)
                    const narrativeCharacter = narrativeData.characters.find(c => c.name === selectedCharacterName);
                    if (narrativeCharacter) {
                        currentPersonalityAdjustments[narrativeCharacter.id] = { ...libraryCharacter.personality_traits };
                        updateDebugInfo(`Stored temporary adjustments for character ID ${narrativeCharacter.id}`);
                    }
                }
                
                closeSyncModal();
                alert(`Successfully synced personality traits for "${selectedCharacterName}" from the character library!\\n\\nNote: These are temporary runtime changes and won't affect the original narrative.`);
                
            } catch (error) {
                console.error('Error syncing personality traits:', error);
                updateDebugInfo(`Error syncing personality traits: ${error.message}`);
                alert(`Error syncing personality traits: ${error.message}`);
            }
        }
        
        // Modify the existing updateControlButtons function to include narrator visibility
        const originalUpdateControlButtons = updateControlButtons;
        updateControlButtons = function(state) {
            // Call the original function
            originalUpdateControlButtons(state);
            
            // Add narrator button visibility logic
            updateNarratorButtonVisibility(state);
        };
    </script>
    
    <script src="/static/assets/personality-sliders.js"></script>
</body>
</html> 