<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>{{ narrative.title }} - Play</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial; 
            background: #1a1a1a; 
            color: #ffffff; 
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        .header { 
            background: #1c1c1e; 
            color: white; 
            padding: 15px; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        .narrative-title {
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .play-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .narrative-theater {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            min-height: 700px;
        }
        
        .control-panel {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            height: fit-content;
        }
        
        .narrative-status {
            background: #333;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .status-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-dormant { background: #555; color: #ddd; }
        .status-manifesting { background: #4caf50; color: white; }
        .status-paused { background: #ff9800; color: white; }
        .status-completed { background: #2196f3; color: white; }
        
        .interactions-display {
            flex: 1;
            background: #222;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            max-height: 500px;
            margin-bottom: 20px;
        }
        
        .interaction-message {
            margin-bottom: 15px;
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
            align-items: flex-end;
            gap: 8px;
        }
        
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            font-size: 1rem;
            line-height: 1.4;
        }
        
        .character-a .message-bubble {
            background: linear-gradient(135deg, #007AFF, #0051D8);
            color: white;
            border-bottom-left-radius: 4px;
            margin-left: auto;
            text-align: right;
        }
        
        .character-b .message-bubble {
            background: #2C2C2E;
            color: #FFFFFF;
            border: 1px solid #3A3A3C;
            border-bottom-right-radius: 4px;
            text-align: left;
        }
        
        .character-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .character-a {
            flex-direction: row-reverse;
        }
        
        .character-a .character-avatar {
            background: linear-gradient(135deg, #007AFF, #0051D8);
            color: white;
        }
        
        .character-b .character-avatar {
            background: #48484A;
            color: white;
        }
        
        .typing-indicator {
            display: flex;
            align-items: flex-end;
            gap: 8px;
            margin-bottom: 15px;
            animation: messageSlideIn 0.4s ease-out;
        }
        
        .typing-bubble {
            background: #2C2C2E;
            border: 1px solid #3A3A3C;
            border-radius: 18px;
            border-bottom-right-radius: 4px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #8E8E93;
            animation: typingPulse 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingPulse {
            0%, 60%, 100% { opacity: 0.3; transform: scale(0.8); }
            30% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes messageSlideIn {
            from { opacity: 0; transform: translateY(10px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        .message-timestamp {
            font-size: 0.7rem;
            color: #8E8E93;
            margin-top: 4px;
            text-align: center;
            opacity: 0.8;
        }
        
        .controls-section {
            margin-bottom: 20px;
        }
        
        .controls-grid {
            display: grid;
            gap: 10px;
            margin-bottom: 15px;
            grid-template-columns: 1fr 1fr;
        }
        
        .controls-grid .control-button {
            width: 100%;
        }
        
        .controls-grid .control-button:last-child {
            grid-column: 1 / -1;
        }
        
        .control-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .control-button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-button.pause {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }
        
        .control-button.advance {
            background: linear-gradient(135deg, #4caf50, #388e3c);
        }
        
        .output-mode-selector {
            margin-bottom: 15px;
        }
        
        .form-select {
            width: 100%;
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            color: #ffffff;
            font-size: 0.9rem;
        }
        
        .panel-header {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .influence-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .form-input {
            width: 100%;
            background: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            color: #ffffff;
            font-size: 0.9rem;
        }
        
        .influence-duration {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .duration-input {
            width: 60px;
        }
        
        .active-influences {
            margin-top: 15px;
        }
        
        .influence-item {
            background: #444;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .influence-word {
            font-weight: 600;
            color: #ff9800;
        }
        
        .empty-theater {
            text-align: center;
            color: #888;
            font-style: italic;
            margin-top: 50px;
        }
        
        .loading-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .characters-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .character-item {
            background: #333;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
        }
        
        .character-display-name {
            font-weight: 600;
        }
        
        .character-model {
            font-size: 0.8rem;
            color: #888;
        }
        
        @media (max-width: 768px) {
            .play-container {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .control-panel {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="/emergent_narrative">← Back to Narratives</a>
        <div class="narrative-title">{{ narrative.title }}</div>
    </div>

    <div class="play-container">
        <div class="narrative-theater">
            <div class="narrative-status">
                <div class="status-header">
                    <h3>Narrative Status</h3>
                    <span class="status-badge status-{{ narrative.state }}" id="statusBadge">
                        {{ narrative.state.upper() }}
                    </span>
                </div>
                
                <div id="actInfo">
                    <strong>Current Act:</strong> Loading...
                </div>
                
                <div id="sceneInfo" style="margin-top: 10px;">
                    <strong>Current Scene:</strong> Loading...
                </div>
            </div>
            
            <div class="interactions-display" id="interactionsDisplay">
                <div class="empty-theater">
                    Narrative interactions will appear here when the story begins...
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="controls-section">
                <div class="panel-header">🎮 Narrative Controls</div>
                
                <div class="output-mode-selector">
                    <label style="display: block; margin-bottom: 5px;">Output Mode:</label>
                    <select class="form-select" id="outputMode">
                        <option value="text">📝 Text Only</option>
                        <option value="rover_audio">🔊 RoverSeer Speakers</option>
                        <option value="local_audio">🎵 Download Audio</option>
                    </select>
                </div>
                
                <div class="output-mode-selector">
                    <label style="display: block; margin-bottom: 5px;">Story Flow:</label>
                    <select class="form-select" id="autoAdvanceMode">
                        <option value="auto">🔄 Auto-flowing (like real conversation)</option>
                        <option value="manual">👆 Manual (click Next each time)</option>
                    </select>
                </div>
                
                <div id="statusHelp" style="background: #444; border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.8rem; color: #ccc;">
                    <div id="statusHelpText">Loading status...</div>
                    <button onclick="toggleDebug()" style="margin-top: 8px; background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">🔧 Debug</button>
                </div>
                
                <div id="debugPanel" style="background: #333; border-radius: 8px; padding: 10px; margin-bottom: 15px; font-size: 0.7rem; color: #888; display: none;">
                    <div style="font-weight: bold; margin-bottom: 5px;">🔧 Debug Info:</div>
                    <div id="debugText" style="max-height: 200px; overflow-y: auto; background: #222; padding: 8px; border-radius: 4px; margin-bottom: 8px; white-space: pre-wrap; font-family: monospace;">No debug info yet...</div>
                    <div style="margin-top: 8px;">
                        <button onclick="runHealthCheck()" style="background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; margin-right: 5px;">🏥 Health Check</button>
                        <button onclick="repairNarrativeCharacters()" style="background: #d32f2f; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem; margin-right: 5px;">🔧 Fix Characters</button>
                        <button onclick="document.getElementById('debugText').innerHTML = 'Debug cleared...'" style="background: #555; color: #ccc; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">🗑️ Clear</button>
                    </div>
                </div>
                
                <div class="controls-grid">
                    <button class="control-button" id="startButton" onclick="startNarrative()">
                        ▶️ Start Narrative
                    </button>
                    <button class="control-button pause" id="pauseButton" onclick="pauseNarrative()">
                        ⏸️ Pause
                    </button>
                    <button class="control-button advance" id="advanceButton" onclick="advanceNarrative()">
                        ⏭️ Next Interaction
                    </button>
                    <button class="control-button" id="resetButton" onclick="resetNarrative()" style="background: linear-gradient(135deg, #f44336, #d32f2f); display: none;">
                        🔄 Reset to Start
                    </button>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🌟 Consciousness Influence</div>
                
                <div class="influence-form">
                    <input type="text" 
                           class="form-input" 
                           id="influenceWord" 
                           placeholder="Word of influence..."
                           maxlength="50">
                    
                    <select class="form-select" id="influenceTarget">
                        <option value="">All Characters</option>
                        {% for character in narrative.characters %}
                        <option value="{{ character.id }}">{{ character.name }}</option>
                        {% endfor %}
                    </select>
                    
                    <div class="influence-duration">
                        <span>Duration:</span>
                        <input type="number" 
                               class="form-input duration-input" 
                               id="influenceDuration" 
                               value="3" 
                               min="1" 
                               max="10">
                        <span>cycles</span>
                    </div>
                    
                    <button class="control-button" onclick="applyInfluence()">
                        Apply Influence
                    </button>
                </div>
                
                <div class="active-influences" id="activeInfluences">
                    <div style="color: #888; font-style: italic;">No active influences</div>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🎨 Character Colors</div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    {% for character in narrative.characters %}
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="color" 
                               id="color-{{ loop.index0 }}" 
                               data-character-index="{{ loop.index0 }}"
                               value="{% if loop.index0 == 0 %}#007AFF{% else %}#48484A{% endif %}"
                               style="width: 40px; height: 40px; border: none; border-radius: 8px; cursor: pointer;"
                               class="character-color-picker">
                        <div>
                            <div style="font-weight: 600;">{{ character.name }}</div>
                            <div style="font-size: 0.8rem; color: #888;">{{ character.model }}</div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            
            <div class="controls-section">
                <div class="panel-header">🎭 Characters Info</div>
                
                <div class="characters-list">
                    {% for character in narrative.characters %}
                    <div class="character-item">
                        <div class="character-display-name">{{ character.name }}</div>
                        <div class="character-model">{{ character.model }} ({{ character.voice }})</div>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>

    <!-- Narrative data from server -->
    <script type="application/json" id="narrative-data">
        {{ narrative | tojson | safe }}
    </script>

    <script>
        const narrativeData = JSON.parse(document.getElementById('narrative-data').textContent);
        const narrativeId = narrativeData.id;
        let statusUpdateInterval;
        let isProcessing = false;
        let debugMode = false;
        let autoAdvanceTimer = null;
        let currentSceneInfo = null; // Store current scene character assignments
        
        function toggleDebug() {
            debugMode = !debugMode;
            const debugPanel = document.getElementById('debugPanel');
            debugPanel.style.display = debugMode ? 'block' : 'none';
            if (debugMode) {
                updateDebugInfo('Debug mode enabled');
                setTimeout(() => runHealthCheck(), 100); // Run health check after a brief delay
            }
        }
        
        function updateDebugInfo(message) {
            if (!debugMode) return;
            const debugText = document.getElementById('debugText');
            const timestamp = new Date().toLocaleTimeString();
            
            // If this is the first message, clear the placeholder
            if (debugText.innerHTML === 'No debug info yet...') {
                debugText.innerHTML = '';
            }
            
            debugText.innerHTML += `[${timestamp}] ${message}\n`;
            debugText.scrollTop = debugText.scrollHeight;
        }
        
        function startStatusUpdates() {
            statusUpdateInterval = setInterval(updateNarrativeStatus, 2000);
        }
        
        async function updateNarrativeStatus() {
            try {
                updateDebugInfo(`Updating status for narrative ${narrativeId}`);
                const response = await fetch(`/emergent_narrative/status/${narrativeId}`);
                updateDebugInfo(`Status response: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const status = await response.json();
                updateDebugInfo(`Status data: ${JSON.stringify(status, null, 2)}`);
                
                // Extra debug for scene progress
                if (status.current_scene_info) {
                    updateDebugInfo(`SCENE PROGRESS DEBUG: ${status.current_scene_info.total_interactions}/${status.current_scene_info.required_interactions} interactions = ${status.current_scene_info.progress_text}`);
                }
                
                // Update status badge
                const badge = document.getElementById('statusBadge');
                badge.textContent = status.state.toUpperCase();
                badge.className = `status-badge status-${status.state}`;
                
                // Update act info
                const actInfo = document.getElementById('actInfo');
                if (status.current_act_info) {
                    actInfo.innerHTML = `
                        <strong>Act ${status.current_act_info.number}:</strong> 
                        ${status.current_act_info.theme}
                        <br><small>(${status.current_act + 1}/${status.total_acts})</small>
                    `;
                } else {
                    actInfo.innerHTML = '<strong>Current Act:</strong> Not started';
                }
                
                // Update scene info and store for character assignment
                const sceneInfo = document.getElementById('sceneInfo');
                if (status.current_scene_info) {
                    currentSceneInfo = status.current_scene_info; // Store for character styling
                    sceneInfo.innerHTML = `
                        <strong>Scene ${status.current_scene_info.number}:</strong> 
                        ${status.current_scene_info.description}
                        <br><small>
                            ${status.current_scene_info.characters.join(' & ')} 
                            (${status.current_scene_info.progress_text} cycles complete)
                            <br>${status.current_scene_info.total_interactions}/${status.current_scene_info.required_interactions} total exchanges
                        </small>
                    `;
                } else {
                    currentSceneInfo = null;
                    sceneInfo.innerHTML = '<strong>Current Scene:</strong> Not started';
                }
                
                // Update control buttons
                updateControlButtons(status.state);
                
                // Update active influences
                updateActiveInfluences(status.active_influences);
                
            } catch (error) {
                console.error('Failed to update status:', error);
                updateDebugInfo(`ERROR updating status: ${error.message}`);
                
                // Show error in status help
                const statusHelpText = document.getElementById('statusHelpText');
                statusHelpText.innerHTML = `❌ <strong>Connection Error</strong><br>Unable to get narrative status: ${error.message}`;
            }
        }
        
        function updateControlButtons(state) {
            const startButton = document.getElementById('startButton');
            const pauseButton = document.getElementById('pauseButton');
            const advanceButton = document.getElementById('advanceButton');
            const resetButton = document.getElementById('resetButton');
            const statusHelpText = document.getElementById('statusHelpText');
            const autoMode = document.getElementById('autoAdvanceMode').value;
            
            console.log('Updating buttons for state:', state);
            
            if (state === 'dormant') {
                startButton.disabled = false;
                startButton.textContent = '▶️ Start Narrative';
                pauseButton.disabled = true;
                advanceButton.disabled = true;
                resetButton.style.display = 'none';
                statusHelpText.innerHTML = '✨ <strong>Ready to Start</strong><br>Click "Start Narrative" to begin the story.';
            } else if (state === 'manifesting') {
                startButton.disabled = true;
                startButton.textContent = '▶️ Running...';
                pauseButton.disabled = false;
                advanceButton.disabled = isProcessing;
                resetButton.style.display = 'inline-block';
                
                if (autoMode === 'auto') {
                    statusHelpText.innerHTML = '🎭 <strong>Story Flowing</strong><br>Auto-advancing every 2-4 seconds. Use "Pause" to stop, "Next" to skip ahead, or "Reset" to start over.';
                } else {
                    statusHelpText.innerHTML = '🎭 <strong>Story in Progress</strong><br>Click "Next Interaction" to advance, "Pause" to stop, or "Reset" to start over.';
                }
            } else if (state === 'paused') {
                startButton.disabled = false;
                startButton.textContent = '▶️ Resume';
                pauseButton.disabled = true;
                advanceButton.disabled = isProcessing;
                resetButton.style.display = 'inline-block';
                statusHelpText.innerHTML = '⏸️ <strong>Story Paused</strong><br>Click "Resume" to continue, "Next Interaction" to advance manually, or "Reset" to start over.';
            } else if (state === 'completed') {
                startButton.disabled = true;
                startButton.textContent = '✅ Complete';
                pauseButton.disabled = true;
                advanceButton.disabled = true;
                resetButton.style.display = 'inline-block';
                statusHelpText.innerHTML = '🎉 <strong>Story Complete</strong><br>This narrative has finished. Click "Reset" to experience it again from the beginning.';
            }
        }
        
        function updateActiveInfluences(influences) {
            const container = document.getElementById('activeInfluences');
            
            if (influences.length === 0) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">No active influences</div>';
                return;
            }
            
            container.innerHTML = influences.map(inf => `
                <div class="influence-item">
                    <div class="influence-word">"${inf.word}"</div>
                    <div style="font-size: 0.8rem; color: #aaa;">
                        Target: ${inf.target || 'All Characters'}
                    </div>
                    <div style="font-size: 0.8rem; color: #4caf50;">
                        ${inf.remaining_cycles} cycles remaining
                    </div>
                </div>
            `).join('');
        }
        
        async function startNarrative() {
            console.log('Starting narrative:', narrativeId);
            updateDebugInfo(`Starting narrative: ${narrativeId}`);
            
            try {
                const response = await fetch(`/emergent_narrative/start/${narrativeId}`, {
                    method: 'POST'
                });
                
                console.log('Start response status:', response.status);
                updateDebugInfo(`Start response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Start result:', result);
                    updateDebugInfo(`Start result: ${JSON.stringify(result)}`);
                    updateNarrativeStatus();
                    
                    // Start auto-advance if enabled
                    startAutoAdvance();
                } else {
                    const errorText = await response.text();
                    console.error('Start error:', errorText);
                    updateDebugInfo(`Start ERROR: ${errorText}`);
                    alert(`Failed to start narrative: ${errorText}`);
                }
            } catch (error) {
                console.error('Start exception:', error);
                updateDebugInfo(`Start EXCEPTION: ${error.message}`);
                alert(`Error starting narrative: ${error.message}`);
            }
        }
        
        async function pauseNarrative() {
            stopAutoAdvance(); // Stop auto-advance when pausing
            
            try {
                const response = await fetch(`/emergent_narrative/pause/${narrativeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    updateNarrativeStatus();
                } else {
                    alert('Failed to pause narrative');
                }
            } catch (error) {
                alert(`Error pausing narrative: ${error.message}`);
            }
        }
        
        async function repairNarrativeCharacters() {
            updateDebugInfo('Attempting to repair character ID mismatches...');
            
            try {
                const response = await fetch(`/emergent_narrative/repair/${narrativeId}`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    updateDebugInfo(`Repair result: ${JSON.stringify(result)}`);
                    alert('Character IDs repaired. Try advancing again.');
                    updateNarrativeStatus();
                } else {
                    const error = await response.text();
                    updateDebugInfo(`Repair failed: ${error}`);
                    alert('Failed to repair character IDs. You may need to reset the narrative.');
                }
            } catch (error) {
                updateDebugInfo(`Repair exception: ${error.message}`);
                alert('Error during repair. Try resetting the narrative.');
            }
        }
        
        async function advanceNarrative() {
            if (isProcessing) return;
            
            // Stop any pending auto-advance
            stopAutoAdvance();
            
            const button = document.getElementById('advanceButton');
            const originalText = button.textContent;
            
            isProcessing = true;
            button.disabled = true;
            button.innerHTML = '<span class="loading-indicator"></span> Processing...';
            
            updateDebugInfo('Starting narrative advance...');
            
            // Show typing indicator
            showTypingIndicator();
            
            try {
                const outputMode = document.getElementById('outputMode').value;
                updateDebugInfo(`Advance with output mode: ${outputMode}`);
                
                const response = await fetch(`/emergent_narrative/advance/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ output_mode: outputMode })
                });
                
                updateDebugInfo(`Advance response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Advance result:', result);
                    updateDebugInfo(`Advance result: ${JSON.stringify(result)}`);
                    
                    // Remove typing indicator
                    hideTypingIndicator();
                    
                    // If scene advanced to a new scene, clear the interactions display
                    if (result.narrative_advanced) {
                        updateDebugInfo('Scene advanced - clearing interactions display for new scene');
                        const container = document.getElementById('interactionsDisplay');
                        container.innerHTML = '<div class="empty-theater">New scene starting...</div>';
                        
                        // Brief delay before adding the new interaction to show scene transition
                        setTimeout(() => {
                            addInteractionToDisplay(result);
                        }, 500);
                    } else {
                        // Add interaction to current scene
                        addInteractionToDisplay(result);
                    }
                    
                    // Handle audio if provided
                    if (result.audio_url) {
                        playAudioFromUrl(result.audio_url);
                    }
                    
                    updateNarrativeStatus();
                    
                    // Start next auto-advance if enabled and narrative is still running
                    if (!result.narrative_completed && !result.scene_completed) {
                        startAutoAdvance();
                    }
                    
                } else {
                    hideTypingIndicator();
                    const error = await response.text();
                    console.error('Advance error:', error);
                    updateDebugInfo(`Advance ERROR: ${error}`);
                    
                    // If it's a character error, try to run a repair
                    if (error.includes('Scene characters not found')) {
                        updateDebugInfo('Character ID mismatch detected - running repair...');
                        await repairNarrativeCharacters();
                    } else {
                        alert(`Failed to advance narrative: ${error}`);
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('Advance exception:', error);
                updateDebugInfo(`Advance EXCEPTION: ${error.message}`);
                alert(`Error advancing narrative: ${error.message}`);
            } finally {
                isProcessing = false;
                button.disabled = false;
                button.textContent = originalText;
            }
        }
        
        function showTypingIndicator() {
            const container = document.getElementById('interactionsDisplay');
            
            // Remove empty state if present
            const emptyState = container.querySelector('.empty-theater');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Remove any existing typing indicator
            hideTypingIndicator();
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            
            typingDiv.innerHTML = `
                <div class="character-avatar">
                    <span>🤔</span>
                </div>
                <div class="typing-bubble">
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            
            container.appendChild(typingDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        function addInteractionToDisplay(result) {
            const container = document.getElementById('interactionsDisplay');
            
            // Remove empty state if present
            const emptyState = container.querySelector('.empty-theater');
            if (emptyState) {
                emptyState.remove();
            }
            
            // Determine character type based on current scene assignments
            let isCharacterA = false;
            if (currentSceneInfo && currentSceneInfo.characters) {
                // Use actual scene character assignments if available
                const sceneCharacterA = currentSceneInfo.characters[0];
                isCharacterA = result.character === sceneCharacterA;
                updateDebugInfo(`Character assignment: ${result.character} is ${isCharacterA ? 'A' : 'B'} (Scene A: ${sceneCharacterA}, Scene B: ${currentSceneInfo.characters[1] || 'Unknown'})`);
            } else {
                // Fallback to alternating pattern
                const existingMessages = container.querySelectorAll('.interaction-message');
                const messageCount = existingMessages.length;
                isCharacterA = messageCount % 2 === 0;
                updateDebugInfo(`Character assignment fallback: ${result.character} is ${isCharacterA ? 'A' : 'B'} (message #${messageCount})`);
            }
            const characterInitials = result.character.split(' ').map(n => n[0]).join('').toUpperCase();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `interaction-message character-${isCharacterA ? 'a' : 'b'}`;
            
            messageDiv.innerHTML = `
                <div class="character-avatar">
                    ${characterInitials}
                </div>
                <div class="message-bubble">
                    ${result.response}
                    ${result.influence_applied ? `<div style="font-size: 0.7rem; opacity: 0.8; margin-top: 6px; font-style: italic;">✨ "${result.influence_applied}"</div>` : ''}
                </div>
            `;
            
            container.appendChild(messageDiv);
            
            // Add timestamp after a brief delay for better UX
            setTimeout(() => {
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'message-timestamp';
                timestampDiv.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                container.appendChild(timestampDiv);
                container.scrollTop = container.scrollHeight;
            }, 100);
            
            container.scrollTop = container.scrollHeight;
        }
        
        async function loadExistingInteractions() {
            // Load any existing interactions when page loads
            try {
                const response = await fetch(`/emergent_narrative/interactions/${narrativeId}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Loaded existing interactions:', data);
                    
                    const container = document.getElementById('interactionsDisplay');
                    
                    if (data.interactions && data.interactions.length > 0) {
                        // Clear empty state
                        container.innerHTML = '';
                        
                        // Add each existing interaction
                        data.interactions.forEach(interaction => {
                            addInteractionToDisplay(interaction);
                        });
                        
                        console.log(`Loaded ${data.interactions.length} existing interactions`);
                    } else {
                        // Show empty state
                        container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
                    }
                }
            } catch (error) {
                console.error('Failed to load existing interactions:', error);
                // Fallback to empty state
                const container = document.getElementById('interactionsDisplay');
                container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
            }
        }
        
        function playAudioFromUrl(url) {
            const audio = new Audio(url);
            audio.play().catch(e => console.log('Audio playback failed:', e));
        }
        
        async function applyInfluence() {
            const word = document.getElementById('influenceWord').value.trim();
            const target = document.getElementById('influenceTarget').value;
            const duration = parseInt(document.getElementById('influenceDuration').value);
            
            if (!word) {
                alert('Please enter a word of influence');
                return;
            }
            
            try {
                const response = await fetch(`/emergent_narrative/influence/${narrativeId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        target_character: target || null,
                        duration_cycles: duration
                    })
                });
                
                if (response.ok) {
                    document.getElementById('influenceWord').value = '';
                    updateNarrativeStatus();
                } else {
                    alert('Failed to apply influence');
                }
            } catch (error) {
                alert(`Error applying influence: ${error.message}`);
            }
        }
        
        // Color customization functions
        function setupColorPickers() {
            const colorPickers = document.querySelectorAll('.character-color-picker');
            colorPickers.forEach(picker => {
                picker.addEventListener('change', function() {
                    const characterIndex = parseInt(this.dataset.characterIndex);
                    updateCharacterColor(characterIndex, this.value);
                });
            });
        }
        
        function updateCharacterColor(characterIndex, color) {
            const characterClass = characterIndex === 0 ? 'character-a' : 'character-b';
            const isLightColor = isColorLight(color);
            const textColor = isLightColor ? '#000000' : '#FFFFFF';
            
            // Create or update CSS rule for this character
            let styleSheet = document.getElementById('dynamic-character-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'dynamic-character-styles';
                document.head.appendChild(styleSheet);
            }
            
            // Update bubble colors
            const rules = `
                .${characterClass} .message-bubble {
                    background: ${color} !important;
                    color: ${textColor} !important;
                }
                .${characterClass} .character-avatar {
                    background: ${color} !important;
                    color: ${textColor} !important;
                }
            `;
            
            // Replace or add the rules
            const existingRules = styleSheet.textContent;
            const updatedRules = existingRules.replace(
                new RegExp(`\\.${characterClass}[^}]*}[^}]*}`, 'g'), 
                ''
            ) + rules;
            
            styleSheet.textContent = updatedRules;
        }
        
        function isColorLight(color) {
            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5;
        }
        
        // Initialize color pickers when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateDebugInfo('Page loaded, initializing...');
            updateDebugInfo(`Narrative ID: ${narrativeId}`);
            updateDebugInfo(`Narrative data: ${JSON.stringify(narrativeData, null, 2)}`);
            
            updateNarrativeStatus();
            startStatusUpdates();
            loadExistingInteractions();
            setupColorPickers();
            
            // Add auto-advance mode change listener
            document.getElementById('autoAdvanceMode').addEventListener('change', function() {
                const newMode = this.value;
                updateDebugInfo(`Auto-advance mode changed to: ${newMode}`);
                
                if (newMode === 'manual') {
                    stopAutoAdvance();
                }
                
                // Update status text to reflect new mode
                updateControlButtons(document.getElementById('statusBadge').textContent.toLowerCase());
            });
            
            updateDebugInfo('Initialization complete');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            stopAutoAdvance();
            if (statusUpdateInterval) {
                clearInterval(statusUpdateInterval);
            }
        });

        async function resetNarrative() {
            if (!confirm('Are you sure you want to reset this narrative to the beginning? This will clear all progress and interactions.')) {
                return;
            }
            
            stopAutoAdvance(); // Stop auto-advance when resetting
            updateDebugInfo(`Resetting narrative: ${narrativeId}`);
            
            try {
                const response = await fetch(`/emergent_narrative/reset/${narrativeId}`, {
                    method: 'POST'
                });
                
                updateDebugInfo(`Reset response: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Reset result:', result);
                    updateDebugInfo(`Reset result: ${JSON.stringify(result)}`);
                    
                    // Clear the interactions display
                    const container = document.getElementById('interactionsDisplay');
                    container.innerHTML = '<div class="empty-theater">Narrative interactions will appear here when the story begins...</div>';
                    
                    // Update status
                    updateNarrativeStatus();
                    
                    alert('Narrative has been reset to the beginning.');
                } else {
                    const errorText = await response.text();
                    console.error('Reset error:', errorText);
                    updateDebugInfo(`Reset ERROR: ${errorText}`);
                    alert(`Failed to reset narrative: ${errorText}`);
                }
            } catch (error) {
                console.error('Reset exception:', error);
                updateDebugInfo(`Reset EXCEPTION: ${error.message}`);
                alert(`Error resetting narrative: ${error.message}`);
            }
        }

        async function runHealthCheck() {
            updateDebugInfo('=== RUNNING HEALTH CHECK ===');
            
            // Check narrative data
            updateDebugInfo(`Has narrative data: ${narrativeData ? 'YES' : 'NO'}`);
            if (narrativeData) {
                updateDebugInfo(`Narrative title: ${narrativeData.title}`);
                updateDebugInfo(`Narrative state: ${narrativeData.state}`);
                updateDebugInfo(`Characters count: ${narrativeData.characters ? narrativeData.characters.length : 0}`);
                updateDebugInfo(`Acts count: ${narrativeData.acts ? narrativeData.acts.length : 0}`);
            }
            
            // Test status endpoint
            try {
                const response = await fetch(`/emergent_narrative/status/${narrativeId}`);
                updateDebugInfo(`Status endpoint: ${response.status} ${response.statusText}`);
                if (response.ok) {
                    const data = await response.json();
                    updateDebugInfo(`Current state: ${data.state}`);
                    updateDebugInfo(`Current act: ${data.current_act}`);
                    updateDebugInfo(`Current scene: ${data.current_scene}`);
                }
            } catch (error) {
                updateDebugInfo(`Status endpoint ERROR: ${error.message}`);
            }
            
            // Test debug endpoint
            try {
                const response = await fetch(`/emergent_narrative/debug/${narrativeId}`);
                updateDebugInfo(`Debug endpoint: ${response.status} ${response.statusText}`);
                if (response.ok) {
                    const data = await response.json();
                    updateDebugInfo(`Server debug info: ${JSON.stringify(data, null, 2)}`);
                }
            } catch (error) {
                updateDebugInfo(`Debug endpoint ERROR: ${error.message}`);
            }
            
            updateDebugInfo('=== HEALTH CHECK COMPLETE ===');
        }

        function startAutoAdvance() {
            const autoMode = document.getElementById('autoAdvanceMode').value;
            if (autoMode === 'auto' && !isProcessing) {
                // Wait 2-4 seconds for realistic conversation flow
                const delay = 2000 + Math.random() * 2000; 
                updateDebugInfo(`Auto-advance scheduled in ${Math.round(delay/1000)}s`);
                
                autoAdvanceTimer = setTimeout(() => {
                    updateDebugInfo('Auto-advancing...');
                    advanceNarrative();
                }, delay);
            }
        }
        
        function stopAutoAdvance() {
            if (autoAdvanceTimer) {
                clearTimeout(autoAdvanceTimer);
                autoAdvanceTimer = null;
                updateDebugInfo('Auto-advance stopped');
            }
        }
    </script>
</body>
</html> 