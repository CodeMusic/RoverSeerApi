<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RoverSeer Neural Interface</title>
    <style>
        :root {
            /* Refined black theme with orange and purple accents */
            --primary-black: #000000;
            --background-black: #0A0A0A;
            --surface-black: #1A1A1A;
            --border-black: #2A2A2A;
            
            /* Purple accents - refined and elegant */
            --accent-purple: #8B5CF6;
            --accent-purple-light: #A78BFA;
            --accent-purple-subtle: rgba(139, 92, 246, 0.1);
            --accent-purple-border: rgba(139, 92, 246, 0.2);
            
            /* Orange accents - warm and inviting */
            --accent-orange: #F97316;
            --accent-orange-light: #FB923C;
            --accent-orange-subtle: rgba(249, 115, 22, 0.1);
            --accent-orange-border: rgba(249, 115, 22, 0.2);
            
            /* Text colors */
            --text-primary: #FFFFFF;
            --text-secondary: #B3B3B3;
            --text-muted: #666666;
            --text-accent: #CCCCCC;
            
            /* Gradients */
            --gradient-purple: linear-gradient(135deg, #8B5CF6, #A78BFA);
            --gradient-orange: linear-gradient(135deg, #F97316, #FB923C);
            --gradient-surface: linear-gradient(135deg, #1A1A1A, #2A2A2A);
            
            /* Glass effects */
            --glass-bg: rgba(26, 26, 26, 0.8);
            --glass-border: rgba(255, 255, 255, 0.1);
            
            /* Shadows */
            --shadow-subtle: 0 4px 20px rgba(0, 0, 0, 0.5);
            --shadow-purple: 0 4px 20px rgba(139, 92, 246, 0.3);
            --shadow-orange: 0 4px 20px rgba(249, 115, 22, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            background: var(--background-black);
            background-image: 
                radial-gradient(circle at 20% 80%, var(--accent-purple-subtle) 0%, transparent 70%),
                radial-gradient(circle at 80% 20%, var(--accent-orange-subtle) 0%, transparent 70%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Glassmorphism Effects */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: var(--shadow-subtle);
        }

        .glow-effect {
            position: relative;
        }

        .glow-effect::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--gradient-primary);
            border-radius: inherit;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .glow-effect:hover::before {
            opacity: 0.7;
            animation: glow-pulse 2s ease-in-out infinite alternate;
        }

        @keyframes glow-pulse {
            0% { box-shadow: 0 0 20px rgba(138, 92, 245, 0.4); }
            100% { box-shadow: 0 0 40px rgba(138, 92, 245, 0.8); }
        }

        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                margin: 0;
                padding: 0;
                background: var(--background-black);
            }
            
            .topbar {
                background: var(--glass-bg);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border-bottom: 1px solid var(--glass-border);
                color: var(--text-primary);
                padding: 12px 15px;
                padding-top: max(12px, env(safe-area-inset-top));
                flex-direction: column;
                gap: 10px;
                position: sticky;
                top: 0;
                z-index: 100;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            
            .status-container {
                justify-content: center;
                text-align: center;
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }
            
            .mobile-status-toggle {
                background: var(--glass-bg);
                color: var(--light-purple);
                border: 1px solid var(--glass-border);
                padding: 8px 16px;
                border-radius: 12px;
                font-size: 12px;
                cursor: pointer;
                margin-bottom: 6px;
                transition: all 0.3s ease;
                backdrop-filter: blur(10px);
            }
            
            .mobile-status-toggle:hover {
                background: var(--secondary-purple);
                color: white;
                transform: translateY(-2px);
                box-shadow: var(--shadow-glow);
            }
            
            .status-section {
                display: none;
                flex-wrap: wrap;
                justify-content: center;
                margin-top: 8px;
                animation: slideDown 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                gap: 10px;
            }
            
            .status-section.mobile-expanded {
                display: flex;
            }
            
            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                    max-height: 0;
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                    max-height: 400px;
                }
            }
            
            .essential-status {
                display: flex;
                flex-direction: column;
                gap: 6px;
                align-items: center;
            }
            
            .sensor-data {
                font-size: 11px;
                padding: 8px 12px;
                gap: 8px;
                border-radius: 12px;
                max-width: 100%;
                overflow-x: auto;
                white-space: nowrap;
                background: var(--glass-bg);
                border: 1px solid var(--glass-border);
                backdrop-filter: blur(10px);
                color: var(--text-secondary);
                margin-bottom: 6px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .ai-pipeline-status {
                background: var(--gradient-primary);
                color: white;
                margin-left: 0;
                font-size: 12px;
                padding: 8px 12px;
                gap: 8px;
                border-radius: 12px;
                max-width: 100%;
                overflow-x: auto;
                white-space: nowrap;
                box-shadow: var(--shadow-glow);
            }
            
            .chatbox {
                margin: 15px;
                border-radius: 20px;
                height: calc(100vh - env(safe-area-inset-top) - 140px);
                max-height: calc(100vh - env(safe-area-inset-top) - 140px);
                box-shadow: var(--shadow-subtle);
                border: 1px solid var(--glass-border);
                overflow: hidden;
            }
        }

        /* Desktop styles */
        @media (min-width: 769px) {
            body {
                margin: 20px;
                padding: 20px;
            }
        }
        
        .topbar {
            background: var(--surface-black);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-black);
            color: var(--text-primary);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            border-radius: 16px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-subtle);
        }

        .topbar strong {
            font-size: 20px;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        .status-section {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }
        
        .status-item {
            margin-right: 10px;
        }

        .status-link {
            color: var(--light-purple);
            text-decoration: none;
            padding: 4px 8px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .status-link:hover {
            color: white;
            background: var(--secondary-purple);
            text-decoration: none;
            transform: translateY(-1px);
        }

        .sensor-data {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            display: flex;
            gap: 16px;
            margin-bottom: 10px;
        }

        .sensor-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .refresh {
            cursor: pointer;
            font-size: 18px;
            margin-top: 6px;
            transition: transform 0.3s ease;
        }

        .refresh:hover {
            transform: rotate(180deg) scale(1.1);
        }
        
        .ai-pipeline-status {
            background: var(--gradient-primary);
            padding: 10px 16px;
            border-radius: 12px;
            display: flex;
            gap: 16px;
            margin-left: 0;
            color: white;
            box-shadow: var(--shadow-glow);
        }
        
        .pipeline-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }
        
        .pipeline-item .status-indicator {
            font-size: 12px;
        }
        
        .pipeline-item .detail {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* Enhanced select styling */
        select {
            background: var(--surface-black);
            border: 1px solid var(--border-black);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: var(--shadow-purple);
        }

        select option {
            background-color: var(--surface-black);
            color: var(--text-primary);
            padding: 8px;
        }

        select option:hover,
        select option:focus,
        select option:checked {
            background-color: var(--accent-purple);
            color: white;
        }
        
        select optgroup {
            font-weight: bold;
            color: var(--accent-purple-light);
            background-color: var(--background-black);
            padding: 8px 0;
        }
        
        select optgroup option {
            font-weight: normal;
            padding-left: 20px;
            background-color: var(--surface-black);
        }
        
        #voice-select option {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }
        
        /* Refined black chatbox */
        .chatbox {
            background: var(--surface-black);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-black);
            padding: 0;
            border-radius: 20px;
            margin-top: 20px;
            box-shadow: var(--shadow-subtle);
            overflow: hidden;
            height: 700px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chatbox::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--gradient-glass);
            z-index: -1;
            border-radius: inherit;
        }
        
        .chat-header {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 20px 20px 0 0;
        }
        
        .chat-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .action-buttons button {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .action-buttons button:hover {
            background: var(--secondary-purple);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(138, 92, 245, 0.4);
        }

        .clear-button {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53) !important;
        }

        .logs-button {
            background: linear-gradient(135deg, #4ecdc4, #44a08d) !important;
        }

        .volume-control {
            display: inline-flex !important;
            align-items: center;
            gap: 8px;
            background: var(--glass-bg);
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
        }

        #volumeSlider {
            width: 80px;
            height: 4px;
            background: var(--glass-border);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--gradient-primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            background: transparent;
            display: flex;
            flex-direction: column;
            scrollbar-width: thin;
            scrollbar-color: var(--glass-border) transparent;
        }

        .messages-container::-webkit-scrollbar {
            width: 6px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }

        .messages-container::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-purple);
        }
        
        .message {
            max-width: 75%;
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            animation: messageSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .message.user {
            align-self: flex-end;
        }
        
        .message.assistant {
            align-self: flex-start;
        }
        
        .message-bubble {
            padding: 14px 18px;
            border-radius: 20px;
            position: relative;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 15px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .message-bubble:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .message.user .message-bubble {
            background: var(--gradient-orange);
            color: white;
            box-shadow: var(--shadow-orange);
            border: none;
        }
        
        .message.assistant .message-bubble {
            background: var(--gradient-purple);
            color: white;
            backdrop-filter: blur(20px);
            border: 1px solid var(--accent-purple-border);
            box-shadow: var(--shadow-purple);
        }
        
        .message-info {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
            padding: 0 12px;
            opacity: 0.8;
        }

        /* Revolutionary Typing Indicator */
        .typing-indicator {
            display: none;
            max-width: 75%;
            margin-bottom: 16px;
            align-self: flex-start;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .typing-indicator.active {
            display: flex !important;
            opacity: 1;
            animation: typingSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes typingSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .typing-bubble {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 16px 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 60px;
            position: relative;
            overflow: hidden;
        }

        .typing-bubble::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(138, 92, 245, 0.1), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .typing-dots {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-purple);
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
        }

        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        .typing-dot:nth-child(3) { animation-delay: 0s; }

        @keyframes typingBounce {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.6;
            }
            40% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .typing-text {
            color: var(--text-muted);
            font-size: 12px;
            margin-left: 6px;
            opacity: 0.8;
        }
        
        /* Enhanced Chat Input */
        .chat-input-container {
            padding: 20px 24px;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            background: var(--surface-black);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border-black);
            border-radius: 0 0 20px 20px;
        }

        .chat-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 8px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .chat-controls::-webkit-scrollbar {
            display: none;
        }

        .chat-controls select,
        .chat-controls input {
            font-size: 14px;
            padding: 10px 14px;
            white-space: nowrap;
            min-width: fit-content;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .chat-controls label {
            white-space: nowrap;
            font-size: 14px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-input-form {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .chat-textarea {
            flex: 1;
            font-size: 16px;
            min-height: 48px;
            max-height: 120px;
            border-radius: 24px;
            padding: 14px 20px;
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            resize: none;
            outline: none;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .chat-textarea:focus {
            border-color: var(--secondary-purple);
            box-shadow: 0 0 20px rgba(138, 92, 245, 0.3);
        }

        .chat-textarea::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }

        .send-button {
            min-width: 48px;
            height: 48px;
            border-radius: 24px;
            font-size: 18px;
            padding: 0;
            background: var(--gradient-orange);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-orange);
        }

        .send-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 30px rgba(249, 115, 22, 0.6);
        }

        .send-button:active {
            transform: translateY(0) scale(0.95);
        }

        /* Interaction Mode Styling - Compact Version */
        .interaction-mode-toggle {
            margin-bottom: 8px;
        }

        .interaction-mode-toggle label {
            background: var(--glass-bg);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .interaction-mode-toggle label:hover {
            background: var(--secondary-purple);
            color: white;
            transform: translateY(-1px);
        }

        /* Compact interaction status bar when running */
        .interaction-status-bar {
            background: linear-gradient(135deg, var(--primary-purple), var(--secondary-purple));
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: 500;
        }

        .interaction-status-bar .status-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .interaction-status-bar .status-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .interaction-status-bar button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .interaction-status-bar button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Compact configuration panel */
        .interaction-controls {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            margin-bottom: 12px;
            backdrop-filter: blur(20px);
            overflow: hidden;
        }

        .interaction-controls.collapsed .interaction-body {
            display: none;
        }

        .interaction-header {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--gradient-glass);
            border-bottom: 1px solid var(--glass-border);
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .interaction-header:hover {
            background: var(--secondary-purple);
            color: white;
        }

        .interaction-body {
            padding: 16px;
        }

        .interaction-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .interaction-row label {
            min-width: 80px;
            font-size: 13px;
            font-weight: 500;
        }

        .interaction-row select,
        .interaction-row input {
            font-size: 13px;
            padding: 6px 8px;
        }

        .interaction-row textarea {
            font-size: 13px;
            padding: 8px;
            min-height: 50px;
        }

        /* Custom System Message Styling */
        #custom-system-group {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
        }

        #custom-system-group textarea {
            font-size: 14px;
            padding: 12px 16px;
            border-radius: 10px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
            width: 100%;
            min-height: 80px;
            resize: vertical;
        }

        /* Loading States */
        .loading-text {
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .star-loading {
            display: flex;
            gap: 4px;
        }

        .star-loading .dot {
            width: 6px;
            height: 6px;
            background: var(--secondary-purple);
            border-radius: 50%;
            animation: starPulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 8px rgba(138, 92, 245, 0.6);
        }

        .star-loading .dot:nth-child(1) { animation-delay: -0.3s; }
        .star-loading .dot:nth-child(2) { animation-delay: -0.15s; }
        .star-loading .dot:nth-child(3) { animation-delay: 0s; }

        @keyframes starPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1.3);
                opacity: 1;
            }
        }

        /* Responsive improvements for mobile */
        @media (max-width: 480px) {
            .chat-controls {
                flex-direction: column;
                gap: 12px;
            }
            
            .chat-controls > * {
                width: 100%;
            }

            .interaction-row {
                flex-direction: column;
                align-items: stretch;
            }

            .action-buttons {
                flex-wrap: wrap;
                gap: 6px;
            }

            .action-buttons button {
                font-size: 11px;
                padding: 6px 12px;
            }
        }

        /* Enhanced focus states */
        input:focus,
        select:focus,
        textarea:focus,
        button:focus {
            outline: 2px solid var(--secondary-purple);
            outline-offset: 2px;
        }

        /* Smooth transitions for all interactive elements */
        * {
            transition: color 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        }
    </style>

    <script>
        // Configuration
        var STATUS_REFRESH_INTERVAL = 5000; // 5 seconds
        
        // Parse template data from JSON script with error handling
        var roverseerData = {};
        try {
            var roverseerDataScript = document.getElementById('roverseer-data');
            if (roverseerDataScript && roverseerDataScript.textContent) {
                roverseerData = JSON.parse(roverseerDataScript.textContent);
            }
        } catch (e) {
            console.error('Error parsing roverseer data:', e);
            roverseerData = {};
        }
        
        // Use the properly escaped template data with fallbacks
        var availableVoices = roverseerData.voices || [];
        var categorizedVoices = roverseerData.categorizedVoices || {};
        var availablePersonalities = roverseerData.personalities || [];
        var currentPersonalityName = (roverseerData.currentPersonality && roverseerData.currentPersonality.name) ? roverseerData.currentPersonality.name : null;
        
        // Create personality to voice mapping from parsed data
        const personalityVoiceMap = {};
        if (availablePersonalities) {
            availablePersonalities.forEach(function(personality) {
                personalityVoiceMap[personality.name] = personality.voice_id;
            });
        }
        
        function escapeHtml(text) {
            var div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function processThinkTags(text) {
            // Check if text contains <think> tags
            var thinkRegex = /<think>([\s\S]*?)<\/think>/gi;
            var matches = text.match(thinkRegex);
            
            if (!matches) {
                return escapeHtml(text);
            }
            
            // Extract think content and main content
            var thinkContent = '';
            var mainContent = text;
            
            matches.forEach(function(match) {
                var content = match.replace(/<\/?think>/gi, '');
                thinkContent += content + '\n';
                mainContent = mainContent.replace(match, '');
            });
            
            mainContent = mainContent.trim();
            thinkContent = thinkContent.trim();
            
            // Generate unique ID for this think section - using 4 characters instead of 2
            var thinkId = 'think-' + Date.now() + '-' + Math.random().toString(36).substr(0, 4);
            
            // Build HTML with collapsible think section
            var html = '';
            if (thinkContent) {
                html += '<span class="think-toggle" onclick="toggleThink(\'' + thinkId + '\')">‚ñ∂ Show thoughts</span>';
                html += '<div class="think-content" id="' + thinkId + '">' + escapeHtml(thinkContent) + '</div>';
            }
            html += escapeHtml(mainContent);
            
            return html;
        }
        
        function toggleThink(thinkId) {
            var thinkElement = document.getElementById(thinkId);
            var toggleElement = thinkElement.previousElementSibling;
            
            if (thinkElement.classList.contains('expanded')) {
                thinkElement.classList.remove('expanded');
                toggleElement.textContent = '‚ñ∂ Show thoughts';
            } else {
                thinkElement.classList.add('expanded');
                toggleElement.textContent = '‚ñº Hide thoughts';
            }
        }
        
        // Function to load personalities dynamically from API
        function loadPersonalitiesDynamically() {
            console.log('üîÑ Loading personalities dynamically...');
            
            fetch('/system/personalities')
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Personalities loaded:', data);
                    
                    if (data && data.personalities && data.personalities.length > 0) {
                        // Update availablePersonalities global variable
                        availablePersonalities = data.personalities;
                        
                        // Update current personality if available
                        if (data.current) {
                            currentPersonalityName = data.current;
                        }
                        
                        // Refresh the personality dropdown if personality mode is active
                        var usePersonality = document.getElementById('use-personality');
                        if (usePersonality && usePersonality.checked) {
                            console.log('üîÑ Refreshing personality dropdown...');
                            togglePersonalityMode();
                        }
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error loading personalities:', error);
                });
        }

        // Auto-scroll to bottom of messages
        window.onload = function() {
            var messagesContainer = document.getElementById('messages-container');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Process all existing messages for think tags
            document.querySelectorAll('.message.assistant .message-bubble').forEach(function(bubble) {
                var text = bubble.textContent;
                if (text.includes('<think>')) {
                    bubble.innerHTML = processThinkTags(text);
                }
            });
            
            // Process any new message that needs processing
            document.querySelectorAll('.needs-processing').forEach(function(bubble) {
                var text = bubble.getAttribute('data-text');
                var audioHtml = bubble.querySelector('audio') ? bubble.querySelector('audio').outerHTML : '';
                bubble.innerHTML = processThinkTags(text) + audioHtml;
                bubble.classList.remove('needs-processing');
            });
            
            // Initialize interaction mode state based on checkbox
            toggleInteractionMode();
            
            // Double-check that interaction controls are hidden if checkbox is unchecked
            const checkbox = document.getElementById('interaction-mode-checkbox');
            const controls = document.getElementById('interaction-controls');
            if (!checkbox.checked) {
                controls.style.display = 'none';
                console.log('üé≠ Interaction controls explicitly hidden on page load');
            }
            
            // Load personalities if not already loaded from server data
            if (!availablePersonalities || availablePersonalities.length === 0) {
                console.log('üìã No personalities in server data, loading dynamically...');
                loadPersonalitiesDynamically();
            }
            
            // Start auto-refresh of status every 5 seconds
            setInterval(refreshStatus, STATUS_REFRESH_INTERVAL);
        }
        
        // Auto-resize textarea
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        
        // Track if request is in progress
        var requestInProgress = false;
        
        // Store current form selections
        var currentSelections = {
            outputType: 'speak',
            model: roverseerData.selectedModel || 'PenphinMind',
            voice: roverseerData.selectedVoice || 'en_US-amy'
        };
        
        // Function to toggle between personality and voice mode
        function togglePersonalityMode() {
            var usePersonality = document.getElementById('use-personality').checked;
            var voiceSelect = document.getElementById('voice-select');
            var customSystemGroup = document.getElementById('custom-system-group');
            var systemTextarea = document.getElementById('system-message');
            var chatHeaderTitle = document.getElementById('chat-header-title');
            
            // Clear current options
            voiceSelect.innerHTML = '';
            
            if (usePersonality) {
                // Show personalities
                customSystemGroup.style.display = 'none';
                systemTextarea.value = ''; // Clear system message
                
                // Update header for personality mode
                if (availablePersonalities && availablePersonalities.length > 0) {
                    var currentPersonality = availablePersonalities.find(p => p.name === currentPersonalityName);
                    if (currentPersonality) {
                        chatHeaderTitle.textContent = `RoverSeer Chat - ${currentPersonality.avatar_emoji} ${currentPersonality.name}`;
                    } else {
                        chatHeaderTitle.textContent = `RoverSeer Chat - ${availablePersonalities[0].avatar_emoji} ${availablePersonalities[0].name}`;
                    }
                } else {
                    chatHeaderTitle.textContent = 'RoverSeer Chat - Personality Mode';
                }
                
                if (availablePersonalities) {
                    availablePersonalities.forEach(function(personality) {
                        var option = document.createElement('option');
                        option.value = personality.voice_id;
                        option.setAttribute('data-personality', personality.name);
                        
                        // Show personality name with status indicator
                        var displayText = personality.avatar_emoji + ' ' + personality.name;
                        if (personality.status === 'fallback_ready' && personality.fallback_model) {
                            displayText += ' (‚Üí ' + personality.fallback_model.split(':')[0] + ')';
                            option.style.color = '#ff9800'; // Orange for fallback
                            option.title = `Preferred model not available. Will use: ${personality.fallback_model}`;
                        } else if (personality.status === 'ready') {
                            option.style.color = '#4caf50'; // Green for ready
                            option.title = `Ready with preferred model: ${personality.model_preference || 'system default'}`;
                        }
                        
                        option.textContent = displayText;
                        
                        // Select current personality if it matches
                        if (currentPersonalityName && currentPersonalityName === personality.name) {
                            option.selected = true;
                        }
                        
                        voiceSelect.appendChild(option);
                    });
                }
            } else {
                // Show voices with categories
                customSystemGroup.style.display = 'block';
                
                // Update header for model mode - show currently selected model
                var modelSelect = document.querySelector('[name="model"]');
                if (modelSelect && modelSelect.selectedOptions.length > 0) {
                    var selectedModelText = modelSelect.selectedOptions[0].textContent;
                    chatHeaderTitle.textContent = `RoverSeer Chat - ${selectedModelText}`;
                } else {
                    chatHeaderTitle.textContent = 'RoverSeer Chat - Model Mode';
                }
                
                // Check if we have categorized voices
                if (categorizedVoices && categorizedVoices.categorized) {
                    // Create optgroups for each category
                    for (var categoryName in categorizedVoices.categorized) {
                        if (categorizedVoices.categorized.hasOwnProperty(categoryName)) {
                            var voices = categorizedVoices.categorized[categoryName];
                            
                            // Create optgroup for this category (unless it's uncategorized)
                            if (categoryName === 'uncategorized') {
                                // Add uncategorized voices directly (no optgroup)
                                voices.forEach(function(voice) {
                                    var option = document.createElement('option');
                                    option.value = voice;
                                    option.textContent = voice;
                                    
                                    if (roverseerData.selectedVoice === voice) {
                                        option.selected = true;
                                    }
                                    
                                    voiceSelect.appendChild(option);
                                });
                            } else {
                                // Create optgroup for categorized voices
                                var optgroup = document.createElement('optgroup');
                                optgroup.label = categoryName;
                                
                                voices.forEach(function(voice) {
                                    var option = document.createElement('option');
                                    option.value = voice;
                                    option.textContent = voice;
                                    
                                    if (roverseerData.selectedVoice === voice) {
                                        option.selected = true;
                                    }
                                    
                                    optgroup.appendChild(option);
                                });
                                
                                voiceSelect.appendChild(optgroup);
                            }
                        }
                    }
                } else {
                    // Fallback to flat list if no categorization
                    availableVoices.forEach(function(voice) {
                        var option = document.createElement('option');
                        option.value = voice;
                        option.textContent = voice;
                        
                        // Select current voice if it matches
                        if (roverseerData.selectedVoice === voice) {
                            option.selected = true;
                        }
                        
                        voiceSelect.appendChild(option);
                    });
                }
            }
        }
        
        // Update selections when changed
        document.addEventListener('DOMContentLoaded', function() 
        {
            // Initialize the voice/personality dropdown
            togglePersonalityMode();
            
            // Debug: Log initial voice value
            console.log('Initial voice value after toggle:', document.querySelector('[name="voice"]').value);
            
            document.querySelector('[name="output_type"]').addEventListener('change', function(e) 
            {
                currentSelections.outputType = e.target.value;
            });
            document.querySelector('[name="model"]').addEventListener('change', function(e) 
            {
                currentSelections.model = e.target.value;
                
                // Update header if not in personality mode
                var usePersonality = document.getElementById('use-personality').checked;
                if (!usePersonality) {
                    var chatHeaderTitle = document.getElementById('chat-header-title');
                    var selectedModelText = e.target.selectedOptions[0].textContent;
                    chatHeaderTitle.textContent = `RoverSeer Chat - ${selectedModelText}`;
                }
            });
            document.querySelector('[name="voice"]').addEventListener('change', function(e) 
            {
                currentSelections.voice = e.target.value;
                console.log('Voice changed to:', e.target.value);
                
                var usePersonality = document.getElementById('use-personality').checked;
                
                if (usePersonality) 
                {
                    // Get the selected option's personality data
                    var selectedOption = e.target.options[e.target.selectedIndex];
                    var personalityName = selectedOption.getAttribute('data-personality');
                    
                    if (personalityName) 
                    {
                        // Update chat header immediately
                        var chatHeaderTitle = document.getElementById('chat-header-title');
                        var personalityEmoji = selectedOption.textContent.split(' ')[0];
                        chatHeaderTitle.textContent = `RoverSeer Chat - ${selectedOption.textContent}`;
                        
                        // Fetch personality details to get model preference
                        fetch('/system/personalities')
                            .then(response => response.json())
                            .then(data => 
                            {
                                var personality = data.personalities.find(p => p.name === personalityName);
                                if (personality && personality.model_preference) 
                                {
                                    // Update model selection if personality has a preference
                                    var modelSelect = document.querySelector('[name="model"]');
                                    
                                    // Check if model exists in dropdown
                                    var modelExists = false;
                                    for (var i = 0; i < modelSelect.options.length; i++) 
                                    {
                                        if (modelSelect.options[i].value === personality.model_preference) 
                                        {
                                            modelExists = true;
                                            break;
                                        }
                                    }
                                    
                                    if (modelExists) 
                                    {
                                        modelSelect.value = personality.model_preference;
                                        currentSelections.model = personality.model_preference;
                                        console.log('Updated model to personality preference:', personality.model_preference);
                                    } 
                                    else 
                                    {
                                        console.warn('Personality preferred model not available:', personality.model_preference);
                                        console.log('Available models:', Array.from(modelSelect.options).map(o => o.value));
                                        console.log('Personality status:', personality.status);
                                        console.log('Fallback model:', personality.fallback_model);
                                        
                                        // Enhanced fallback strategy with personality manager's logic
                                        var fallbackModel = personality.fallback_model || roverseerData.selectedModel || 'PenphinMind';
                                        var fallbackExists = false;
                                        
                                        for (var i = 0; i < modelSelect.options.length; i++) 
                                        {
                                            if (modelSelect.options[i].value === fallbackModel) 
                                            {
                                                fallbackExists = true;
                                                break;
                                            }
                                        }
                                        
                                        if (fallbackExists) 
                                        {
                                            modelSelect.value = fallbackModel;
                                            currentSelections.model = fallbackModel;
                                            console.log('Using intelligent fallback model:', fallbackModel);
                                        } 
                                        else if (modelSelect.options.length > 0) 
                                        {
                                            // Use first available model as last resort
                                            modelSelect.value = modelSelect.options[0].value;
                                            currentSelections.model = modelSelect.options[0].value;
                                            console.log('Using first available model as fallback:', currentSelections.model);
                                        }
                                    }
                                }
                                else 
                                {
                                    // Personality has no model preference - use default
                                    var modelSelect = document.querySelector('[name="model"]');
                                    modelSelect.value = roverseerData.selectedModel || 'PenphinMind';
                                    currentSelections.model = roverseerData.selectedModel || 'PenphinMind';
                                    console.log('Personality has no model preference, using default:', currentSelections.model);
                                }
                            })
                            .catch(error => {
                                console.error('‚ùå Error fetching personality details:', error);
                            });
                    }
                }
            });
            
            // Set initial values from the form elements
            currentSelections.outputType = document.querySelector('[name="output_type"]').value;
            currentSelections.model = document.querySelector('[name="model"]').value;
            currentSelections.voice = document.querySelector('[name="voice"]').value;
        });
        
        function refreshStatus() 
        {
            console.log('üîÑ Auto-refreshing status at', new Date().toLocaleTimeString());
            
            // Only refresh status, not reload the page
            fetch('/status_only')
                .then(response => response.json())
                .then(data => 
                {
                    console.log('üìä Status data received:', data);
                    
                    // Update sensor data
                    if (data.sensor_data) 
                    {
                        var sensorElement = document.querySelector('.sensor-data');
                        if (sensorElement) {
                            sensorElement.innerHTML = 
                                '<span class="sensor-item">üå°Ô∏è HAT: ' + data.sensor_data.hat_temperature + '</span>' +
                                '<span class="sensor-item">üñ•Ô∏è CPU: ' + data.sensor_data.cpu_temperature + '</span>' +
                                '<span class="sensor-item">üåä ' + data.sensor_data.pressure + '</span>' +
                                '<span class="sensor-item">üèîÔ∏è ' + data.sensor_data.altitude + '</span>' +
                                '<span class="sensor-item">üå¨Ô∏è Fan: ' + data.sensor_data.fan_state + '</span>';
                            console.log('‚úÖ Sensor data updated');
                        } else {
                            console.warn('‚ö†Ô∏è .sensor-data element not found');
                        }
                    }
                    
                    // Update TCP status - find or create TCP services container
                    if (data.tcp_status) 
                    {
                        var statusHtml = '';
                        for (const [name, info] of Object.entries(data.tcp_status)) 
                        {
                            if (name === "Ollama") 
                            {
                                statusHtml += '<span class="status-item">' +
                                    '<a href="http://roverseer.local:' + info.port + '/api/tags" onclick="window.open(this.href, \'_blank\'); return false;" class="status-link">' +
                                        info.status + ' ' + name + ' (' + info.port + ')' +
                                    '</a>' +
                                '</span>';
                            } 
                            else 
                            {
                                statusHtml += '<span class="status-item">' +
                                    '<a href="http://roverseer.local:' + info.port + '" onclick="window.open(this.href, \'_blank\'); return false;" class="status-link">' +
                                        info.status + ' ' + name + ' (' + info.port + ')' +
                                    '</a>' +
                                '</span>';
                            }
                        }
                        
                        // Find the TCP services container and update only that part
                        var statusSection = document.querySelector('.status-section');
                        var tcpContainer = statusSection ? statusSection.querySelector('.tcp-services') : null;
                        
                        if (tcpContainer) {
                            // Update existing TCP container
                            tcpContainer.innerHTML = statusHtml;
                            console.log('‚úÖ TCP services updated');
                        } else {
                            console.warn('‚ö†Ô∏è .tcp-services container not found');
                            // Create TCP container if it doesn't exist and insert before sensor data
                            if (statusSection) {
                                var sensorData = statusSection.querySelector('.sensor-data');
                                var newTcpContainer = document.createElement('div');
                                newTcpContainer.className = 'tcp-services';
                                newTcpContainer.innerHTML = statusHtml;
                                statusSection.insertBefore(newTcpContainer, sensorData);
                                console.log('‚úÖ TCP services container created and updated');
                            }
                        }
                    }
                    
                    // Update AI pipeline status
                    if (data.ai_pipeline) 
                    {
                        updateAIPipelineStatus(data.ai_pipeline);
                        console.log('‚úÖ AI pipeline status updated');
                    }
                })
                .catch(error => {
                    console.error('‚ùå Error refreshing status:', error);
                });
        }
        
        function updateAIPipelineStatus(pipeline) 
        {
            var pipelineDiv = document.querySelector('.ai-pipeline-status');
            if (pipelineDiv) 
            {
                var statusHtml = 
                    '<div class="pipeline-item">' +
                        '<span class="status-indicator">' + pipeline.status + '</span>' +
                        '<span>RoverSeer</span>' +
                        (pipeline.activity !== 'idle' ? '<span class="detail">' + pipeline.activity + '</span>' : '') +
                        (pipeline.detail ? '<span class="detail">(' + pipeline.detail + ')</span>' : '') +
                        (pipeline.requests ? '<span class="detail">[' + pipeline.requests + ']</span>' : '') +
                    '</div>';
                pipelineDiv.innerHTML = statusHtml;
            }
        }
        
        // Handle form submission
        function handleSubmit(event) 
        {
            event.preventDefault(); // Prevent default form submission
            
            // Immediately disable submit button and check if already in progress
            var submitButton = event.target.querySelector('[type="submit"]');
            if (submitButton.disabled || requestInProgress) 
            {
                return; // Already processing
            }
            
            // Check if RoverSeer is already busy by fetching current status
            fetch('/status_only')
                .then(response => response.json())
                .then(data => 
                {
                    // CRITICAL FIX: Check for actual activity strings returned by API
                    var current_activity = data.ai_pipeline && data.ai_pipeline.activity ? data.ai_pipeline.activity : 'idle';
                    
                    // Check if the activity indicates a busy state (match actual API response strings)
                    var is_busy = false;
                    if (data.ai_pipeline && data.ai_pipeline.status !== 'üîµ') {
                        // Check for the actual activity strings returned by sensors.py
                        if (current_activity.includes('listening') || 
                            current_activity.includes('processing') || 
                            current_activity.includes('thinking') || 
                            current_activity.includes('speaking') || 
                            current_activity.includes('playing') ||
                            current_activity.includes('interrupted')) {
                            is_busy = true;
                        }
                    }
                    
                    if (is_busy) 
                    {
                        // RoverSeer is busy
                        var messagesContainer = document.getElementById('messages-container');
                        var typingIndicator = document.getElementById('typing-indicator');
                        
                        var errorDiv = document.createElement('div');
                        errorDiv.className = 'message assistant';
                        errorDiv.innerHTML = 
                            '<div class="message-bubble">RoverSeer is currently busy (' + escapeHtml(current_activity) + '). Please wait a moment and try again.</div>' +
                            '<div class="message-info">System</div>';
                        messagesContainer.insertBefore(errorDiv, typingIndicator);
                        
                        // Scroll to bottom
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        
                        // Flash the status indicator
                        var statusIndicator = document.querySelector('.ai-pipeline-status .status-indicator');
                        if (statusIndicator) 
                        {
                            statusIndicator.style.animation = 'flash 0.5s ease-in-out 3';
                            setTimeout(() => 
                            {
                                statusIndicator.style.animation = '';
                            }, 1500);
                        }
                        
                        return; // Don't proceed with submission
                    }
                    
                    // RoverSeer is idle, proceed with submission
                    proceedWithSubmission(event);
                })
                .catch(error => 
                {
                    // If status check fails, proceed anyway
                    console.error('Failed to check status:', error);
                    proceedWithSubmission(event);
                });
        }
        
        function proceedWithSubmission(event) 
        {
            var submitButton = event.target.querySelector('[type="submit"]');
            
            // Set request in progress and disable button
            requestInProgress = true;
            submitButton.disabled = true;
            
            // Get form values
            var userInput = document.querySelector('[name="user_input"]').value.trim();
            var model = document.querySelector('[name="model"]').value;
            var modelDisplay = document.querySelector('[name="model"] option:checked').text;
            var voice = document.querySelector('[name="voice"]').value;
            var outputType = document.querySelector('[name="output_type"]').value;
            var usePersonality = document.getElementById('use-personality').checked;
            var systemMessage = document.getElementById('system-message').value.trim();
            
            // Generate a unique request ID to track this specific request
            var requestId = Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            
            // Validate voice selection - use default if empty
            if (!voice) 
            {
                voice = roverseerData.selectedVoice || 'en_US-amy-medium';
                console.warn('No voice selected, using default:', voice);
            }
            
            if (!userInput) 
            {
                // Re-enable if no input
                requestInProgress = false;
                submitButton.disabled = false;
                return;
            }
            
            // Add user message immediately
            var messagesContainer = document.getElementById('messages-container');
            var typingIndicator = document.getElementById('typing-indicator');
            
            var userDiv = document.createElement('div');
            userDiv.className = 'message user';
            userDiv.dataset.requestId = requestId; // Store request ID for reference
            userDiv.innerHTML = 
                '<div class="message-bubble">' + escapeHtml(userInput) + '</div>' +
                '<div class="message-info">You</div>';
            messagesContainer.insertBefore(userDiv, typingIndicator);
            
            // Clear input and reset height
            document.querySelector('[name="user_input"]').value = '';
            document.querySelector('[name="user_input"]').style.height = 'auto';
            
            // Show typing indicator with enhanced styling
            showTypingIndicator();
            
            // Update status to show activity immediately
            updateAIPipelineStatus({
                status: 'üü¢',
                activity: 'ü§î thinking',
                detail: modelDisplay.split(' ')[0]
            });
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Submit via AJAX
            var formData = new FormData();
            formData.append('action', 'chat');
            formData.append('user_input', userInput);
            formData.append('model', model);
            formData.append('voice', voice);
            formData.append('output_type', outputType);
            formData.append('use_personality', usePersonality);
            formData.append('system_message', systemMessage);
            formData.append('request_id', requestId); // Add request ID to track
            
            // Debug logging
            console.log('üîß FRONTEND DEBUG - Form submission:');
            console.log('  üìù user_input:', userInput);
            console.log('  ü§ñ model:', model);
            console.log('  üîä voice:', voice);
            console.log('  üéµ output_type:', outputType);
            console.log('  üé≠ use_personality:', usePersonality);
            console.log('  üìã system_message:', systemMessage);
            console.log('  üîë request_id:', requestId);
            console.log('Submitting form with voice:', voice);
            console.log('Use personality:', usePersonality);
            console.log('Request ID:', requestId);
            
            // Use fetch with a timeout to handle stuck requests
            var fetchPromise = fetch('/chat_ajax', {
                method: 'POST',
                body: formData
            });
            
            // Create a timeout promise
            var timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Request timed out')), 120000); // 120 second timeout (2 minutes)
            });
            
            // Race between fetch and timeout
            Promise.race([fetchPromise, timeoutPromise])
            .then(response => 
            {
                // Check if we got a 429 (Too Many Requests) status
                if (response.status === 429) 
                {
                    return response.json().then(data => 
                    {
                        throw new Error(data.error || 'RoverSeer is busy');
                    });
                }
                return response.json();
            })
            .then(data => 
            {
                            // Hide typing indicator with enhanced styling
            hideTypingIndicator();
                
                // Check if we already have a response for this request (prevent duplicates)
                if (document.querySelector(`.message.assistant[data-request-id="${requestId}"]`)) {
                    console.warn(`Duplicate response received for request ${requestId}, ignoring`);
                    return;
                }
                
                if (data.error) 
                {
                    // Show error message
                    var errorDiv = document.createElement('div');
                    errorDiv.className = 'message assistant';
                    errorDiv.dataset.requestId = requestId;
                    errorDiv.innerHTML = 
                        '<div class="message-bubble">Error: ' + escapeHtml(data.error) + '</div>' +
                        '<div class="message-info">System</div>';
                    messagesContainer.insertBefore(errorDiv, typingIndicator);
                } 
                else 
                {
                    // Add assistant message
                    var assistantDiv = document.createElement('div');
                    assistantDiv.className = 'message assistant';
                    assistantDiv.dataset.requestId = requestId;
                    
                    var messageContent = processThinkTags(data.reply);
                    
                    if (data.audio_url) 
                    {
                        messageContent += '<audio controls autoplay>' +
                            '<source src="' + data.audio_url + '" type="audio/wav">' +
                            'Your browser does not support the audio element.' +
                        '</audio>';
                    }
                    
                    // Get current personality info for display
                    var personalityDisplay = '';
                    if (data.personality) 
                    {
                        personalityDisplay = data.personality.avatar_emoji + ' ' + 
                                           data.personality.name;
                    }
                    if (!personalityDisplay.trim()) 
                    {
                        personalityDisplay = modelDisplay; // Fallback to model
                    }
                    
                    assistantDiv.innerHTML = 
                        '<div class="message-bubble">' + messageContent + '</div>' +
                        '<div class="message-info">' + escapeHtml(personalityDisplay) + '</div>';
                    messagesContainer.insertBefore(assistantDiv, typingIndicator);
                }
                
                // Update AI pipeline status
                if (data.ai_pipeline) 
                {
                    updateAIPipelineStatus(data.ai_pipeline);
                }
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // Re-enable submit button
                submitButton.disabled = false;
                
                // Restore form selections
                document.querySelector('[name="output_type"]').value = currentSelections.outputType;
                document.querySelector('[name="model"]').value = currentSelections.model;
                
                // Safely restore voice selection
                var voiceSelect = document.querySelector('[name="voice"]');
                if (voiceSelect && currentSelections.voice) 
                {
                    // Check if the voice option exists
                    var voiceExists = false;
                    for (var i = 0; i < voiceSelect.options.length; i++) 
                    {
                        if (voiceSelect.options[i].value === currentSelections.voice) 
                        {
                            voiceExists = true;
                            break;
                        }
                    }
                    
                    if (voiceExists) 
                    {
                        voiceSelect.value = currentSelections.voice;
                    } 
                    else 
                    {
                        console.warn('Voice option not found:', currentSelections.voice);
                        // Let it use the default selected option
                    }
                }
                
                // Clear request flag
                requestInProgress = false;
            })
            .catch(error => 
            {
                console.error('Error:', error);
                            // Hide typing indicator on error with enhanced styling
            hideTypingIndicator();
                
                // Check if we already have an error message for this request
                if (document.querySelector(`.message.assistant[data-request-id="${requestId}"]`)) {
                    console.warn(`Duplicate error response for request ${requestId}, ignoring`);
                    return;
                }
                
                // Add error message
                var errorDiv = document.createElement('div');
                errorDiv.className = 'message assistant';
                errorDiv.dataset.requestId = requestId;
                errorDiv.innerHTML = 
                    '<div class="message-bubble">Sorry, an error occurred: ' + escapeHtml(error.toString()) + '</div>' +
                    '<div class="message-info">System</div>';
                messagesContainer.insertBefore(errorDiv, typingIndicator);
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // Re-enable submit button
                submitButton.disabled = false;
                
                // Update status back to idle
                updateAIPipelineStatus({
                    status: 'üîµ',
                    activity: 'idle',
                    detail: ''
                });
                
                // Clear request flag
                requestInProgress = false;
            });
        }
        
        // Volume control and hush functions
        async function setVolume(volume) {
            try {
                const response = await fetch('/system/volume', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({volume: parseInt(volume)})
                });
                
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('volumeDisplay').textContent = data.volume + '%';
                    console.log('‚úÖ Volume set to:', data.volume + '%');
                } else {
                    console.error('‚ùå Failed to set volume');
                }
            } catch (error) {
                console.error('‚ùå Error setting volume:', error);
            }
        }
        
        async function hushAudio() {
            try {
                const response = await fetch('/system/hush', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('ü§´ Audio hushed:', data.message);
                    
                    // Update status to show audio stopped
                    updateAIPipelineStatus({
                        status: 'üîµ',
                        activity: 'idle',
                        detail: 'audio stopped'
                    });
                    
                    // Show brief feedback
                    showStatusMessage('Audio playback stopped', 'success');
                } else {
                    console.error('‚ùå Failed to hush audio');
                }
            } catch (error) {
                console.error('‚ùå Error hushing audio:', error);
            }
        }
        
        // Load current volume on page load
        async function loadCurrentVolume() {
            try {
                const response = await fetch('/system/volume');
                if (response.ok) {
                    const data = await response.json();
                    const volumeSlider = document.getElementById('volumeSlider');
                    const volumeDisplay = document.getElementById('volumeDisplay');
                    if (volumeSlider && volumeDisplay) {
                        volumeSlider.value = data.volume;
                        volumeDisplay.textContent = data.volume + '%';
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading volume:', error);
            }
        }
        
        // Helper function to show status messages
        function showStatusMessage(message, type) {
            // Create or update status message element
            let statusMsg = document.getElementById('temp-status-message');
            if (!statusMsg) {
                statusMsg = document.createElement('div');
                statusMsg.id = 'temp-status-message';
                statusMsg.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 1000;
                    padding: 10px 15px; border-radius: 5px; color: white;
                    font-weight: bold; transition: opacity 0.3s ease;
                `;
                document.body.appendChild(statusMsg);
            }
            
            statusMsg.textContent = message;
            statusMsg.style.backgroundColor = type === 'success' ? '#28a745' : '#dc3545';
            statusMsg.style.opacity = '1';
            
            setTimeout(() => {
                statusMsg.style.opacity = '0';
                setTimeout(() => statusMsg.remove(), 300);
            }, 3000);
        }

        // Mobile status toggle functionality
        function toggleMobileStatus() {
            var statusSection = document.querySelector('.status-section');
            var toggleButton = document.querySelector('.mobile-status-toggle');
            
            console.log('Toggling mobile status. Current classes:', statusSection.className);
            
            if (statusSection.classList.contains('mobile-expanded')) {
                statusSection.classList.remove('mobile-expanded');
                toggleButton.textContent = 'üì° Show Status';
                console.log('Status collapsed');
            } else {
                statusSection.classList.add('mobile-expanded');
                toggleButton.textContent = 'üì° Hide Status';
                console.log('Status expanded');
            }
        }
        
        // Show mobile toggle button only on mobile
        function setupMobileUI() {
            console.log('Setting up mobile UI. Window width:', window.innerWidth);
            
            var toggleButton = document.querySelector('.mobile-status-toggle');
            var statusSection = document.querySelector('.status-section');
            
            if (window.innerWidth <= 768) {
                toggleButton.style.display = 'block';
                console.log('Mobile mode: toggle button shown');
                // Start with status expanded on mobile for better UX
                statusSection.classList.add('mobile-expanded');
                toggleButton.textContent = 'üì° Hide Status';
            } else {
                toggleButton.style.display = 'none';
                // Ensure status section is visible on desktop
                statusSection.classList.add('mobile-expanded');
                console.log('Desktop mode: status always visible');
            }
        }
        
        // Reset pipeline function
        function resetPipeline() {
            fetch('/system/reset-pipeline', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('‚úÖ Pipeline reset successful:', data.message);
                    
                    // Update status to show idle
                    updateAIPipelineStatus({
                        status: 'üîµ',
                        activity: 'idle',
                        detail: ''
                    });
                    
                    // Show success message in chat
                    var messagesContainer = document.getElementById('messages-container');
                    var typingIndicator = document.getElementById('typing-indicator');
                    
                    var resetDiv = document.createElement('div');
                    resetDiv.className = 'message assistant';
                    resetDiv.innerHTML = 
                        '<div class="message-bubble">üîß Pipeline reset successfully. System is now ready.</div>' +
                        '<div class="message-info">System</div>';
                    messagesContainer.insertBefore(resetDiv, typingIndicator);
                    
                    // Scroll to bottom
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } else {
                    console.error('‚ùå Pipeline reset failed:', data.message);
                    alert('Pipeline reset failed: ' + data.message);
                }
            })
            .catch(error => {
                console.error('‚ùå Error resetting pipeline:', error);
                alert('Error resetting pipeline: ' + error);
            });
        }
        
        // Force reset system function for stuck states
        function forceResetSystem() {
            if (!confirm('‚ö° Emergency Reset: This will force-clear all system states and processes. Continue?')) {
                return;
            }
            
            fetch('/system/force-reset', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('‚úÖ Force reset successful:', data.message);
                    
                    // Update status to show idle
                    updateAIPipelineStatus({
                        status: 'üîµ',
                        activity: 'idle',
                        detail: ''
                    });
                    
                    // Show success message in chat
                    var messagesContainer = document.getElementById('messages-container');
                    var typingIndicator = document.getElementById('typing-indicator');
                    
                    var resetDiv = document.createElement('div');
                    resetDiv.className = 'message assistant';
                    resetDiv.innerHTML = 
                        '<div class="message-bubble">‚ö° Emergency reset completed. All states cleared.<br>' +
                        'Details: ' + JSON.stringify(data.reset_details, null, 2).replace(/"/g, '') + '</div>' +
                        '<div class="message-info">System</div>';
                    messagesContainer.insertBefore(resetDiv, typingIndicator);
                    
                    // Scroll to bottom
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Re-enable form if it was disabled
                    document.querySelector('[name="user_input"]').disabled = false;
                    document.querySelector('.send-button').disabled = false;
                    
                } else {
                    console.error('‚ùå Force reset failed:', data.message);
                    alert('Force reset failed: ' + data.message);
                }
            })
            .catch(error => {
                console.error('‚ùå Error during force reset:', error);
                alert('Error during force reset: ' + error);
            });
        }
        
        // Setup mobile UI on load and resize
        window.addEventListener('load', setupMobileUI);
        window.addEventListener('resize', setupMobileUI);
        
        // Personality/Model synchronization
        function handlePersonalityChange() {
            const personalitySelect = document.querySelector('select[name="voice"][data-personality-mode="true"]');
            if (!personalitySelect) return;
            
            personalitySelect.addEventListener('change', function() {
                const selectedPersonality = this.value;
                console.log('üé≠ Personality changed to:', selectedPersonality);
                
                // Find the personality data from the options
                const option = this.querySelector(`option[value="${selectedPersonality}"]`);
                const personalityName = option ? option.dataset.personalityName : null;
                
                if (personalityName) {
                    // Switch personality on backend
                    fetch('/system/personality/switch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: 'personality=' + encodeURIComponent(personalityName)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success' && data.model) {
                            console.log('‚úÖ Personality switched, updating model to:', data.model);
                            
                            // Update model select dropdown
                            const modelSelect = document.querySelector('select[name="model"]');
                            if (modelSelect) {
                                modelSelect.value = data.model;
                                modelSelect.dispatchEvent(new Event('change'));
                                console.log('üîß Model dropdown updated to:', data.model);
                            }
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Error switching personality:', error);
                    });
                }
            });
        }
        
        // Initialize personality change handler when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            handlePersonalityChange();
            console.log('üé≠ Personality change handler initialized');
        });
        
        // ======= INTERACTION MODE FUNCTIONS =======
        
        var interactionMode = {
            active: false,
            roundsRemaining: 0,
            totalRounds: 0,
            currentTurn: 'agent1', // 'agent1' or 'agent2'
            agent1: null,
            agent2: null,
            agent1Voice: null,
            agent2Voice: null,
            systemMessage: '',
            conversationHistory: [],
            intervalId: null
        };

        // Audio queue system for interaction mode
        var audioQueue = {
            queue: [],
            currentAudio: null,
            isPlaying: false,
            
            enqueue: function(audioElement, messageDiv) {
                this.queue.push({ audio: audioElement, messageDiv: messageDiv });
                this.processQueue();
            },
            
            processQueue: function() {
                if (this.isPlaying || this.queue.length === 0) {
                    return;
                }
                
                const { audio, messageDiv } = this.queue.shift();
                this.currentAudio = audio;
                this.isPlaying = true;
                
                // Add playing indicator to message
                if (messageDiv) {
                    const indicator = document.createElement('div');
                    indicator.className = 'audio-playing-indicator';
                    indicator.innerHTML = 'üîä Playing...';
                    indicator.style.cssText = 'font-size: 12px; color: #4CAF50; margin-top: 5px;';
                    messageDiv.appendChild(indicator);
                }
                
                // Set up event listeners
                audio.addEventListener('ended', () => {
                    this.onAudioEnded(messageDiv);
                });
                
                audio.addEventListener('error', () => {
                    console.error('Audio playback error');
                    this.onAudioEnded(messageDiv);
                });
                
                // Start playing
                audio.play().catch(error => {
                    console.error('Error starting audio playback:', error);
                    this.onAudioEnded(messageDiv);
                });
            },
            
            onAudioEnded: function(messageDiv) {
                this.isPlaying = false;
                this.currentAudio = null;
                
                // Remove playing indicator
                if (messageDiv) {
                    const indicator = messageDiv.querySelector('.audio-playing-indicator');
                    if (indicator) {
                        indicator.remove();
                    }
                }
                
                // Process next item in queue
                setTimeout(() => {
                    this.processQueue();
                }, 500); // Small delay between audio files
            },
            
            clear: function() {
                this.queue = [];
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
                this.isPlaying = false;
            }
        };
        
        function toggleInteractionPanel() {
            const controls = document.getElementById('interaction-controls');
            controls.classList.toggle('collapsed');
        }
        
        function toggleInteractionMode() {
            const checkbox = document.getElementById('interaction-mode-checkbox');
            const controls = document.getElementById('interaction-controls');
            const statusBar = document.getElementById('interaction-status-bar');
            const normalControls = document.querySelector('.chat-input-wrapper');
            
            if (checkbox.checked) {
                controls.style.display = 'block';
                normalControls.style.display = 'none';
                // Start with controls collapsed to save space
                controls.classList.add('collapsed');
            } else {
                controls.style.display = 'none';
                statusBar.style.display = 'none';
                normalControls.style.display = 'flex';
                
                // Stop any active interaction and clear audio queue
                if (interactionMode.active) {
                    stopInteraction();
                } else {
                    // Clear audio queue even if no active interaction
                    audioQueue.clear();
                }
            }
        }
        
        function playInteractionStartSound() {
            // Play a mystical rune sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            const gainNode2 = audioContext.createGain();
            
            // Create mystical chord - C and G (perfect fifth)
            oscillator1.frequency.setValueAtTime(261.63, audioContext.currentTime); // C4
            oscillator2.frequency.setValueAtTime(392.00, audioContext.currentTime); // G4
            
            oscillator1.type = 'sine';
            oscillator2.type = 'triangle';
            
            // Fade in and out
            gainNode1.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode1.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
            gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.8);
            
            gainNode2.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode2.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.15);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.9);
            
            oscillator1.connect(gainNode1);
            oscillator2.connect(gainNode2);
            gainNode1.connect(audioContext.destination);
            gainNode2.connect(audioContext.destination);
            
            oscillator1.start();
            oscillator2.start();
            oscillator1.stop(audioContext.currentTime + 1);
            oscillator2.stop(audioContext.currentTime + 1);
        }
        
        function updateCompactStatus() {
            const progressElement = document.getElementById('interaction-progress');
            const turnElement = document.getElementById('current-turn-indicator');
            
            if (interactionMode.active) {
                const currentRound = interactionMode.totalRounds - interactionMode.roundsRemaining + 1;
                progressElement.textContent = `ü§ù Round ${currentRound}/${interactionMode.totalRounds}`;
                
                const currentAgent = interactionMode.currentTurn === 'agent1' ? 
                    getAgentDisplayName(interactionMode.agent1) : 
                    getAgentDisplayName(interactionMode.agent2);
                turnElement.textContent = `üîÑ ${currentAgent} thinking...`;
            }
        }
        
        function startInteraction() {
            // Get values from form
            const agent1Select = document.getElementById('interaction-agent1');
            const agent2Select = document.getElementById('interaction-agent2');
            const voice1Select = document.getElementById('interaction-voice1');
            const voice2Select = document.getElementById('interaction-voice2');
            const roundsInput = document.getElementById('interaction-rounds');
            const systemMessageInput = document.getElementById('interaction-system-message');
            
            // Validate selections
            if (agent1Select.value === agent2Select.value) {
                alert('Please select two different agents for the interaction.');
                return;
            }
            
            // Play mystical start sound
            playInteractionStartSound();
            
            // Show compact status bar and collapse the panel after starting
            const controls = document.getElementById('interaction-controls');
            const statusBar = document.getElementById('interaction-status-bar');
            controls.classList.add('collapsed');
            statusBar.style.display = 'flex';
            
            // Initialize interaction state
            interactionMode.active = true;
            interactionMode.agent1 = agent1Select.value;
            interactionMode.agent2 = agent2Select.value;
            interactionMode.agent1Voice = voice1Select.value;
            interactionMode.agent2Voice = voice2Select.value;
            interactionMode.totalRounds = parseInt(roundsInput.value);
            interactionMode.roundsRemaining = interactionMode.totalRounds;
            interactionMode.systemMessage = systemMessageInput.value;
            interactionMode.currentTurn = 'agent1';
            interactionMode.conversationHistory = [];
            
            // Update UI
            document.getElementById('interaction-start-btn').disabled = true;
            document.getElementById('interaction-stop-btn').disabled = false;
            
            // Update status bar
            updateCompactStatus();
            agent1Select.disabled = true;
            agent2Select.disabled = true;
            voice1Select.disabled = true;
            voice2Select.disabled = true;
            roundsInput.disabled = true;
            systemMessageInput.disabled = true;
            
            // Disable normal chat input during interaction
            document.querySelector('[name="user_input"]').disabled = true;
            document.querySelector('.send-button').disabled = true;
            
            // Update status display
            updateInteractionStatus();
            updateCompactStatus();
            
            // Add initial system message to chat
            const messagesContainer = document.getElementById('messages-container');
            const typingIndicator = document.getElementById('typing-indicator');
            
            const systemDiv = document.createElement('div');
            systemDiv.className = 'message system';
            systemDiv.innerHTML = 
                '<div class="message-bubble">ü§ù Starting interaction between ' + 
                escapeHtml(getAgentDisplayName(interactionMode.agent1)) + ' and ' + 
                escapeHtml(getAgentDisplayName(interactionMode.agent2)) + 
                ' for ' + interactionMode.totalRounds + ' rounds</div>' +
                '<div class="message-info">System</div>';
            messagesContainer.insertBefore(systemDiv, typingIndicator);
            
            // Start with agent1's first message
            sendInteractionMessage('Hello! I\'m ready to start our conversation.');
        }
        
        function stopInteraction() {
            interactionMode.active = false;
            
            // Clear audio queue
            audioQueue.clear();
            
            // Hide status bar
            const statusBar = document.getElementById('interaction-status-bar');
            statusBar.style.display = 'none';
            
            // Play stop interaction sound
            playInteractionStopSound();
            
            // If output type was speak, also play device sound
            const outputTypeSelect = document.getElementById('interaction-output-type');
            if (outputTypeSelect && outputTypeSelect.value === 'speak') {
                // Send a request to play stop sound on device
                fetch('/interaction/stop-sound', {
                    method: 'POST'
                }).catch(error => {
                    console.error('Error playing device stop sound:', error);
                });
            }
            
            // Re-enable controls
            document.getElementById('interaction-start-btn').disabled = false;
            document.getElementById('interaction-stop-btn').disabled = true;
            document.getElementById('interaction-agent1').disabled = false;
            document.getElementById('interaction-agent2').disabled = false;
            document.getElementById('interaction-voice1').disabled = false;
            document.getElementById('interaction-voice2').disabled = false;
            document.getElementById('interaction-rounds').disabled = false;
            document.getElementById('interaction-system-message').disabled = false;
            if (outputTypeSelect) outputTypeSelect.disabled = false;
            
            // Re-enable normal chat input
            document.querySelector('[name="user_input"]').disabled = false;
            document.querySelector('.send-button').disabled = false;
            
            // Clear status
            updateCompactStatus();
            
            // Add completion message
            const messagesContainer = document.getElementById('messages-container');
            const typingIndicator = document.getElementById('typing-indicator');
            
            const completeDiv = document.createElement('div');
            completeDiv.className = 'message system';
            completeDiv.innerHTML = 
                '<div class="message-bubble">üèÅ Interaction completed! Total exchanges: ' + 
                (interactionMode.totalRounds - interactionMode.roundsRemaining) + '</div>';
            messagesContainer.insertBefore(completeDiv, typingIndicator);
            
            // Collapse the interaction controls
            const interactionControls = document.getElementById('interaction-controls');
            const collapseIcon = interactionControls.querySelector('.collapse-icon');
            const interactionBody = interactionControls.querySelector('.interaction-body');
            
            if (interactionBody.style.display !== 'none') {
                interactionBody.style.display = 'none';
                collapseIcon.textContent = '‚ñ∂';
            }
            
            // Update AI pipeline status to idle
            updateAIPipelineStatus({
                status: 'üîµ',
                activity: 'idle',
                detail: ''
            });
            
            // Clear conversation history after a short delay
            setTimeout(() => {
                interactionMode.conversationHistory = [];
            }, 1000);
            
            // Scroll to show completion message
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function playInteractionStopSound() {
            // Play a descending completion sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const gainNode = audioContext.createGain();
            
            // Create three descending notes
            const notes = [
                { freq: 659.25, start: 0 },      // E5
                { freq: 523.25, start: 0.15 },   // C5
                { freq: 392, start: 0.3 }         // G4
            ];
            
            notes.forEach(note => {
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime + note.start);
                oscillator.type = 'sine';
                
                oscillator.connect(gainNode);
                oscillator.start(audioContext.currentTime + note.start);
                oscillator.stop(audioContext.currentTime + note.start + 0.15);
            });
            
            // Fade out
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            gainNode.connect(audioContext.destination);
        }
        
        function updateInteractionStatus() {
            const statusDiv = document.getElementById('interaction-status');
            const currentAgent = interactionMode.currentTurn === 'agent1' ? 
                getAgentDisplayName(interactionMode.agent1) : 
                getAgentDisplayName(interactionMode.agent2);
            
            // Update compact status bar
            updateCompactStatus();
        }
        
        function getAgentDisplayName(agentValue) {
            // Extract display name from select option
            const select = document.getElementById('interaction-agent1');
            const option = select.querySelector(`option[value="${agentValue}"]`);
            return option ? option.textContent : agentValue;
        }
        
        function sendInteractionMessage(userMessage) {
            if (!interactionMode.active) return;
            
            const currentAgent = interactionMode.currentTurn === 'agent1' ? 
                interactionMode.agent1 : interactionMode.agent2;
            const currentVoice = interactionMode.currentTurn === 'agent1' ? 
                interactionMode.agent1Voice : interactionMode.agent2Voice;
            const currentAgentDisplay = getAgentDisplayName(currentAgent);
            
            // Debug log
            console.log('üé≠ Sending interaction message:', {
                userMessage: userMessage,
                currentAgent: currentAgent,
                currentVoice: currentVoice,
                currentTurn: interactionMode.currentTurn,
                roundsRemaining: interactionMode.roundsRemaining
            });
            
            // Add user message to chat (from previous agent)
            if (userMessage !== 'Hello! I\'m ready to start our conversation.') {
                const messagesContainer = document.getElementById('messages-container');
                const typingIndicator = document.getElementById('typing-indicator');
                
                const prevAgent = interactionMode.currentTurn === 'agent1' ? 'agent2' : 'agent1';
                const prevAgentDisplay = getAgentDisplayName(interactionMode.currentTurn === 'agent1' ? 
                    interactionMode.agent2 : interactionMode.agent1);
                
                // Alternate between user and assistant classes based on which agent is speaking
                // For agent1, use the user class (blue bubbles on right)
                // For agent2, use the assistant class (gray bubbles on left)
                const messageClass = prevAgent === 'agent1' ? 'user' : 'assistant';
                    
                const userDiv = document.createElement('div');
                userDiv.className = `message ${messageClass}`;
                userDiv.innerHTML = 
                    '<div class="message-bubble">' + processThinkTags(userMessage) + '</div>' +
                    '<div class="message-info">' + escapeHtml(prevAgentDisplay) + '</div>';
                messagesContainer.insertBefore(userDiv, typingIndicator);
            }
            
            // Build conversation context
            let systemMessage = interactionMode.systemMessage || '';
            if (systemMessage) {
                systemMessage += '\n\n';
            }
            systemMessage += 'You are in a conversation with another AI agent. Respond naturally and engage with their message.';
            
            // Play LLM thinking sound
            playLLMThinkingSound();
            
            // Prepare form data
            const formData = new FormData();
            formData.append('action', 'chat');
            formData.append('user_input', userMessage);
            formData.append('model', currentAgent.replace('PERSONALITY:', ''));
            formData.append('voice', currentVoice); // Use selected voice
            
            // Get selected output type from dropdown
            const outputTypeSelect = document.getElementById('interaction-output-type');
            const selectedOutputType = outputTypeSelect ? outputTypeSelect.value : 'text';
            formData.append('output_type', selectedOutputType);
            
            formData.append('use_personality', currentAgent.startsWith('PERSONALITY:'));
            formData.append('system_message', systemMessage);
            formData.append('interaction_mode', 'true');
            formData.append('conversation_history', JSON.stringify(interactionMode.conversationHistory));
            
            // Show typing indicator for the current agent
            const typingIndicator = document.getElementById('typing-indicator');
            const messagesContainer = document.getElementById('messages-container');
            
            // For agent1, use user typing style (right side)
            // For agent2, use assistant typing style (left side)
            typingIndicator.className = `typing-indicator ${interactionMode.currentTurn === 'agent1' ? 'user' : 'assistant'}`;
            
            // Update typing text to show which agent is thinking
            const typingText = typingIndicator.querySelector('.typing-text');
            if (typingText) {
                const agentName = interactionMode.currentTurn === 'agent1' ? 'Agent 1' : 'Agent 2';
                typingText.textContent = `${agentName} is thinking...`;
            }
            
            // Show the enhanced typing indicator
            showTypingIndicator();
            
            // Update status
            updateAIPipelineStatus({
                status: 'üü¢',
                activity: 'ü§î ' + currentAgentDisplay + ' thinking',
                detail: ''
            });
            
            // Scroll to show typing indicator
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Send request
            fetch('/chat_ajax', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                hideTypingIndicator();
                typingIndicator.className = 'typing-indicator'; // Reset class
                
                if (data.error) {
                    // Handle error
                    console.error('Interaction error:', data.error);
                    alert('Interaction error: ' + data.error);
                    stopInteraction();
                    return;
                }
                
                // Play completion sound
                playLLMCompleteSound();
                
                // Add the response to chat
                const messagesContainer = document.getElementById('messages-container');
                
                // Determine the class based on which agent is responding
                // For agent1, use user class (blue bubbles on right)
                // For agent2, use assistant class (gray bubbles on left)
                const messageClass = interactionMode.currentTurn === 'agent1' ? 'user' : 'assistant';
                
                const assistantDiv = document.createElement('div');
                assistantDiv.className = `message ${messageClass}`;
                
                // Always process think tags for both agents
                const processedReply = processThinkTags(data.reply);
                
                // Handle audio if present
                let audioElement = null;
                if (data.audio_url) {
                    audioElement = new Audio(data.audio_url);
                    // Add audio controls to the message but don't autoplay
                    const audioHtml = '<audio controls style="width: 100%; margin-top: 8px;">' +
                        '<source src="' + data.audio_url + '" type="audio/wav">' +
                        'Your browser does not support the audio element.' +
                    '</audio>';
                    
                    assistantDiv.innerHTML = 
                        '<div class="message-bubble">' + processedReply + audioHtml + '</div>' +
                        '<div class="message-info">' + escapeHtml(currentAgentDisplay) + '</div>';
                } else {
                    assistantDiv.innerHTML = 
                        '<div class="message-bubble">' + processedReply + '</div>' +
                        '<div class="message-info">' + escapeHtml(currentAgentDisplay) + '</div>';
                }
                
                messagesContainer.insertBefore(assistantDiv, typingIndicator);
                
                // Add to audio queue for sequential playback
                if (audioElement) {
                    audioQueue.enqueue(audioElement, assistantDiv);
                }
                
                // Add to conversation history
                interactionMode.conversationHistory.push([userMessage, data.reply]);
                
                // Switch turns
                if (interactionMode.currentTurn === 'agent2') {
                    // Round complete
                    interactionMode.roundsRemaining--;
                    
                    if (interactionMode.roundsRemaining <= 0) {
                        // Interaction complete
                        console.log('üé≠ Interaction complete - no rounds remaining');
                        stopInteraction();
                        return;
                    }
                }
                
                // Switch to other agent
                interactionMode.currentTurn = interactionMode.currentTurn === 'agent1' ? 'agent2' : 'agent1';
                updateInteractionStatus();
                
                // Continue conversation after a short delay
                setTimeout(() => {
                    if (interactionMode.active) {
                        console.log('üé≠ Continuing interaction with response:', data.reply.substring(0, 50) + '...');
                        sendInteractionMessage(data.reply);
                    }
                }, 2000); // 2 second delay between turns
                
                // Update status
                updateAIPipelineStatus({
                    status: 'üîµ',
                    activity: 'idle',
                    detail: ''
                });
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            })
            .catch(error => {
                console.error('Interaction error:', error);
                hideTypingIndicator();
                typingIndicator.className = 'typing-indicator'; // Reset class
                alert('Failed to get response: ' + error.message);
                stopInteraction();
            });
        }
        
        // Add LLM thinking and completion sounds
        function playLLMThinkingSound() {
            // Play a contemplative sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Soft ascending tone
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
            oscillator.frequency.linearRampToValueAtTime(523.25, audioContext.currentTime + 0.3); // C5
            
            oscillator.type = 'sine';
            
            // Gentle fade in and out
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.4);
        }
        
        function playLLMCompleteSound() {
            // Play a completion sound using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator1 = audioContext.createOscillator();
            const oscillator2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const merger = audioContext.createChannelMerger(2);
            
            // Two-note completion chord
            oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
            oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
            
            oscillator1.type = 'sine';
            oscillator2.type = 'sine';
            
            // Quick fade in and out
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
            
            oscillator1.connect(merger, 0, 0);
            oscillator2.connect(merger, 0, 1);
            merger.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator1.start();
            oscillator2.start();
            oscillator1.stop(audioContext.currentTime + 0.25);
            oscillator2.stop(audioContext.currentTime + 0.25);
        }
        
        // Sync voice selection when agent changes
        function syncVoiceWithAgent(agentNum) {
            const agentSelect = document.getElementById(`interaction-agent${agentNum}`);
            const voiceSelect = document.getElementById(`interaction-voice${agentNum}`);
            const selectedAgent = agentSelect.value;
            
            // If it's a personality, try to match its voice
            if (selectedAgent.startsWith('PERSONALITY:')) {
                const personalityName = selectedAgent.substring(12);
                
                if (personalityVoiceMap[personalityName]) {
                    const preferredVoice = personalityVoiceMap[personalityName];
                    // Try to select this voice if it exists
                    for (let option of voiceSelect.options) {
                        if (option.value === preferredVoice) {
                            voiceSelect.value = preferredVoice;
                            break;
                        }
                    }
                }
            }
        }
        
        // Add event listeners when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            // Existing initialization
            handlePersonalityChange();
            console.log('üé≠ Personality change handler initialized');
            
            // Add agent change listeners for voice syncing
            const agent1Select = document.getElementById('interaction-agent1');
            const agent2Select = document.getElementById('interaction-agent2');
            
            if (agent1Select) {
                agent1Select.addEventListener('change', () => syncVoiceWithAgent(1));
                // Initial sync
                syncVoiceWithAgent(1);
            }
            
            if (agent2Select) {
                agent2Select.addEventListener('change', () => syncVoiceWithAgent(2));
                // Initial sync
                syncVoiceWithAgent(2);
            }
        });
        
        // Add a general loading indicator function that can be used throughout the app
        function showLoading(targetElement, message = "Loading") 
        {
            // Create loading HTML
            const loadingHtml = `
                <div class="loading-indicator active">
                    <div>${message}</div>
                    <div class="star-loading">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </div>
            `;
            
            // Set loading HTML to target element
            if (typeof targetElement === 'string') {
                document.querySelector(targetElement).innerHTML = loadingHtml;
            } else {
                targetElement.innerHTML = loadingHtml;
            }
        }

        function hideLoading(targetElement) 
        {
            // Find loading indicator in target element
            const loadingIndicator = (typeof targetElement === 'string') 
                ? document.querySelector(`${targetElement} .loading-indicator`)
                : targetElement.querySelector('.loading-indicator');
            
            // Hide loading indicator if found
            if (loadingIndicator) {
                loadingIndicator.classList.remove('active');
            }
        }

        /* Enhanced typing indicator management */
        function updateLoadingIndicators() {
            // Find all loading indicators except our main typing indicator which is already styled
            const loadingIndicators = document.querySelectorAll('.loading-indicator, #processing-indicator');
            
            loadingIndicators.forEach(indicator => {
                if (!indicator.classList.contains('enhanced-loading-applied')) {
                    // Create enhanced loading animation
                    const loadingContainer = document.createElement('div');
                    loadingContainer.className = 'loading-text';
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = 'Processing';
                    
                    const starLoading = document.createElement('span');
                    starLoading.className = 'star-loading';
                    
                    // Add three dots with enhanced styling
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('span');
                        dot.className = 'dot';
                        dot.style.setProperty('--index', i);
                        starLoading.appendChild(dot);
                    }
                    
                    loadingContainer.appendChild(textSpan);
                    loadingContainer.appendChild(starLoading);
                    
                    // Clear the indicator and add our new animation
                    indicator.innerHTML = '';
                    indicator.appendChild(loadingContainer);
                    
                    // Mark as processed
                    indicator.classList.add('enhanced-loading-applied');
                }
            });
        }
        
        /* Ensure typing indicator works properly */
        function showTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                console.log('ü§î Showing enhanced typing indicator');
                typingIndicator.style.display = 'flex';
                typingIndicator.classList.add('active');
                
                // Scroll to show typing indicator
                typingIndicator.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                console.log('‚úÖ Enhanced typing indicator shown');
            } else {
                console.error('‚ùå Typing indicator element not found!');
            }
        }
        
        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                console.log('ü§´ Hiding enhanced typing indicator');
                typingIndicator.style.display = 'none';
                typingIndicator.classList.remove('active');
                console.log('‚úÖ Enhanced typing indicator hidden');
            }
        }

        // Call this function on page load and whenever new messages are added
        document.addEventListener('DOMContentLoaded', function() {
            // Store references to original functions
            if (typeof addMessageToChat !== 'undefined') {
                const originalAddMessageToChat = addMessageToChat;
                addMessageToChat = function(message, isUser, additionalClasses = '') {
                    originalAddMessageToChat(message, isUser, additionalClasses);
                    updateLoadingIndicators();
                };
            }
            
            if (typeof showTypingIndicator !== 'undefined') {
                const originalShowTypingIndicator = showTypingIndicator;
                showTypingIndicator = function() {
                    originalShowTypingIndicator();
                    updateLoadingIndicators();
                };
            }
            
            // Initial update of loading indicators
            updateLoadingIndicators();
            
            // Load current volume
            loadCurrentVolume();
        });
    </script>
    
    {% if reply_text %}
    <!-- Messages are already rendered server-side, no need for JavaScript -->
    {% endif %}
</head>
<body>
    <div class="topbar">
        <div><strong>RoverSeer</strong></div>
        <div class="status-container">
            <!-- Mobile toggle button for expanded status -->
            <button class="mobile-status-toggle" onclick="toggleMobileStatus()" style="display: none;">
                üì° Show Status
            </button>
            
            <!-- Collapsible status section - includes TCP services, sensor data, and refresh -->
            <div class="status-section">
                <!-- TCP Services -->
                <div class="tcp-services">
                    {% for name, info in statuses.items() %}
                        <span class="status-item">
                            {% if name == "Ollama" %}
                                <a href="http://roverseer.local:{{ info.port }}/api/tags" onclick="window.open(this.href, '_blank'); return false;" class="status-link">
                                    {{ info.status }} {{ name }} ({{ info.port }})
                                </a>
                            {% else %}
                                <a href="http://roverseer.local:{{ info.port }}" onclick="window.open(this.href, '_blank'); return false;" class="status-link">
                                    {{ info.status }} {{ name }} ({{ info.port }})
                                </a>
                            {% endif %}
                        </span>
                    {% endfor %}
                </div>
                
                <!-- Sensor Data (moved from essential-status) -->
                <div class="sensor-data">
                    <span class="sensor-item">üå°Ô∏è HAT: {{ sensor_data.hat_temperature }}</span>
                    <span class="sensor-item">üñ•Ô∏è CPU: {{ sensor_data.cpu_temperature }}</span>
                    <span class="sensor-item">üåä {{ sensor_data.pressure }}</span>
                    <span class="sensor-item">üèîÔ∏è {{ sensor_data.altitude }}</span>
                    <span class="sensor-item">üå¨Ô∏è Fan: {{ sensor_data.fan_state }}</span>
                </div>
                
                <!-- Refresh button (moved from outside) -->
                <span class="refresh" onclick="refreshStatus()">üîÑ</span>
            </div>
            
            <!-- Essential status - only AI pipeline always visible -->
            <div class="essential-status">
                <div class="ai-pipeline-status">
                    <div class="pipeline-item">
                        <span class="status-indicator">{{ ai_pipeline.status }}</span>
                        <span>RoverSeer</span>
                        {% if ai_pipeline.activity != 'idle' %}
                        <span class="detail">{{ ai_pipeline.activity }}</span>
                        {% endif %}
                        {% if ai_pipeline.detail %}
                        <span class="detail">({{ ai_pipeline.detail }})</span>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="chatbox">
        <div class="chat-header">
            <h2 id="chat-header-title">RoverSeer Chat{% if current_personality %} - {{ current_personality.avatar_emoji }} {{ current_personality.name }}{% endif %}</h2>
            <div class="action-buttons">
                <form method="post" style="display: inline;">
                    <input type="hidden" name="action" value="clear_context">
                    <button type="submit" class="clear-button">üóëÔ∏è Clear</button>
                </form>
                <button onclick="resetPipeline()" class="clear-button" style="background: #ff6b35;">üîß Reset</button>
                <button onclick="forceResetSystem()" class="clear-button" style="background: #dc3545;">‚ö° Force Reset</button>
                <button onclick="hushAudio()" class="clear-button" style="background: #e74c3c;">ü§´ Hush</button>
                <div class="volume-control" style="display: inline-flex; align-items: center; margin-left: 10px;">
                    <span style="margin-right: 5px;">üîä</span>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50" 
                           style="width: 80px;" onchange="setVolume(this.value)">
                    <span id="volumeDisplay" style="margin-left: 5px; font-size: 12px;">50%</span>
                </div>
                <button onclick="window.location.href='/system'" class="logs-button">üìä System</button>
                <button onclick="window.location.href='/audiocraft'" class="logs-button" style="background: #667eea;">üéµ AudioCraft</button>
                <button onclick="window.location.href='/emergent_narrative'" class="logs-button" style="background: #9b59b6;">üé≠ Emergent Narrative</button>
            </div>
        </div>
        
        <div class="messages-container" id="messages-container">
            {% for user, reply, model in history %}
                <div class="message user">
                    <div class="message-bubble">{{ user }}</div>
                    <div class="message-info">You</div>
                </div>
                <div class="message assistant">
                    <div class="message-bubble">{{ reply }}</div>
                    <div class="message-info">{{ model }}</div>
                </div>
            {% endfor %}
            
            <div class="typing-indicator" id="typing-indicator">
                <div class="typing-bubble">
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                    <div class="typing-text">RoverSeer is thinking...</div>
                </div>
            </div>
        </div>
        
        <div class="chat-input-container">
            <!-- Interaction Mode Toggle -->
            <div class="interaction-mode-toggle">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                    <input type="checkbox" id="interaction-mode-checkbox" onchange="toggleInteractionMode()">
                    <span>üé≠ Interaction Mode</span>
                </label>
            </div>
            
            <!-- Compact Status Bar (shown when interaction is active) -->
            <div id="interaction-status-bar" class="interaction-status-bar" style="display: none;">
                <div class="status-left">
                    <span id="interaction-progress">ü§ù Round 1/5</span>
                    <span id="current-turn-indicator">üîÑ Agent 1 thinking...</span>
                </div>
                <div class="status-right">
                    <button onclick="stopInteraction()">‚èπÔ∏è Stop</button>
                    <button onclick="toggleInteractionPanel()">‚öôÔ∏è Settings</button>
                </div>
            </div>
            
            <!-- Interaction Mode Configuration (collapsible) -->
            <div id="interaction-controls" class="interaction-controls collapsed" style="display: none;">
                <div class="interaction-header" onclick="toggleInteractionPanel()">
                    <span>‚öôÔ∏è Configure Agents</span>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                
                <div class="interaction-body">
                    <div class="interaction-row">
                        <label>Agent 1:</label>
                        <select id="interaction-agent1" style="flex: 1;">
                            {% if categorized_models %}
                                {% for category_name, models_list in categorized_models.items() %}
                                    <optgroup label="{{ category_name }}">
                                        {% for model in models_list %}
                                            <option value="{{ model.full_name }}">{{ model.display_name }}</option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% endif %}
                        </select>
                        <select id="interaction-voice1" style="flex: 1;">
                            {% if categorized_voices %}
                                {% for category, voice_list in categorized_voices.categorized.items() %}
                                    <optgroup label="{{ category|title }}">
                                        {% for voice in voice_list %}
                                            <option value="{{ voice }}">{{ voice }}</option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% else %}
                                {% for voice in voices %}
                                    <option value="{{ voice }}">{{ voice }}</option>
                                {% endfor %}
                            {% endif %}
                        </select>
                    </div>
                    
                    <div class="interaction-row">
                        <label>Agent 2:</label>
                        <select id="interaction-agent2" style="flex: 1;">
                            {% if categorized_models %}
                                {% for category_name, models_list in categorized_models.items() %}
                                    <optgroup label="{{ category_name }}">
                                        {% for model in models_list %}
                                            <option value="{{ model.full_name }}" {% if loop.index0 == 1 %}selected{% endif %}>
                                                {{ model.display_name }}
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% endif %}
                        </select>
                        <select id="interaction-voice2" style="flex: 1;">
                            {% if categorized_voices %}
                                {% for category, voice_list in categorized_voices.categorized.items() %}
                                    <optgroup label="{{ category|title }}">
                                        {% for voice in voice_list %}
                                            <option value="{{ voice }}" {% if loop.index0 == 1 %}selected{% endif %}>{{ voice }}</option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% else %}
                                {% for voice in voices %}
                                    <option value="{{ voice }}" {% if loop.index0 == 1 %}selected{% endif %}>{{ voice }}</option>
                                {% endfor %}
                            {% endif %}
                        </select>
                    </div>
                    
                    <div class="interaction-row">
                        <label>Rounds:</label>
                        <input type="number" id="interaction-rounds" min="1" max="20" value="5" style="width: 60px;">
                        
                        <label style="margin-left: 16px;">Output:</label>
                        <select id="interaction-output-type" style="flex: 1;">
                            <option value="text">üìù Text Only</option>
                            <option value="speak">üîä Play on RoverSeer</option>
                            <option value="audio_file">üéµ Download Audio</option>
                        </select>
                    </div>
                    
                    <div class="interaction-row" style="flex-direction: column; align-items: stretch;">
                        <label>Context (optional):</label>
                        <textarea id="interaction-system-message" 
                                  placeholder="e.g., 'Discuss philosophy', 'Debate technology'"></textarea>
                    </div>
                    
                    <div class="interaction-buttons" style="display: flex; gap: 8px; justify-content: center; margin-top: 12px;">
                        <button id="interaction-start-btn" class="interaction-button start" onclick="startInteraction()" style="flex: 1;">
                            ‚ñ∂Ô∏è Start Interaction
                        </button>
                        <button id="interaction-stop-btn" class="interaction-button stop" onclick="stopInteraction()" disabled style="flex: 1;">
                            ‚èπÔ∏è Stop Interaction
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Normal Chat Input -->
            <form method="post" id="chat_form" class="chat-input-form" onsubmit="handleSubmit(event)">
                <input type="hidden" name="action" value="chat">
                
                <div class="chat-input-wrapper">
                    <div class="chat-controls">
                        <select name="output_type" title="Output Type">
                            <option value="speak">üîä RoverSeer</option>
                            <option value="audio_file">üéµ Local Audio</option>
                            <option value="text">üìù Text Only</option>
                        </select>
                        
                        <select name="model" title="AI Model">
                            {% if categorized_models %}
                                {% for category_name, models_list in categorized_models.items() %}
                                    <optgroup label="{{ category_name }}">
                                        {% for model in models_list %}
                                            <option value="{{ model.full_name }}" {% if model.full_name == selected_model %}selected{% endif %}>
                                                {{ model.display_name }}
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                {% endfor %}
                            {% else %}
                                <!-- Fallback to flat list if no categorization -->
                                {% for tag in models %}
                                    <option value="{{ tag.full_name }}" {% if tag.full_name == selected_model %}selected{% endif %}>
                                        {{ tag.display_name }}
                                    </option>
                                {% endfor %}
                            {% endif %}
                        </select>
                        
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="use-personality" name="use_personality" checked onchange="togglePersonalityMode()">
                            <span style="white-space: nowrap;">Use Personality</span>
                        </label>
                        
                        <select name="voice" id="voice-select" title="Voice/Personality">
                            <!-- Will be populated dynamically based on checkbox state -->
                        </select>
                    </div>
                    
                    <div id="custom-system-group" style="display: none; margin-top: 8px;">
                        <textarea 
                            name="system" 
                            id="system-message" 
                            class="chat-textarea" 
                            style="min-height: 60px; font-size: 14px;"
                            placeholder="Enter custom system message..."
                            oninput="autoResize(this)"
                        ></textarea>
                    </div>
                    
                    <div class="chat-message-row" style="display: flex; gap: 12px; align-items: flex-end; margin-top: 12px;">
                        <textarea 
                            name="user_input" 
                            class="chat-textarea" 
                            style="flex: 1;"
                            placeholder="Type a message..."
                            oninput="autoResize(this)"
                            onkeydown="if(event.key === 'Enter' && (event.metaKey || event.ctrlKey || !event.shiftKey)) { event.preventDefault(); document.getElementById('chat_form').requestSubmit(); }"
                        ></textarea>
                        
                        <button type="submit" class="send-button">Send</button>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Data for JavaScript -->
    <script type="application/json" id="roverseer-data">
    {
        "voices": {{ voices | tojson }},
        "categorizedVoices": {{ categorized_voices | tojson }},
        "personalities": {{ personalities | tojson }},
        "currentPersonality": {{ current_personality | tojson }},
        "selectedModel": {{ selected_model | tojson }},
        "selectedVoice": {{ selected_voice | tojson }}
    }
    </script>
</body>
</html> 